#score: {'data3D.txt': -0.16981220000000005}
#standard deviation: 0.05149417570133541
#island_id: 1
#version_generated: 3
#generate time00:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_neighbors.index(min(site_neighbors)) * N + k][0] += np.exp(-abs(total_spin)) * (1 if min(site_neighbors) < 0 else 0)
          priorities[i * N * N + site_neighbors.index(min(site_neighbors)) * N + k][1] -= 2 - 2 * min(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[3:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_neighbors.index(max(site_neighbors)) * N + k][0] -= np.exp(-abs(total_spin)) * (1 if max(site_neighbors) > 0 else 0)
          priorities[i * N * N + site_neighbors.index(max(site_neighbors)) * N + k][1] = -2 + 2 * max(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.3965678}
#standard deviation: 0.04038538105750644
#island_id: 1
#version_generated: 3
#generate time00:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.3896654000000001}
#standard deviation: 0.0490769730407245
#island_id: 1
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]] if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.017087799999999785}
#standard deviation: 0.04941802759277226
#island_id: 1
#version_generated: 3
#generate time00:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2] if J[d, i, j, k] < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2] if J[d, i, j, k] > 0]) - 2
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(J[d, i, j, k])) for d in [0, 1, 2] if J[d, i, j, k] > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = np.sum([np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2] if J[d, i, j, k] < 0]) + 2

        site_neighbors_sum = sum(site_neighbors)
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.31337860000000006}
#standard deviation: 0.04542027633161207
#island_id: 1
#version_generated: 3
#generate time00:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
          diagonal_neighbor_sum = sum(val for val in diagonal_neighbors if val < 0)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(sum(site_neighbors) + sum(diagonal_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbor_sum = sum(val for val in site_neighbors if val > 0)
          diagonal_neighbor_sum = sum(val for val in diagonal_neighbors if val > 0)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(sum(site_neighbors) + sum(diagonal_neighbors))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4145562}
#standard deviation: 0.04148051351610778
#island_id: 1
#version_generated: 3
#generate time00:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - abs(sum(site_neighbors))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add the interactions with diagonal neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in diagonal_neighbors if val < 0]) - abs(sum(diagonal_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(diagonal_neighbors) - sum(1 for val in diagonal_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.07983459999999999}
#standard deviation: 0.05025005913270152
#island_id: 3
#version_generated: 3
#generate time00:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.07983459999999999}
#standard deviation: 0.05025005913270152
#island_id: 3
#version_generated: 3
#generate time00:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 3
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.07983459999999999}
#standard deviation: 0.05025005913270152
#island_id: 3
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1171474000000001}
#standard deviation: 0.045002050544836296
#island_id: 0
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (2 - 2 * ((k + 1) % 2))
            priorities[i * N * N + j * N + k][1] += 2

  return priorities




#score: {'data3D.txt': -0.32221659999999996}
#standard deviation: 0.048212317974144325
#island_id: 1
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32221659999999996}
#standard deviation: 0.048212317974144325
#island_id: 1
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4713506000000002}
#standard deviation: 0.04555460020283352
#island_id: 1
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4713506000000002}
#standard deviation: 0.04555460020283352
#island_id: 1
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.06618940000000001}
#standard deviation: 0.045532693393209235
#island_id: 1
#version_generated: 3
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2
          if total_spin > 0.5:
            priorities[i * N * N + j * N + k][0] += np.log(len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4
          else:
            priorities[i * N * N + j * N + k][0] -= np.log(len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] += 4
        
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = 2
          if total_spin > 0.5:
            priorities[i * N * N + j * N + k][0] -= np.log(len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 4
          else:
            priorities[i * N * N + j * N + k][0] += np.log(len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 4
        
  return priorities




#score: {'data3D.txt': -0.27460700000000005}
#standard deviation: 0.044197670425034856
#island_id: 1
#version_generated: 3
#generate time00:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.47366500000000006}
#standard deviation: 0.04359781708984981
#island_id: 1
#version_generated: 3
#generate time00:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[i][j][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          if h[i][j][k] < 0:
            priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * total_neighbor_spin
          else:
            priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': 0.17921179999999998}
#standard deviation: 0.04733505234770529
#island_id: 1
#version_generated: 3
#generate time00:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += total_neighbor_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= total_neighbor_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.45695060000000004}
#standard deviation: 0.043667043861933236
#island_id: 1
#version_generated: 3
#generate time00:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] -= len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.0460046}
#standard deviation: 0.04679590515034408
#island_id: 1
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        
        # Add the probability of the current site
        if h[i][j][k] > 0:
          probabilities = [np.exp(-abs(total_spin)), np.exp(-abs(total_neighbor_spin))]
        else:
          probabilities = [np.exp(abs(total_spin)), np.exp(abs(total_neighbor_spin))]
        priorities[i * N * N + j * N + k][0] += sum(probabilities)
        priorities[i * N * N + j * N + k][1] -= sum(probabilities)
  
  return priorities




#score: {'data3D.txt': -0.22302580000000014}
#standard deviation: 0.04688656624620746
#island_id: 3
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]

            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
              priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
              priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.22302580000000014}
#standard deviation: 0.04688656624620746
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
              priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
              priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22302580000000014}
#standard deviation: 0.04688656624620746
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
              priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
              priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.45695060000000004}
#standard deviation: 0.043667043861933236
#island_id: 1
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] -= len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.45695060000000004}
#standard deviation: 0.043667043861933236
#island_id: 1
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] -= len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.45695060000000004}
#standard deviation: 0.043667043861933236
#island_id: 1
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] -= len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) - len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val > 0]) + len([val for val in [site_neighbors[0], J[0, i, (j + 1) % N, k]] if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.23347340000000005}
#standard deviation: 0.042248962264652135
#island_id: 1
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return priorities




#score: {'data3D.txt': 0.059288200000000235}
#standard deviation: 0.0519108869194122
#island_id: 1
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.23347340000000005}
#standard deviation: 0.042248962264652135
#island_id: 1
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return priorities




#score: {'data3D.txt': -0.5462386}
#standard deviation: 0.03953929273570786
#island_id: 0
#version_generated: 3
#generate time00:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5050938}
#standard deviation: 0.04132356278880126
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[0, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45854700000000004}
#standard deviation: 0.04006510839870523
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time00:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Your logic here...
  # Add your Python code here...

  return(priorities)




#score: {'data3D.txt': -0.404673}
#standard deviation: 0.04296695277768718
#island_id: 0
#version_generated: 3
#generate time00:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.27132860000000025}
#standard deviation: 0.047170230252141024
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbor_spin < 0) if h[i][j][k] > 0 else -np.exp(abs(total_spin)) * (total_site_neighbor_spin > 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if i + (d - 1) % 2 == 0:
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if h[i][j][k] > 0 and neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
          elif h[i][j][k] > 0 and neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
          elif h[i][j][k] < 0 and neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
          elif h[i][j][k] < 0 and neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.23215220000000017}
#standard deviation: 0.045848726865203145
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
              priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
              priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbor_spin < 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbor_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.22302580000000014}
#standard deviation: 0.04688656624620746
#island_id: 3
#version_generated: 3
#generate time00:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
              priorities[i * N * N + j * N + k][1] -= 3 - 3 * total_spin
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
              priorities[i * N * N + j * N + k][1] += 3 - 3 * total_spin
            
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        neighbor_spin_x = J[0,i,(j+1)%N,k] if i < N-1 else 0
        neighbor_spin_y = J[1,i,j,(k+1)%N] if k < N-1 else 0
        neighbor_spin_z = J[2,i,(j+1)%N,k] if i < N-1 and j < N-1 else 0

        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin + neighbor_spin_x + neighbor_spin_y + neighbor_spin_z
        priorities[i*N*N+k][1] -= 2 - 2 * (total_spin + neighbor_spin_x + neighbor_spin_y + neighbor_spin_z)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) + total_spin
        priorities[i*N*N+k][1] -= 2 - 2 * total_spin

  # Add the priority for each of the four neighboring spins
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if i < N-1:
          priorities[i*N*N+k][0] += np.exp(-abs(J[2,i,j,k])) * (J[2,i+1,j,k] > 0) + J[2,i+1,j,k]
          priorities[i*N*N+k][1] -= 2 - 2 * J[2,i+1,j,k]
        if j < N-1:
          priorities[i*N*N+k][0] += np.exp(-abs(J[1,i,j,k])) * (J[1,i,j+1,k] > 0) + J[1,i,j+1,k]
          priorities[i*N*N+k][1] -= 2 - 2 * J[1,i,j+1,k]
        if k < N-1:
          priorities[i*N*N+k][0] += np.exp(-abs(J[0,i,j,k])) * (J[0,i,j,k+1] > 0) + J[0,i,j,k+1]
          priorities[i*N*N+k][1] -= 2 - 2 * J[0,i,j,k+1]

  return(priorities)




#score: {'data3D.txt': 0.027193}
#standard deviation: 0.0485339921189263
#island_id: 3
#version_generated: 3
#generate time00:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0,1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = sum(J[3-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[3-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = sum(J[3-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[3-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.40855340000000007}
#standard deviation: 0.04860820618414138
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(sum(J[d, i, j, k] for d in [0, 1, 2]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(sum(J[d, i, j, k] for d in [0, 1, 2]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0165862}
#standard deviation: 0.04643588967124458
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0).sum()
          priorities[i * N * N + j * N + k][1] = -np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0).mean() + np.sum(J[3:, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0).sum()
          priorities[i * N * N + j * N + k][1] = np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0).mean() - np.sum(J[3:, i, j, k])
        
  return(priorities)




#score: {'data3D.txt': -0.2146574}
#standard deviation: 0.04646232651557604
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = J[0, i, (j + 1) % N, k] + J[1, (i + 1) % N, j, k]
        diagonal_neighbors = sum([J[d, i, j, (k - 1) % N] for d in [3, 4, 5]])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - abs(sum(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
          
          site_neighbor_sum = sum(val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]] if val < 0)
          diagonal_neighbor_sum = sum(val for val in [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]] if val < 0)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - abs(sum(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - abs(sum(interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
          
          site_neighbor_sum = sum(val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]] if val > 0)
          diagonal_neighbor_sum = sum(val for val in [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]] if val > 0)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - abs(sum(interacting_spins))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4680054000000001}
#standard deviation: 0.04688749866264994
#island_id: 1
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbor_sum = sum(val for val in site_neighbors if val < 0)
          diagonal_neighbor_sum = sum(val for val in diagonal_neighbors if val < 0)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbor_sum = sum(val for val in site_neighbors if val > 0)
          diagonal_neighbor_sum = sum(val for val in diagonal_neighbors if val > 0)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return priorities




#score: {'data3D.txt': 0.001332999999999999}
#standard deviation: 0.04641366039217334
#island_id: 2
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': 0.001332999999999999}
#standard deviation: 0.04641366039217334
#island_id: 2
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])

        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': 0.001332999999999999}
#standard deviation: 0.04641366039217334
#island_id: 2
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.17531860000000035}
#standard deviation: 0.044032923750757236
#island_id: 2
#version_generated: 3
#generate time00:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          spin_diff = len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_diff
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          spin_diff = len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_diff
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time00:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.32221659999999996}
#standard deviation: 0.048212317974144325
#island_id: 1
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.280443}
#standard deviation: 0.05516832742616003
#island_id: 1
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32221659999999996}
#standard deviation: 0.048212317974144325
#island_id: 1
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.09503660000000005}
#standard deviation: 0.04597944215016099
#island_id: 2
#version_generated: 3
#generate time00:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[3+i] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        for d in [0, 1, 2]:
          neighbor_spin = interacting_spins[d][i][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 2
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 2
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, 1, axis=i)
  for i in range(3):
    interacting_spins[3+i] = np.roll(np.flip(h, axis=i), 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*h[i][j][k]-1) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.294255}
#standard deviation: 0.05143871747040355
#island_id: 1
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) - len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
  
  return priorities




#score: {'data3D.txt': -0.0643294}
#standard deviation: 0.04588284315122593
#island_id: 1
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
          
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
  return priorities




#score: {'data3D.txt': -0.4155962000000001}
#standard deviation: 0.04337556853298871
#island_id: 1
#version_generated: 3
#generate time00:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        diagonal_neighbors = [J[3, i, j, (k - 1) % N], J[4, (i + 1) % N, (j - 1) % N, k], J[5, i, (j - 1) % N, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in site_neighbors + diagonal_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 2
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time00:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], 
                   J[1, i, (j+1)%N, k], 
                   J[2, i, j, (k+1)%N], 
                   J[3, (i-1)%N if i > 0 else N-1, j, k], 
                   J[4, i, (j-1)%N if j > 0 else N-1, k], 
                   J[5, (i-1)%N if i > 0 else N-1, (j-1)%N if j > 0 else N-1, k]]
        site_nbr = sum(-1 if val < 0 else 1 for val in interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * site_nbr
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time00:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], 
                   J[1, i, (j+1)%N, k],
                   J[2, i, j, (k+1)%N],
                   J[3, (i-1)%N if i>0 else N-1, j, k],
                   J[4, i, (j-1)%N if j>0 else N-1, k],
                   J[5, i, j, (k-1)%N if k>0 else N-1]]
        
        site_nbr = sum(-1 if val < 0 else 1 for val in interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [3,4,5]))) * site_nbr
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time00:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d==0 else 
                  J[1, i, (j+1)%N, k] if d==1 else 
                  J[2, i, j, (k+1)%N] for d in range(3)] + \
                  [J[d, i, (j+1)%N, k] if d==3 else 
                  J[4, (i+1)%N, j, k] if d==4 else 
                  J[5, i, (j-1)%N, k] for d in range(3)]
        
        site_nbr = sum(-1 if val < 0 else 1 for val in interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * site_nbr
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time00:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 0
#version_generated: 3
#generate time00:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 0
#version_generated: 3
#generate time00:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time00:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31064139999999996}
#standard deviation: 0.045109522786657794
#island_id: 0
#version_generated: 3
#generate time00:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 0
#version_generated: 3
#generate time00:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 0
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time01:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4646082000000001}
#standard deviation: 0.04409634693214394
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) + total_spin
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        
  return priorities




#score: {'data3D.txt': -0.4646082000000001}
#standard deviation: 0.04409634693214394
#island_id: 1
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val < 0])
          priorities[i * N * N + site_nbr * N + k][1] -= 2 - 2 * sum(site_neighbors[:2])
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + site_nbr * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_neighbors[0], site_nbr_neighbors[0]] if val > 0]) + total_spin
          priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_neighbors[:2])
        
  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.31066420000000006}
#standard deviation: 0.043959669679832676
#island_id: 3
#version_generated: 3
#generate time01:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': 0.17921179999999998}
#standard deviation: 0.04733505234770529
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += total_neighbor_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= total_neighbor_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': 0.17921179999999998}
#standard deviation: 0.04733505234770529
#island_id: 1
#version_generated: 3
#generate time01:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += total_neighbor_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 + 2 * sum(site_nbr_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= total_neighbor_spin - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_neighbor_spin
          
          if h[i][site_nbr][k] > 0:
            priorities[i * N * N + site_nbr * N + k][0] += sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
          else:
            priorities[i * N * N + site_nbr * N + k][0] -= sum(site_nbr_neighbors) - len([val for val in site_nbr_neighbors if val < 0]) + len([val for val in site_nbr_neighbors if val > 0])
            priorities[i * N * N + site_nbr * N + k][1] = -2 - 2 * sum(site_nbr_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.2839398000000002}
#standard deviation: 0.04563869954282218
#island_id: 3
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2839398000000002}
#standard deviation: 0.04563869954282218
#island_id: 3
#version_generated: 3
#generate time01:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.14318700000000015}
#standard deviation: 0.04753081306899768
#island_id: 0
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j-1)%N, k] if d == 0 else
                   J[d, i, j, (k-1)%N] if d == 1 else
                   J[d, (i-1)%N, j, k] for d in range(6)]
        total_spin = sum(val for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - (np.count_nonzero([val for val in interacting_spins if val < 0]) - np.count_nonzero([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - (np.count_nonzero([val for val in interacting_spins if val < 0]) - np.count_nonzero([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.05174660000000033}
#standard deviation: 0.049052475456800346
#island_id: 0
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5278618}
#standard deviation: 0.04172157500334809
#island_id: 2
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in site_neighbors if neighbor < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in site_neighbors if neighbor > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5278618}
#standard deviation: 0.04172157500334809
#island_id: 2
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in site_neighbors if neighbor < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in site_neighbors if neighbor > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5268298}
#standard deviation: 0.04153972980123968
#island_id: 2
#version_generated: 3
#generate time01:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in J[2, i, j, :k].flatten() if neighbor < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in J[2, i, j, :k].flatten() if neighbor > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.096439}
#standard deviation: 0.04200880715992779
#island_id: 1
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return priorities




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += sum(-np.exp(abs(J[d, i, j, k])) for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 1
#version_generated: 3
#generate time01:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += sum(-np.exp(abs(J[d,i,j,k])) for d in [0,1,2]) - len([val for val in interacting_spins if val<0])
        priorities[i*N*N+j*N+k][1] -= 2*total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31064139999999996}
#standard deviation: 0.045109522786657794
#island_id: 0
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spin_sum = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spin_sum)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spin_sum)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))

  return(priorities)




#score: {'data3D.txt': -0.017374999999999988}
#standard deviation: 0.04716483833323295
#island_id: 0
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(abs(s) for s in interacting_spins) + np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += sum(abs(s) for s in interacting_spins) + np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += 2 + 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.0133138}
#standard deviation: 0.04844136052548483
#island_id: 0
#version_generated: 3
#generate time01:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(abs(s) for s in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(abs(s) for s in interacting_spins)
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14825380000000019}
#standard deviation: 0.04465069255409147
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in J[2, i, j, :k].flatten() if neighbor < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in J[2, i, j, :k].flatten() if neighbor > 0) - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] -= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] += np.abs(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.2081818}
#standard deviation: 0.05514613194739954
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          spin_energy = -h[i][j][k]
          neighbor_spins = np.sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]], axis=0)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_energy
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * spin_energy
          
        else:
          spin_energy = -h[i][j][k]
          neighbor_spins = np.sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]], axis=0)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * spin_energy
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * spin_energy
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * total_spin

  return(priorities)




#score: {'data3D.txt': -0.02374340000000002}
#standard deviation: 0.04588407170729294
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])

        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.3496618000000001}
#standard deviation: 0.045342998365348545
#island_id: 2
#version_generated: 3
#generate time01:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for neighbor in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if neighbor < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.exp(-abs(total_spin)) * sum(1 for neighbor in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if neighbor > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for neighbor in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if neighbor > 0) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.exp(-abs(total_spin)) * sum(1 for neighbor in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if neighbor < 0)

  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time01:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.49333860000000007}
#standard deviation: 0.04207048882577905
#island_id: 0
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          total_spin = sum(s for s in interacting_spins)
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          total_spin = sum(s for s in interacting_spins)
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': 0.17673819999999998}
#standard deviation: 0.05416514876523464
#island_id: 2
#version_generated: 3
#generate time01:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = -2 * total_spin
        priorities[i * N * N + j * N + k][1] = 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and spin-flip probabilities
        priorities[i * N * N + j * N + k][0] += h[i][j][k] + np.log(1 + np.exp(-h[i][j][k]))
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] - np.log(1 + np.exp(h[i][j][k]))
        
        # Add a term based on the number of neighboring spins with the same sign
        spin_count = len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += -2 * spin_count
        priorities[i * N * N + j * N + k][1] += 2 * spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.07520859999999999}
#standard deviation: 0.04594770294628448
#island_id: 1
#version_generated: 3
#generate time01:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + site_neighbors.index(site_neighbors[0]) * N + k][0] += np.exp(-abs(total_spin)) * (1 if site_neighbors[0] < 0 else 0)
            priorities[i * N * N + site_neighbors.index(site_neighbors[0]) * N + k][1] -= 2 - 2 * site_neighbors[0]
          elif site_neighbors[-1] > 0:
            priorities[i * N * N + site_neighbors.index(site_neighbors[-1]) * N + k][0] += np.exp(-abs(total_spin)) * (1 if site_neighbors[-1] > 0 else 0)
            priorities[i * N * N + site_neighbors.index(site_neighbors[-1]) * N + k][1] = -2 + 2 * site_neighbors[-1]

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.sort()
          if site_neighbors[0] < 0:
            priorities[i * N * N + site_neighbors.index(site_neighbors[0]) * N + k][0] += np.exp(-abs(total_spin)) * (1 if site_neighbors[0] < 0 else 0)
            priorities[i * N * N + site_neighbors.index(site_neighbors[0]) * N + k][1] = -2 + 2 * site_neighbors[0]
          elif site_neighbors[-1] > 0:
            priorities[i * N * N + site_neighbors.index(site_neighbors[-1]) * N + k][0] += np.exp(-abs(total_spin)) * (1 if site_neighbors[-1] > 0 else 0)
            priorities[i * N * N + site_neighbors.index(site_neighbors[-1]) * N + k][1] = -2 + 2 * site_neighbors[-1]

  return(priorities)




#score: {'data3D.txt': -0.39034019999999997}
#standard deviation: 0.04201213234245556
#island_id: 1
#version_generated: 3
#generate time01:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.39034019999999997}
#standard deviation: 0.04201213234245556
#island_id: 1
#version_generated: 3
#generate time01:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.39034019999999997}
#standard deviation: 0.04201213234245556
#island_id: 1
#version_generated: 3
#generate time01:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.35565500000000005}
#standard deviation: 0.04388817033096732
#island_id: 1
#version_generated: 3
#generate time01:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.0133138}
#standard deviation: 0.04844136052548483
#island_id: 0
#version_generated: 3
#generate time01:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(abs(s) for s in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(abs(s) for s in interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0133138}
#standard deviation: 0.04844136052548483
#island_id: 0
#version_generated: 3
#generate time01:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(abs(s) for s in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(abs(s) for s in interacting_spins)
        
        site_neighbors = [J[0,i,(j + 1) % N,k], J[1,(i + 1) % N,j,k], J[2,i,j,(k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0133138}
#standard deviation: 0.04844136052548483
#island_id: 0
#version_generated: 3
#generate time01:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(abs(s) for s in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(abs(s) for s in interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0133138}
#standard deviation: 0.04844136052548483
#island_id: 0
#version_generated: 3
#generate time01:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(abs(s) for s in interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(abs(s) for s in interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5387618}
#standard deviation: 0.04169869183511636
#island_id: 2
#version_generated: 2
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 2
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.5420358}
#standard deviation: 0.04009336451783512
#island_id: 2
#version_generated: 2
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for spin in site_neighbors if spin < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for spin in site_neighbors if spin > 0)

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(sum([abs(val) for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d-3, i + (d-3), j, k]
          else:
            neighbor_spin = J[6-d, i - (d-3), j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.1436462}
#standard deviation: 0.046010903768128705
#island_id: 0
#version_generated: 3
#generate time01:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2])))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(sum(J[d, i, j, k] for d in [0, 1, 2])))
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1])))
            priorities[i * N * N + j * N + k][1] -= 2
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(sum(J[d, i, j, k] for d in [0, 1])))
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.5387618}
#standard deviation: 0.04169869183511636
#island_id: 2
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5374169999999999}
#standard deviation: 0.0397320333106676
#island_id: 2
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5142077999999999}
#standard deviation: 0.042044237407283296
#island_id: 2
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d // 3, j, k]
          else:
            neighbor_spin = J[5 - d, i - d // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4895606}
#standard deviation: 0.045363024674728206
#island_id: 2
#version_generated: 3
#generate time01:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.5655301999999999}
#standard deviation: 0.04223951382248617
#island_id: 2
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5387618}
#standard deviation: 0.04169869183511636
#island_id: 2
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0064094}
#standard deviation: 0.047060614866786435
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_interaction = sum(J[d, i, j, k] * (d == 0) + J[(d+1)%3, i, (j+1)%N, k] * (d == 1) + J[(d+2)%3, (i+1)%N, j, k] * (d == 2) for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_interaction)) * int((total_interaction > 0) != site_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (site_spin + total_interaction / 6)
  
  return(priorities)




#score: {'data3D.txt': -0.39034019999999997}
#standard deviation: 0.04201213234245556
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.39034019999999997}
#standard deviation: 0.04201213234245556
#island_id: 1
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(sum(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.2926222000000001}
#standard deviation: 0.04608890568412316
#island_id: 0
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if i < N//2:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.3299229999999998}
#standard deviation: 0.04458230446040221
#island_id: 0
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
  
  return(priorities)




#score: {'data3D.txt': -0.31326179999999987}
#standard deviation: 0.04537475576529309
#island_id: 3
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [3, 4])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 3
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.31066420000000006}
#standard deviation: 0.043959669679832676
#island_id: 3
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.22494299999999998}
#standard deviation: 0.044339584019248535
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len(site_nbr_neighbors) - sum(1 for val in site_nbr_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len(site_nbr_neighbors) + sum(1 for val in site_nbr_neighbors if val < 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3207966}
#standard deviation: 0.044849951933530544
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.32037099999999996}
#standard deviation: 0.041085825280746155
#island_id: 1
#version_generated: 3
#generate time01:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + len(site_neighbors) - sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - len(site_neighbors) + sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.29220820000000003}
#standard deviation: 0.045022545160841365
#island_id: 1
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - abs(total_site_neighbor_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - abs(total_site_neighbor_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3207966}
#standard deviation: 0.044849951933530544
#island_id: 1
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3258854}
#standard deviation: 0.04241842178629469
#island_id: 1
#version_generated: 3
#generate time01:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0]) - abs(sum(site_nbr_neighbors))
        priorities[i * N * N + j * N + k][1] -= len(site_nbr_neighbors) - sum(1 for val in site_nbr_neighbors if val > 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.5313474}
#standard deviation: 0.0420207776372594
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.22494299999999998}
#standard deviation: 0.044339584019248535
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len(site_nbr_neighbors) - sum(1 for val in site_nbr_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -len(site_nbr_neighbors) + sum(1 for val in site_nbr_neighbors if val < 0)
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3207966}
#standard deviation: 0.044849951933530544
#island_id: 1
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3207966}
#standard deviation: 0.044849951933530544
#island_id: 1
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3138014}
#standard deviation: 0.04577591548008625
#island_id: 1
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]

  # Add the magnetism at each site
  for i in range(N):
    for j in range(N):
      priorities[i * N * N + j][0] += h[i][j].sum()
      priorities[i * N * N + j][1] -= h[i][j].sum()

  return(priorities)




#score: {'data3D.txt': -0.32867219999999997}
#standard deviation: 0.04588858624058928
#island_id: 1
#version_generated: 3
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - h[i][j][k]

        site_neighbor_sites = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_site_spin = sum(site_neighbor_sites)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(total_spin) + total_site_neighbor_site_spin
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.25997739999999997}
#standard deviation: 0.05325061736017715
#island_id: 1
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.3447038}
#standard deviation: 0.04510598525207048
#island_id: 1
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(site_neighbors)
        
        site_cross_neighbors = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        total_site_cross_neighbor_spin = sum(site_cross_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_spin) + total_site_neighbor_spin + total_site_cross_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin) + total_site_neighbor_spin + total_site_cross_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.2839398000000002}
#standard deviation: 0.04563869954282218
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2896550000000001}
#standard deviation: 0.04577724647682512
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*h[i-(d%N)][j-(d//3)%N][k-(d//1)%N] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.3119233999999999}
#standard deviation: 0.04545762347989607
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2839398000000002}
#standard deviation: 0.04563869954282218
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2604154000000003}
#standard deviation: 0.04674082629607653
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if i < N//2:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the site's own magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * interacting_spins[d % 3][i, j, k]
          priorities[i * N * N + j * N + k][1] -= J[d, i, j, k] * interacting_spins[d % 3][i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.1994314}
#standard deviation: 0.04541888609422296
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if i < N//2:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] -= (1 - abs(neighbor_spin))
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(neighbor_spin))
            priorities[i * N * N + j * N + k][1] += (1 + abs(neighbor_spin))
        
  return(priorities)




#score: {'data3D.txt': -0.28548060000000014}
#standard deviation: 0.04651329039790671
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 - abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= (1 - abs(h[i][j][k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (1 + abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += (1 + abs(h[i][j][k]))
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if i < N//2:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total magnetism of the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(s) for s in interacting_spins)) * (-h[i][j][k])
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2726598}
#standard deviation: 0.05032770354347593
#island_id: 0
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if i < N//2:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.11901100000000008}
#standard deviation: 0.045380146308710824
#island_id: 0
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.12992019999999999}
#standard deviation: 0.04471119582341765
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
        # Add a new term based on the total magnetism at the site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][1] -= abs(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.14305340000000036}
#standard deviation: 0.04788717310971696
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5374169999999999}
#standard deviation: 0.0397320333106676
#island_id: 2
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.30129380000000017}
#standard deviation: 0.04570947693378257
#island_id: 2
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5241414}
#standard deviation: 0.040154258130863284
#island_id: 2
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i - d >= 0 and j - d >= 0 and k - d >= 0):
            neighbor_spin = J[d, i - d, j - d, k - d]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4968782}
#standard deviation: 0.04048866415133994
#island_id: 2
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i - d < 0 or j - d < 0 or k - d < 0):
            break
          neighbor_spin = J[d, i - d, j - d, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.03837660000000033}
#standard deviation: 0.04955843956825114
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (len([val for val in interacting_spins if val > 0]) * abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) * abs(h[i][j][k]))
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.11891100000000035}
#standard deviation: 0.047858012902752246
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) / (N**3)
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) / (N**3)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.05174660000000033}
#standard deviation: 0.049052475456800346
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (len([val for val in interacting_spins if val > 0]) ** 2)
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) ** 2)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (len([val for val in interacting_spins if val < 0]) ** 2)
          priorities[i * N * N + j * N + k][1] += (len([val for val in interacting_spins if val < 0]) ** 2)
  
  return(priorities)




#score: {'data3D.txt': 0.02325939999999973}
#standard deviation: 0.04905684816251449
#island_id: 0
#version_generated: 3
#generate time02:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] += sum(1 for val in interacting_spins if val < 0)
  
  return(priorities)




#score: {'data3D.txt': 0.38151140000000033}
#standard deviation: 0.04487102706691702
#island_id: 2
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5241414}
#standard deviation: 0.040154258130863284
#island_id: 2
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in range(3):
          if (i - d >= 0 and j - d >= 0 and k - d >= 0):
            neighbor_spin = J[d, i - d, j - d, k - d]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5241414}
#standard deviation: 0.040154258130863284
#island_id: 2
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i - d >= 0 and j - d >= 0 and k - d >= 0):
            neighbor_spin = J[d, i - d, j - d, k - d]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.19507619999999984}
#standard deviation: 0.04359611718444661
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * (h[i][j][k]+1)
          priorities[i * N * N + j * N + k][1] -= np.exp(-total_spin) * (h[i][j][k]+1)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin) * (h[i][j][k]-1)
          priorities[i * N * N + j * N + k][1] += np.exp(-total_spin) * (h[i][j][k]-1)

  return priorities




#score: {'data3D.txt': -0.3119233999999999}
#standard deviation: 0.04545762347989607
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*(interacting_spins[d, i, j, k]-2*h[i][j][k]) for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.3119233999999999}
#standard deviation: 0.04545762347989607
#island_id: 3
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.4968782}
#standard deviation: 0.04048866415133994
#island_id: 2
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i - d < 0 or j - d < 0 or k - d < 0):
            break
          neighbor_spin = J[d, i - d, j - d, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(interacting_spins[:,i,j,k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(interacting_spins[:,i,j,k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.3119233999999999}
#standard deviation: 0.04545762347989607
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.37810940000000015}
#standard deviation: 0.05257140355402356
#island_id: 3
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  return priorities




#score: {'data3D.txt': -0.3433274}
#standard deviation: 0.039383154384076455
#island_id: 0
#version_generated: 2
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4908162}
#standard deviation: 0.04445091334899656
#island_id: 0
#version_generated: 2
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin as the current site
        same_spin = [val for val in interacting_spins if val > 0 or val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(same_spin)
        priorities[i * N * N + j * N + k][1] += len(same_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.457403}
#standard deviation: 0.04129633047862728
#island_id: 2
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.521925}
#standard deviation: 0.04217795745410155
#island_id: 2
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4893302}
#standard deviation: 0.04136611328080027
#island_id: 2
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d // 3, j, k]
          else:
            neighbor_spin = J[5 - d, i - d // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.48268259999999996}
#standard deviation: 0.04255775296276813
#island_id: 2
#version_generated: 3
#generate time02:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d // 3, j, k]
          else:
            neighbor_spin = J[5 - d, i - d // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [5]:
          if (i + (d - 5) % 2 == 0):
            neighbor_spin = J[d, i + (d - 5) // 3, j, k]
          else:
            neighbor_spin = J[6 - d, i - (d - 5) // 3, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.49528300000000003}
#standard deviation: 0.042056215129276674
#island_id: 2
#version_generated: 3
#generate time02:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in range(3):
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[2-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.457403}
#standard deviation: 0.04129633047862728
#island_id: 2
#version_generated: 3
#generate time02:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0204422}
#standard deviation: 0.04598714710829538
#island_id: 3
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [3,4]:
          if i + (d-3)%2 == 0:
            neighbor_spin = sum(J[6-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[6-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [5]:
          if i + (d-3)%2 == 0:
            neighbor_spin = sum(J[6-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[6-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0600518}
#standard deviation: 0.04768353339214702
#island_id: 3
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0,1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = sum(J[3-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[3-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [3,4]:
          if i + (d-1)%2 == 0:
            neighbor_spin = sum(J[3-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[3-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0603594}
#standard deviation: 0.04674893358826488
#island_id: 3
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0,1]:
          if i + (d-1)%2 == 0:
            neighbor_spin = sum(J[3-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[3-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [3,4]:
          if i + (d-3)%2 == 0:
            neighbor_spin = sum(J[6-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[6-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3433274}
#standard deviation: 0.039383154384076455
#island_id: 0
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.05007099999999999}
#standard deviation: 0.047816839282830065
#island_id: 0
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in [0,1,2,3,4,5]]
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        priorities[i * N * N + j * N + k][0] = np.sum([J[d, i, j, k] for d in [0, 1, 2]], axis=0)
        priorities[i * N * N + j * N + k][1] = -np.sum([2 - 2 * J[d, i, j, k] for d in [0, 1, 2]], axis=0)

  return(priorities)




#score: {'data3D.txt': -0.46313980000000005}
#standard deviation: 0.042489343793002975
#island_id: 0
#version_generated: 3
#generate time02:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum([val for val in site_neighbors])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum_total = site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0
        site_neighbors_sum_total_times_sum_interacting_spins = sum([val for val in interacting_spins]) * site_neighbors_sum_total

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum_total_times_sum_interacting_spins

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3445338}
#standard deviation: 0.04212389319091957
#island_id: 1
#version_generated: 2
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 1
#version_generated: 2
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.41151380000000004}
#standard deviation: 0.04308045554030272
#island_id: 2
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.521925}
#standard deviation: 0.04217795745410155
#island_id: 2
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4138166}
#standard deviation: 0.04651038684466084
#island_id: 2
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new terms based on improved heuristics
        
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add new terms based on improved heuristics
        
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4895606}
#standard deviation: 0.045363024674728206
#island_id: 2
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time02:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.1417894}
#standard deviation: 0.04797684032572382
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time02:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37810940000000015}
#standard deviation: 0.05257140355402356
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  return priorities




#score: {'data3D.txt': -0.37810940000000015}
#standard deviation: 0.05257140355402356
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Further improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  return priorities




#score: {'data3D.txt': -0.37810940000000015}
#standard deviation: 0.05257140355402356
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  return priorities




#score: {'data3D.txt': -0.37810940000000015}
#standard deviation: 0.05257140355402356
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin
  
  return priorities




#score: {'data3D.txt': 0.1626925999999998}
#standard deviation: 0.042422289721796014
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*interacting_spins[d,i,j,k]-h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.45402180000000014}
#standard deviation: 0.045797903497430986
#island_id: 3
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d+3,i,j,k] - interacting_spins[d+3,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.3445338}
#standard deviation: 0.04212389319091957
#island_id: 1
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.305421}
#standard deviation: 0.053298497530418244
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin as the current site
        same_spin = [val for val in interacting_spins if val > 0 or val < 0]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(same_spin)
        priorities[i * N * N + j * N + k][1] += len(same_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.39470299999999997}
#standard deviation: 0.03838960472575877
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3433274}
#standard deviation: 0.039383154384076455
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([2 - 2 * val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': 0.17011300000000024}
#standard deviation: 0.04587110802019067
#island_id: 0
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum([val for val in interacting_spins if val > 0 or val < 0])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum([2 - 2 * val for val in site_neighbors if val < 0]) + same_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * len([val for val in interacting_spins if val < 0]) - 2 * sum([2 - 2 * val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - sum([2 - 2 * val for val in site_neighbors if val < 0]) - same_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * len([val for val in interacting_spins if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.015758199999999927}
#standard deviation: 0.0495106410053435
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in [0,1,2,3,4,5]]
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Added a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          neighbor_spin = J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Added a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          neighbor_spin = J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2128258}
#standard deviation: 0.04521101563070664
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in [0,1,2,3,4,5]]
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.11803500000000011}
#standard deviation: 0.04725338014364688
#island_id: 0
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in [0,1,2,3,4,5]]
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.548237}
#standard deviation: 0.04369985756269693
#island_id: 2
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.038775000000000004}
#standard deviation: 0.046933810147909365
#island_id: 2
#version_generated: 3
#generate time03:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.46313980000000005}
#standard deviation: 0.042489343793002975
#island_id: 0
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum([val for val in site_neighbors])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum_total = site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0
        site_neighbors_sum_total_times_sum_interacting_spins = sum([val for val in interacting_spins]) * site_neighbors_sum_total

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum_total_times_sum_interacting_spins

  return(priorities)




#score: {'data3D.txt': -0.46313980000000005}
#standard deviation: 0.042489343793002975
#island_id: 0
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum_total = site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0
        site_neighbors_sum_total_times_sum_interacting_spins = sum([val for val in interacting_spins]) * site_neighbors_sum_total
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum_total_times_sum_interacting_spins
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :] for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([interacting_spins[d][i, j, k] for d in range(3)])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.sum([interacting_spins[d][i, j, k] for d in range(3)], axis=0)
        priorities[i * N * N + j * N + k][1] = -np.sum([2 - 2 * interacting_spins[d][i, j, k] for d in range(3)], axis=0)

  return(priorities)




#score: {'data3D.txt': -0.46313980000000005}
#standard deviation: 0.042489343793002975
#island_id: 0
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum([val for val in site_neighbors])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum_total = site_neighbors_sum / abs(site_neighbors_sum) if site_neighbors_sum else 0
        site_neighbors_sum_total_times_sum_interacting_spins = sum([val for val in interacting_spins]) * site_neighbors_sum_total

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= site_neighbors_sum_total_times_sum_interacting_spins

  return(priorities)




#score: {'data3D.txt': -0.0002957999999999998}
#standard deviation: 0.0434991786400617
#island_id: 0
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.zeros((N,N,N)) for _ in range(6)]
  for i in range(6):
    interacting_spins[i] = np.roll(h, -1, axis=i%3)
    interacting_spins[i] += np.roll(h, 1, axis=(i+3)%3)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in range(6))
        priorities[i * N * N + j * N + k][0] += np.sum([J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6)], axis=0) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.040537800000000006}
#standard deviation: 0.04581064168029084
#island_id: 1
#version_generated: 3
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)
  
  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2
  
  return(priorities)




#score: {'data3D.txt': -0.3445338}
#standard deviation: 0.04212389319091957
#island_id: 1
#version_generated: 3
#generate time03:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.34883459999999994}
#standard deviation: 0.041748311137577765
#island_id: 1
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val if val > 0 else -val for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.0774846}
#standard deviation: 0.04623915486727671
#island_id: 1
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
        x_nbr = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in x_nbr])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in x_nbr])
        
  return(priorities)




#score: {'data3D.txt': -0.3445338}
#standard deviation: 0.04212389319091957
#island_id: 1
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3445338}
#standard deviation: 0.04212389319091957
#island_id: 1
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.16440019999999994}
#standard deviation: 0.04754215602978057
#island_id: 0
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in [0,1,2,3,4,5]]
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.457403}
#standard deviation: 0.04129633047862728
#island_id: 2
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4325870000000002}
#standard deviation: 0.046561586216536915
#island_id: 2
#version_generated: 3
#generate time03:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        interacting_spins += [J[d, i, (j+1)%N, k] for d in [0, 1, 2]]
        interacting_spins += [J[d, i, j, (k+1)%N] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2616382}
#standard deviation: 0.04416567468928783
#island_id: 2
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4061186000000001}
#standard deviation: 0.04921559563837463
#island_id: 2
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45402180000000014}
#standard deviation: 0.045797903497430986
#island_id: 3
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d+3,i,j,k] - interacting_spins[d+3,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.47328020000000015}
#standard deviation: 0.04449712538984964
#island_id: 3
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2977126}
#standard deviation: 0.04492951904082659
#island_id: 3
#version_generated: 3
#generate time03:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i-(d%N),j-(d//3)%N,k-(d//1)%N]*h[i-(d%N)][j-(d//3)%N][k-(d//1)%N] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time03:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i%N,j%N,k%N]*h[(i+d)%N][(j+int(d/3))%N][(k+int(d/1))%N] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': 0.1448618}
#standard deviation: 0.04778645645745246
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for d in range(6):
    interacting_spins[d] = np.pad(interacting_spins[d], ((0,0),(N//2,N//2),(N//2,N//2)), mode='wrap')
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] * interacting_spins[d][i,j,k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val < 0]) + total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1445186}
#standard deviation: 0.04716783961599259
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] * interacting_spins[d][i, j, k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11803500000000011}
#standard deviation: 0.04725338014364688
#island_id: 0
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in range(6)]
        
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0720558}
#standard deviation: 0.046270521570001784
#island_id: 3
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1-priorities[i * N * N + j * N + k][0]

  return priorities




#score: {'data3D.txt': -0.3788330000000002}
#standard deviation: 0.05283628138883358
#island_id: 3
#version_generated: 3
#generate time03:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin**2) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin**2) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  return priorities




#score: {'data3D.txt': -0.2768950000000002}
#standard deviation: 0.046637213199332554
#island_id: 3
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (np.roll(h, d//2 - 1, axis=d//2)[i,j,k] if h[i,j,k] == np.roll(h, d%3 - 1, axis=d%3)[i,j,k] else -np.roll(h, d//2 - 1, axis=d//2)[i,j,k]) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1
        
  return priorities




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 3
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = -1

  return priorities




#score: {'data3D.txt': -0.13711020000000002}
#standard deviation: 0.04690114940979592
#island_id: 0
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for d in range(6):
    interacting_spins[d] = np.pad(interacting_spins[d], ((0,0),(N//2,N//2),(N//2,N//2)), mode='wrap')
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0013098000000000018}
#standard deviation: 0.04704837578450504
#island_id: 0
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] for d in range(6)]
        
        total_spin = sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        for d in [0,1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site's neighbors with some modification
        for d in [0,1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.13711020000000002}
#standard deviation: 0.04690114940979592
#island_id: 0
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for d in range(6):
    interacting_spins[d] = np.pad(interacting_spins[d], ((0,0),(N//2,N//2),(N//2,N//2)), mode='wrap')
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] * interacting_spins[d][i,j,k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.001878600000000003}
#standard deviation: 0.046921825433799996
#island_id: 0
#version_generated: 3
#generate time03:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for d in range(6):
    interacting_spins[d] = np.pad(interacting_spins[d], ((0,0),(N//2,N//2),(N//2,N//2)), mode='wrap')
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d//3)%N, (j+d%3)%N, (k+d%3)%N] * interacting_spins[d][i,j,k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i,j,k], J[1, i,j,k], J[2, i,j,k]] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] -= 1
          elif neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.23848700000000003}
#standard deviation: 0.10750979895339771
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)
  
  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2
  
  # Add some more magic here
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(priorities[i * N * N + j * N + k][0])) * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(priorities[i * N * N + j * N + k][1])) * len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.040537800000000006}
#standard deviation: 0.04581064168029084
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)
  
  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2
  
  return(priorities)

  # Add more magic here
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if priorities[i * N * N + j * N + k][0] > priorities[i * N * N + j * N + k][1]:
          priorities[i * N * N + j * N + k][0] -= (priorities[i * N * N + j * N + k][0] - priorities[i * N * N + j * N + k][1]) / 2
        elif priorities[i * N * N + j * N + k][0] < priorities[i * N * N + j * N + k][1]:
          priorities[i * N * N + j * N + k][1] -= (priorities[i * N * N + j * N + k][1] - priorities[i * N * N + j * N + k][0]) / 2
  
  return(priorities)




#score: {'data3D.txt': -0.040537800000000006}
#standard deviation: 0.04581064168029084
#island_id: 1
#version_generated: 3
#generate time03:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)
  
  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2
  
  return(priorities)




#score: {'data3D.txt': -0.14866099999999993}
#standard deviation: 0.22706060477106102
#island_id: 3
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1 + total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = 1 - total_spin

  return priorities




#score: {'data3D.txt': 0.3127937999999999}
#standard deviation: 0.04465122530860714
#island_id: 3
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - total_spin)
          priorities[i * N * N + j * N + k][1] = 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_spin)
          priorities[i * N * N + j * N + k][1] = -1

  return priorities




#score: {'data3D.txt': 0.0010542000000000004}
#standard deviation: 0.04893596123874548
#island_id: 3
#version_generated: 3
#generate time03:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin = sum(J[d,i,j,k]*(h[i][j][k]-interacting_spins[d,i,j,k]) for d in [0,1,2])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          total_spin = sum(J[d,i,j,k]*(h[i][j][k]-interacting_spins[d,i,j,k]) for d in [0,1,2])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.47328020000000015}
#standard deviation: 0.04449712538984964
#island_id: 3
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.47328020000000015}
#standard deviation: 0.04449712538984964
#island_id: 3
#version_generated: 3
#generate time03:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.4298574}
#standard deviation: 0.04164046811984707
#island_id: 2
#version_generated: 3
#generate time03:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        interacting_spin_sum = sum([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum - len(site_neighbors) / 2)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.18973099999999998}
#standard deviation: 0.04573787838323942
#island_id: 2
#version_generated: 3
#generate time03:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.10004060000000001}
#standard deviation: 0.045019498793744915
#island_id: 2
#version_generated: 3
#generate time03:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d % 2 == 0 else J[1-d, i, j, k] for d in range(3)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors.append(sum(J[d, i, j, k] for d in range(3)))
        site_neighbors.sort()
        site_neighbors.pop(0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.040537800000000006}
#standard deviation: 0.04581064168029084
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])

  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)

  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2

  return(priorities)




#score: {'data3D.txt': -0.040537800000000006}
#standard deviation: 0.04581064168029084
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)
  
  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2
  
  return(priorities)




#score: {'data3D.txt': -0.040537800000000006}
#standard deviation: 0.04581064168029084
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])

  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)

  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2

  return(priorities)




#score: {'data3D.txt': -0.2467506}
#standard deviation: 0.06360191883614832
#island_id: 1
#version_generated: 3
#generate time03:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  # Add some magic here
  min_val = np.min(priorities, axis=1)
  max_val = np.max(priorities, axis=1)
  
  priorities[:, 0] -= (max_val - min_val) / 2
  priorities[:, 1] += (max_val - min_val) / 2
  
  # Add some more magic here
  site_interactions = [J[d, i, j, k] for d in range(6)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.mean(site_interactions))) * len([val for val in site_interactions if val < 0])
        priorities[i * N * N + j * N + k][1] -= np.mean(site_interactions)
  
  return priorities




#score: {'data3D.txt': -0.19645300000000002}
#standard deviation: 0.04163083509851802
#island_id: 1
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        cross_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in cross_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in cross_neighbors])
        
  return priorities




#score: {'data3D.txt': -0.3445338}
#standard deviation: 0.04212389319091957
#island_id: 1
#version_generated: 3
#generate time03:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 2 if val < 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.29883659999999995}
#standard deviation: 0.0497786916304557
#island_id: 2
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * len([val for val in site_neighbors if val < 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.41866859999999995}
#standard deviation: 0.047754739807059986
#island_id: 2
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, (j + 1) % N, k]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4835018000000001}
#standard deviation: 0.04372888926968075
#island_id: 2
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3168474}
#standard deviation: 0.04445680637697674
#island_id: 2
#version_generated: 3
#generate time03:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.521925}
#standard deviation: 0.04217795745410155
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.521925}
#standard deviation: 0.04217795745410155
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4231594}
#standard deviation: 0.0433428018434434
#island_id: 2
#version_generated: 3
#generate time03:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5479138}
#standard deviation: 0.039583065691782895
#island_id: 0
#version_generated: 2
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 2
#generate time03:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time03:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': 0.19507619999999984}
#standard deviation: 0.04359611718444661
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.01426300000000018}
#standard deviation: 0.04501831350683853
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(h[(i+1)%N if d==0 else (i-1)%N, j, k] + h[i,(j+1)%N if d==1 else (j-1)%N, k] + h[i,j,(k+1)%N if d==2 else (k-1)%N]) for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': 0.19507619999999984}
#standard deviation: 0.04359611718444661
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': 0.19507619999999984}
#standard deviation: 0.04359611718444661
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': -0.47798539999999995}
#standard deviation: 0.043028409996652216
#island_id: 1
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2839746}
#standard deviation: 0.04713146501902949
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        
  return priorities




#score: {'data3D.txt': -0.461753}
#standard deviation: 0.04314728718007657
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i - d, j, k] for d in [0, 1])
        if neighbor_spin_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.48265660000000005}
#standard deviation: 0.04233070607065278
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
        # Add a new term based on the number of nearest neighbors with the same spin as this site
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin as this site
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0 and h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.47798539999999995}
#standard deviation: 0.043028409996652216
#island_id: 1
#version_generated: 3
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.5321569999999999}
#standard deviation: 0.0442902800962017
#island_id: 0
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2768950000000002}
#standard deviation: 0.046637213199332554
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (np.roll(h, d//2 - 1, axis=d//2)[i,j,k] if h[i,j,k] == np.roll(h, d%3 - 1, axis=d%3)[i,j,k] else -np.roll(h, d//2 - 1, axis=d//2)[i,j,k]) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1
        
  return priorities




#score: {'data3D.txt': 0.00020620000000000038}
#standard deviation: 0.045560934160308875
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (np.roll(h, d//2 - 1, axis=d//2)[i,j,k] if h[i,j,k] == np.roll(h, d%3 - 1, axis=d%3)[i,j,k] else -np.roll(h, d//2 - 1, axis=d//2)[i,j,k]) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1
        
        for d in [3, 4]:
          if i + (d-3)%2 == 0:
            neighbor_spin = sum(J[6-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[6-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
        for d in [5,]:
          if i + (d-5)%2 == 0:
            neighbor_spin = sum(J[6-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[6-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2768950000000002}
#standard deviation: 0.046637213199332554
#island_id: 3
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (np.roll(h, d//2 - 1, axis=d//2)[i,j,k] if h[i,j,k] == np.roll(h, d%3 - 1, axis=d%3)[i,j,k] else -np.roll(h, d//2 - 1, axis=d//2)[i,j,k]) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1
        
  return priorities




#score: {'data3D.txt': 0.0823781999999998}
#standard deviation: 0.04217140790583117
#island_id: 3
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for d in range(3):
    interacting_spins[d] = np.roll(h, -1, axis=d)
  for d in range(3):
    interacting_spins[d+3] = np.roll(h, 1, axis=d)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[l, i, j, k]*interacting_spins[l, i, j, k] for l in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.027193}
#standard deviation: 0.0485339921189263
#island_id: 3
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin < 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0,1,2]:
          if i + (d-1)%2 == 0:
            neighbor_spin = sum(J[3-d,i+d,j,k] for _ in range(N))
          else:
            neighbor_spin = sum(J[3-d,i-d,j,k] for _ in range(N))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - abs(neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1538918}
#standard deviation: 0.04155179818924808
#island_id: 0
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add the contribution from the remaining neighbors
        remaining_neighbors = [J[0, i, j, (k+1)%N], J[1, (i+1)%N, k, j], J[2, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in remaining_neighbors if val < 0]) - len([val for val in remaining_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in remaining_neighbors if val < 0]) + 2 * len([val for val in remaining_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2434986}
#standard deviation: 0.18472667657390474
#island_id: 0
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  # Add a new term to the priority function based on the total spin
  priorities[:, 0] += np.exp(-total_spin) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
  priorities[:, 1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))

  return(priorities)




#score: {'data3D.txt': 0.0009277999999996685}
#standard deviation: 0.04846562438636276
#island_id: 0
#version_generated: 3
#generate time04:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        else:
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47798539999999995}
#standard deviation: 0.043028409996652216
#island_id: 1
#version_generated: 3
#generate time04:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.47798539999999995}
#standard deviation: 0.043028409996652216
#island_id: 1
#version_generated: 3
#generate time04:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.4700834}
#standard deviation: 0.044087386455084865
#island_id: 2
#version_generated: 3
#generate time04:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          for l in range(N):
            if i == l or j == l or k == l:
              continue
            neighbor_spin = J[d, i, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4497354}
#standard deviation: 0.04607731271287423
#island_id: 2
#version_generated: 3
#generate time04:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(J[d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4835018000000001}
#standard deviation: 0.04372888926968075
#island_id: 2
#version_generated: 3
#generate time04:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31066420000000006}
#standard deviation: 0.043959669679832676
#island_id: 3
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.45799739999999994}
#standard deviation: 0.041636936885894954
#island_id: 3
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5258078}
#standard deviation: 0.04149865514881175
#island_id: 0
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.48491059999999997}
#standard deviation: 0.04024154330589223
#island_id: 0
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.5258078}
#standard deviation: 0.04149865514881175
#island_id: 0
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.47798539999999995}
#standard deviation: 0.043028409996652216
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.47798539999999995}
#standard deviation: 0.043028409996652216
#island_id: 1
#version_generated: 3
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.5321569999999999}
#standard deviation: 0.0442902800962017
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1538918}
#standard deviation: 0.04155179818924808
#island_id: 0
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add the contribution from the remaining neighbors
        remaining_neighbors = [J[0, i, j, (k+1)%N], J[1, (i+1)%N, k, j], J[2, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in remaining_neighbors if val < 0]) - len([val for val in remaining_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in remaining_neighbors if val < 0]) + 2 * len([val for val in remaining_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1538918}
#standard deviation: 0.04155179818924808
#island_id: 0
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add the contribution from the remaining neighbors
        remaining_neighbors = [J[0, i, j, (k+1)%N], J[1, (i+1)%N, k, j], J[2, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in remaining_neighbors if val < 0]) - len([val for val in remaining_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in remaining_neighbors if val < 0]) + 2 * len([val for val in remaining_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5382449999999999}
#standard deviation: 0.03773839338127685
#island_id: 0
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47328020000000015}
#standard deviation: 0.04449712538984964
#island_id: 3
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.45402180000000014}
#standard deviation: 0.045797903497430986
#island_id: 3
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d+3,i,j,k] - interacting_spins[d+3,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.45402180000000014}
#standard deviation: 0.045797903497430986
#island_id: 3
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d,i,j,k] - interacting_spins[d,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*h[i][j][k]*interacting_spins[d+3,i,j,k] - interacting_spins[d+3,i,j,k]**2) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(total_spin)
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.290251}
#standard deviation: 0.04139402081218978
#island_id: 0
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48491059999999997}
#standard deviation: 0.04024154330589223
#island_id: 0
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.5622493999999999}
#standard deviation: 0.04261849738834066
#island_id: 0
#version_generated: 3
#generate time04:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.12104459999999999}
#standard deviation: 0.04372744093632738
#island_id: 0
#version_generated: 3
#generate time04:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbrs = [J[0, i, j-1, k], J[1, i, j-1, k], J[2, i, j-1, k]]
        if sum(site_nbrs) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif sum(site_nbrs) < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3

  return(priorities)




#score: {'data3D.txt': -0.5321569999999999}
#standard deviation: 0.0442902800962017
#island_id: 0
#version_generated: 3
#generate time04:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5007666000000001}
#standard deviation: 0.04353270178199373
#island_id: 0
#version_generated: 3
#generate time04:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2539410000000002}
#standard deviation: 0.05049139331608904
#island_id: 3
#version_generated: 3
#generate time04:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i%N,j%N,k%N]*h[(i+d)%N][(j+int(d/3))%N][(k+int(d/1))%N] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0,1,2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i%N,j%N,k%N]*h[(i+d)%N][(j+int(d/3))%N][(k+int(d/1))%N] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(h[:i,:j,:k] == -1) / 3)
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0,1,2]:
          if i+d > N-1:
            d = -(d+1)
          if j+d//3 > N-1:
            d = d - int(3*(N-j//3-1))
          if k+d//1 > N-1:
            d = d - int(N-1-k//1)
          total_spin += J[d,i%N,j%N,k%N]*h[(i+d)%N][(j+int(d/3))%N][(k+int(d/1))%N]
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][1] += 2
  
  return priorities




#score: {'data3D.txt': -0.3380633999999997}
#standard deviation: 0.045235848841820116
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) for d in [3,4])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(interacting_spins[d,i,j,k]-2*h[i][j][k]) 
                 - J[0,i,j,k]*h[i-1,j,k] if i > 0 else 0 
                 - J[3,i,j,k]*h[i+1,j,k] if i < N-1 else 0 
                 - J[5,i,j,k]*h[i,j-1,k] if j > 0 else 0 
                 - J[2,i,j,k]*h[i,j+1,k] if j < N-1 else 0 for d in [0,1,2])
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (h[i][j][k] > 0) 
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]

  return priorities




#score: {'data3D.txt': -0.3123194}
#standard deviation: 0.04707035610275326
#island_id: 1
#version_generated: 3
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i - d, j, k] for d in [0, 1])
        if neighbor_spin_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.38427979999999995}
#standard deviation: 0.04501270478387186
#island_id: 1
#version_generated: 3
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
          
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i - d, j, k] for d in [0, 1])
        if neighbor_spin_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
          
  return priorities




#score: {'data3D.txt': -0.1945342}
#standard deviation: 0.04764410257691921
#island_id: 1
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i - d, j, k] for d in [0, 1])
        if neighbor_spin_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 3 - total_spin
        elif neighbor_spin_sum > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] = 3 - total_spin
        
  return priorities




#score: {'data3D.txt': -0.274577}
#standard deviation: 0.04517677092267663
#island_id: 1
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product
        
        # Add new terms based on the interactions with neighboring sites
        site_neighbors_sum = sum(J[d, i, (j + 1) % N, k] for d in [0, 1]) + sum(J[d, (i + 1) % N, j, k] for d in [0, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][0] -= site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.1863990000000003}
#standard deviation: 0.04920011665636576
#island_id: 1
#version_generated: 3
#generate time04:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * np.sign(J[d, i, j, k]) for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in [J[d, i, j, k] for d in [0, 1, 2]] for val2 in site_neighbors])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product

  return priorities




#score: {'data3D.txt': -0.3607902}
#standard deviation: 0.04584057791913187
#island_id: 1
#version_generated: 3
#generate time04:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i - d, j, k] for d in [0, 1])
        if neighbor_spin_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
        
  return priorities




#score: {'data3D.txt': -0.38427979999999995}
#standard deviation: 0.04501270478387186
#island_id: 1
#version_generated: 3
#generate time04:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
          
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin_sum = sum(J[d, i - d, j, k] for d in [0, 1])
        if neighbor_spin_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product
          
  return priorities




#score: {'data3D.txt': -0.2839746}
#standard deviation: 0.04713146501902949
#island_id: 1
#version_generated: 3
#generate time04:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_product = sum([val1 * val2 for val1 in interacting_spins for val2 in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + interacting_spin_product + sum([np.exp(abs(J[d, i, j, k])) * np.sign(J[d, i, j, k]) for d in [0, 1]])
        
  return priorities




#score: {'data3D.txt': -0.36277020000000026}
#standard deviation: 0.04679924136094516
#island_id: 0
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        for d in range(3):
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0])

  return priorities




#score: {'data3D.txt': -0.18877339999999998}
#standard deviation: 0.04313738114953202
#island_id: 0
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Added this line to calculate the priority based on the magnetization
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
        
  return priorities




#score: {'data3D.txt': -0.2705002000000002}
#standard deviation: 0.04423159775499863
#island_id: 0
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.5055842}
#standard deviation: 0.043212343032517926
#island_id: 1
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin / len(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.43253539999999996}
#standard deviation: 0.04725284189167886
#island_id: 1
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 2
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44276099999999996}
#standard deviation: 0.03854140888706587
#island_id: 0
#version_generated: 3
#generate time04:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.29994740000000003}
#standard deviation: 0.048075003829849035
#island_id: 2
#version_generated: 3
#generate time04:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3110186}
#standard deviation: 0.047186459223383145
#island_id: 2
#version_generated: 3
#generate time04:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2867018}
#standard deviation: 0.0420654527701771
#island_id: 2
#version_generated: 3
#generate time04:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3110186}
#standard deviation: 0.047186459223383145
#island_id: 2
#version_generated: 3
#generate time04:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20391020000000032}
#standard deviation: 0.04719381544185637
#island_id: 3
#version_generated: 2
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.491151}
#standard deviation: 0.04444976984192382
#island_id: 3
#version_generated: 2
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 2
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14323020000000009}
#standard deviation: 0.045290318700137236
#island_id: 0
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Added this line to calculate the priority based on the magnetization
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)

  return priorities




#score: {'data3D.txt': -0.13790900000000003}
#standard deviation: 0.0471695359209734
#island_id: 0
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        total_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the priority based on the magnetization
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_spin)
        
        # Add the neighbor's spin to calculate the priority
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [interacting_spins[0], interacting_spins[1], neighbor_spin] if val > 0]) - abs(total_spin)
        
  return priorities




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 0
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3013506}
#standard deviation: 0.0457290384727254
#island_id: 0
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]))
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.44022019999999995}
#standard deviation: 0.04510742502027798
#island_id: 1
#version_generated: 3
#generate time04:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0009277999999996685}
#standard deviation: 0.04846562438636276
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
        else:
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0009277999999996685}
#standard deviation: 0.04846562438636276
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        else:
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.0009277999999996685}
#standard deviation: 0.04846562438636276
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        else:
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 3
#generate time04:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.055526599999999995}
#standard deviation: 0.04704714584796829
#island_id: 2
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                   J[1, (i+1)%N, (j+1)%N, k], J[1, i, (j+1)%N, (k+1)%N], J[1, (i+1)%N, j, (k+1)%N],
                   J[2, (i+1)%N, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.sum([abs(a) for a in interacting_spins])) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum([abs(a) for a in interacting_spins])) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
  return(priorities)




#score: {'data3D.txt': -0.29994740000000003}
#standard deviation: 0.048075003829849035
#island_id: 2
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                  [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27520259999999996}
#standard deviation: 0.05240890566726232
#island_id: 2
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                   J[1, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[1, i, j, (k+1)%N],
                   J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.29994740000000003}
#standard deviation: 0.048075003829849035
#island_id: 2
#version_generated: 3
#generate time05:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                  [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2641034}
#standard deviation: 0.053703446336711015
#island_id: 3
#version_generated: 3
#generate time05:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4986794}
#standard deviation: 0.04354297527317122
#island_id: 3
#version_generated: 3
#generate time05:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time05:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47346580000000005}
#standard deviation: 0.04406430426501705
#island_id: 0
#version_generated: 3
#generate time05:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[2, i, j, k - 1], J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4062122000000001}
#standard deviation: 0.050388067348926965
#island_id: 2
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, i-1, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, j-1, k])
          else:
            interacting_spins.append(J[d, i-1, j-1, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 2
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5064050000000001}
#standard deviation: 0.04397253614473471
#island_id: 2
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        
        # Top
        if i > 0:
          interacting_spins.append(J[0, i-1, j, k])
        else:
          interacting_spins.append(0)
          
        # Bottom
        if i < N - 1:
          interacting_spins.append(J[0, i+1, j, k])
        else:
          interacting_spins.append(0)
        
        # Left
        if j > 0:
          interacting_spins.append(J[1, i, j-1, k])
        else:
          interacting_spins.append(0)
          
        # Right
        if j < N - 1:
          interacting_spins.append(J[1, i, j+1, k])
        else:
          interacting_spins.append(0)
        
        # Front
        if k > 0:
          interacting_spins.append(J[2, i, j, k-1])
        else:
          interacting_spins.append(0)
          
        # Back
        if k < N - 1:
          interacting_spins.append(J[2, i, j, k+1])
        else:
          interacting_spins.append(0)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4325870000000002}
#standard deviation: 0.046561586216536915
#island_id: 2
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        interacting_spins += [J[d, i, (j+1)%N, k] for d in [0, 1, 2]]
        interacting_spins += [J[d, i, j, (k+1)%N] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4313426000000002}
#standard deviation: 0.04597819597635384
#island_id: 1
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= total_neighbor_spin / len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (total_neighbor_spin / len(site_neighbors))
            priorities[i * N * N + j * N + k][1] = -total_neighbor_spin / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.4054946}
#standard deviation: 0.04201134002671184
#island_id: 1
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin / len(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin / len(site_neighbors)
        
        # Add a new term based on the number of interacting spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val != 0])
        
  return(priorities)




#score: {'data3D.txt': -0.09689300000000006}
#standard deviation: 0.04937831539248783
#island_id: 1
#version_generated: 3
#generate time05:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + i1) % N, (j + j1) % N, (k + k1) % N] for d in [0, 1, 2]
                     for i1 in [-1, 0, 1] if i1 != 0
                     for j1 in [-1, 0, 1] if j1 != 0
                     for k1 in [-1, 0, 1] if k1 != 0]

        total_spin = sum(J[d, (i + i1) % N, (j + j1) % N, (k + k1) % N] for d in [0, 1, 2]
                     for i1 in [-1, 0, 1] if i1 != 0
                     for j1 in [-1, 0, 1] if j1 != 0
                     for k1 in [-1, 0, 1] if k1 != 0)

        site_neighbors = [J[0, (i + i1) % N, (j + j1) % N, (k + k1) % N] for d in [0, 1]
                     for i1 in [-1, 0, 1] if i1 != 0
                     for j1 in [-1, 0, 1] if j1 != 0
                     for k1 in [-1, 0, 1] if k1 != 0]

        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin / len(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.5055842}
#standard deviation: 0.043212343032517926
#island_id: 1
#version_generated: 3
#generate time05:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin / len(site_neighbors))
        priorities[i * N * N + j * N + k][1] -= total_neighbor_spin / len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.4986794}
#standard deviation: 0.04354297527317122
#island_id: 3
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.4986794}
#standard deviation: 0.04354297527317122
#island_id: 3
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4986794}
#standard deviation: 0.04354297527317122
#island_id: 3
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.4986794}
#standard deviation: 0.04354297527317122
#island_id: 3
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.41291380000000016}
#standard deviation: 0.050320083958197044
#island_id: 2
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, i, j, k])
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          interacting_spins.append(J[d, i + d, j + d, k + d])
        for d in [3, 4]:
          interacting_spins.append(J[d, i - d % N, j - d % N, k - d % N])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4062122000000001}
#standard deviation: 0.050388067348926965
#island_id: 2
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4062122000000001}
#standard deviation: 0.050388067348926965
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4062122000000001}
#standard deviation: 0.050388067348926965
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4062122000000001}
#standard deviation: 0.050388067348926965
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4018386}
#standard deviation: 0.04726056950609038
#island_id: 2
#version_generated: 3
#generate time05:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time05:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time05:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time05:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time05:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.16386300000000023}
#standard deviation: 0.049384134203203374
#island_id: 2
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          for neighbor_spin in site_neighbors:
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          for neighbor_spin in site_neighbors:
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.3945826}
#standard deviation: 0.04109235716334608
#island_id: 2
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5258078}
#standard deviation: 0.04149865514881175
#island_id: 0
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.5258078}
#standard deviation: 0.04149865514881175
#island_id: 0
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.5258078}
#standard deviation: 0.04149865514881175
#island_id: 0
#version_generated: 3
#generate time05:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.4347606}
#standard deviation: 0.04019783088227523
#island_id: 0
#version_generated: 3
#generate time05:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(3):
          if i > 0 and j > 0 and k > 0:
            site_nbr = J[d, (i-1)%N, (j-1)%N, (k-1)%N]
            if site_nbr > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.44022019999999995}
#standard deviation: 0.04510742502027798
#island_id: 1
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4679534}
#standard deviation: 0.04625597505663458
#island_id: 1
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += sum([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46393900000000005}
#standard deviation: 0.04258224135716672
#island_id: 1
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, k] for d in [0, 1]) for _ in range(N))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2641034}
#standard deviation: 0.053703446336711015
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.491151}
#standard deviation: 0.04444976984192382
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.21634500000000012}
#standard deviation: 0.05176052062141571
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2641034}
#standard deviation: 0.053703446336711015
#island_id: 3
#version_generated: 3
#generate time05:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy and interactions with nearest neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.218569}
#standard deviation: 0.04614776656567466
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.11946859999999997}
#standard deviation: 0.045821428764716635
#island_id: 0
#version_generated: 3
#generate time05:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.11946859999999997}
#standard deviation: 0.045821428764716635
#island_id: 0
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2450034}
#standard deviation: 0.04563434351932764
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k]]
        if sum(site_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif sum(site_neighbors) < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.3088326}
#standard deviation: 0.03886949262905293
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_nbrs = [J[0, (i+1)%N, j, k], J[1, (i+1)%N, j, k], J[2, (i+1)%N, j, k], 
               J[0, i, (j+1)%N, k], J[1, i, (j+1)%N, k], J[2, i, (j+1)%N, k], 
               J[0, i, (k+1)%N, j], J[1, i, (k+1)%N, j], J[2, i, (k+1)%N, j]]
        total_spin_neighbors = sum(site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if total_spin_neighbors > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val < 0]) + total_spin_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_neighbors
        elif total_spin_neighbors < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_nbrs if val > 0]) + total_spin_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.0942718}
#standard deviation: 0.04753228970668255
#island_id: 0
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_nbrs = [J[3, i-1, j, k], J[4, i, (j+1)%N, k], J[5, i, j, k-1]]
        
        total_spin = sum(interacting_spins)
        site_nbr_total = sum(site_nbrs)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin) + site_nbr_total
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin + site_nbr_total / abs(site_nbr_total)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) + site_nbr_total
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_nbr_total / abs(site_nbr_total)
  
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 0
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 0
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5479138}
#standard deviation: 0.039583065691782895
#island_id: 0
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.25067100000000014}
#standard deviation: 0.04416934999521727
#island_id: 0
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbor_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbor_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_sum

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_neighbor_sum = sum(site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + site_neighbor_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_neighbor_sum

  return(priorities)




#score: {'data3D.txt': -0.34953019999999996}
#standard deviation: 0.04298077207263732
#island_id: 1
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) - sum([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val > 0]) - sum([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5083222}
#standard deviation: 0.042302935916553125
#island_id: 1
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.1538918}
#standard deviation: 0.04155179818924808
#island_id: 0
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add the contribution from the remaining neighbors
        remaining_neighbors = [J[0, i, j, (k+1)%N], J[1, (i+1)%N, k, j], J[2, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in remaining_neighbors if val < 0]) - len([val for val in remaining_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in remaining_neighbors if val < 0]) + 2 * len([val for val in remaining_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1538918}
#standard deviation: 0.04155179818924808
#island_id: 0
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        remaining_neighbors = [J[0, i, j, (k+1)%N], J[1, (i+1)%N, k, j], J[2, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in remaining_neighbors if val < 0]) - len([val for val in remaining_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in remaining_neighbors if val < 0]) + 2 * len([val for val in remaining_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1538918}
#standard deviation: 0.04155179818924808
#island_id: 0
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        # Add the contribution from the remaining neighbors
        remaining_neighbors = [J[0, i, j, (k+1)%N], J[1, (i+1)%N, k, j], J[2, i, (j+1)%N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in remaining_neighbors if val < 0]) - len([val for val in remaining_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in remaining_neighbors if val < 0]) + 2 * len([val for val in remaining_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 3
#version_generated: 3
#generate time05:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = 2 - total_spin + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 0
#version_generated: 3
#generate time05:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time05:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time05:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5226042}
#standard deviation: 0.042018049721042505
#island_id: 2
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's diagonals
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, (j + 1) % N, k]
          else:
            neighbor_spin = J[3 - d, i - d, (j + 1) % N, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4835018000000001}
#standard deviation: 0.04372888926968075
#island_id: 2
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        interacting_spins.extend(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': -0.30129380000000017}
#standard deviation: 0.04570947693378257
#island_id: 2
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in interacting_spins if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] += sum(1 for val in interacting_spins if val > 0)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.30129380000000017}
#standard deviation: 0.04570947693378257
#island_id: 2
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 2
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                   for d in range(6) for e,f in [(-1,0), (1,0), (0,-1), (0,1), (-1,1), (1,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.45046980000000003}
#standard deviation: 0.041875006960715846
#island_id: 2
#version_generated: 3
#generate time05:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.40761499999999995}
#standard deviation: 0.03851341655838911
#island_id: 0
#version_generated: 2
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_neighbor_spin + total_spin)

        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 2
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.036532599999999915}
#standard deviation: 0.04774901022262138
#island_id: 2
#version_generated: 3
#generate time05:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = []

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * int(np.sign(h[i][j][k])) - 1) for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(J[d, i, j, k] < 0 for d in range(6)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(J[d, i, j, k] > 0 for d in range(6)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time05:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0023606}
#standard deviation: 0.04767832555407121
#island_id: 0
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= sum([J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.22113340000000012}
#standard deviation: 0.04743591218096265
#island_id: 3
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2641034}
#standard deviation: 0.053703446336711015
#island_id: 3
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.491151}
#standard deviation: 0.04444976984192382
#island_id: 3
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4290186}
#standard deviation: 0.047074662548339107
#island_id: 3
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy and the number of nearest neighbors with the same spin
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4573614000000001}
#standard deviation: 0.04254462680574364
#island_id: 1
#version_generated: 3
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= sum([J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time05:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= sum([J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 1
#version_generated: 3
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + np.exp(-abs(total_spin)) * site_neighbors_sum / 3
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + np.exp(-abs(total_spin)) * site_neighbors_sum / 3
          priorities[i * N * N + j * N + k][1] = 2
        
  return priorities




#score: {'data3D.txt': -0.1567782}
#standard deviation: 0.04857231603248912
#island_id: 1
#version_generated: 3
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] = -2 * np.sum([val > 0 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val < 0 for val in interacting_spins]) - np.sum([val > 0 for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.sum([val > 0 for val in interacting_spins]) - np.sum([val < 0 for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= np.sum([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.27520259999999996}
#standard deviation: 0.05240890566726232
#island_id: 2
#version_generated: 3
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                   J[1, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[1, i, j, (k+1)%N],
                   J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.32725540000000003}
#standard deviation: 0.04179678565200917
#island_id: 2
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                   J[1, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[1, i, j, (k+1)%N],
                   J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add the spins from the same layer
        for d in range(3):
          for dir in [(i+1)%N, i-1]:
            if J[d, dir, j, k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
              priorities[i * N * N + j * N + k][1] -= 2
            elif J[d, dir, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 1
              priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.27520259999999996}
#standard deviation: 0.05240890566726232
#island_id: 2
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N],
                   J[1, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[1, i, j, (k+1)%N],
                   J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
        priorities[i * N * N + j * N + k][1] -= sum([J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': 0.3287130000000002}
#standard deviation: 0.049070452932492896
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
        
        priorities[i * N * N + j * N + k][0] += total_spin if h[i][j][k] > 0 else -total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] > 0)

  return(priorities)




#score: {'data3D.txt': 0.5016713999999999}
#standard deviation: 0.04410083879066244
#island_id: 0
#version_generated: 3
#generate time05:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] -= np.sum([J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)]) - 2
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([-J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])
          priorities[i * N * N + j * N + k][1] = -2 + np.sum([J[l,i,j,k]*interacting_spins[l,i,j,k] for l in range(6)])

  return(priorities)




#score: {'data3D.txt': -0.28836379999999995}
#standard deviation: 0.05508404278518417
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.11563419999999999}
#standard deviation: 0.04747743285351473
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d,i,j,k] for d in range(6)))) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d,i,j,k] for d in range(6))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d,i,j,k] for d in range(6)))) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d,i,j,k] for d in range(6))

  return(priorities)




#score: {'data3D.txt': -0.28836379999999995}
#standard deviation: 0.05508404278518417
#island_id: 2
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3548982}
#standard deviation: 0.04742714746598197
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]

        total_neighbor_spin = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3027858000000001}
#standard deviation: 0.04458184112797497
#island_id: 1
#version_generated: 3
#generate time05:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[3 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2541654000000003}
#standard deviation: 0.04714783518720664
#island_id: 1
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.0023606}
#standard deviation: 0.04767832555407121
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0022562000000000007}
#standard deviation: 0.04710547400844195
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [3,4])
        
        priorities[i * N * N + j * N + k][0] += -J[5,i,j,k]*total_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0012594000000000004}
#standard deviation: 0.04905135871349539
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin - J[5,i,j,k]
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0023606}
#standard deviation: 0.04767832555407121
#island_id: 0
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1523502}
#standard deviation: 0.05427192607564247
#island_id: 0
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - len([val for val in interacting_spins[:, i, j, k] if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[:, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.1810418}
#standard deviation: 0.059145042503662135
#island_id: 0
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(J[d, i, j, k] < 0 for d in range(6)) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.45172899999999994}
#standard deviation: 0.04027110873815123
#island_id: 0
#version_generated: 3
#generate time06:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.03870059999999992}
#standard deviation: 0.0471993898227509
#island_id: 2
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * int(np.sign(h[i][j][k])) - 1) for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(J[d, i, j, k] < 0 for d in range(6)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * sum(J[d, i, j, k] > 0 for d in range(6)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.05570379999999993}
#standard deviation: 0.04734127570693465
#island_id: 2
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * int(np.sign(h[i][j][k])) - 1) for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(J[d, i, j, k] < 0 for d in range(3)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(J[d, i, j, k] > 0 for d in range(3)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0380694}
#standard deviation: 0.05766958109471579
#island_id: 2
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * int(np.sign(h[i][j][k])) - 1) for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(J[d, i, j, k] < 0 for d in range(6)) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * sum(J[d, i, j, k] > 0 for d in range(6)) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1567782}
#standard deviation: 0.04857231603248912
#island_id: 1
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = sum(np.exp(-abs(val)) for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] = -2 * sum(1 for val in interacting_spins if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in interacting_spins if val > 0))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val > 0) - sum(1 for val in interacting_spins if val < 0))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.1567782}
#standard deviation: 0.04857231603248912
#island_id: 1
#version_generated: 3
#generate time06:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] = -2 * np.sum([val > 0 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val < 0 for val in interacting_spins]) - np.sum([val > 0 for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.sum([val > 0 for val in interacting_spins]) - np.sum([val < 0 for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * np.sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= np.sum([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4133862000000001}
#standard deviation: 0.049640851015670555
#island_id: 2
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          interacting_spins.append(J[d, (i+d)%N, (j+d)%N, (k+d)%N])
          
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4504430000000001}
#standard deviation: 0.04457549855021253
#island_id: 2
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+1)%N, j, k])
          interacting_spins.append(J[d, i, (j+1)%N, k])
          interacting_spins.append(J[d, i, j, (k+1)%N])
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4724462000000001}
#standard deviation: 0.04385597776312826
#island_id: 2
#version_generated: 3
#generate time06:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, i, j, k])
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          interacting_spins.append(J[d, i + d, j + d, k + d])
        for d in [3, 4]:
          interacting_spins.append(J[d, i - d % N, j - d % N, k - d % N])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.31631459999999995}
#standard deviation: 0.04643426350056605
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        total_neighbor_spin = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, site_nbr, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, site_nbr, k]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.31578819999999996}
#standard deviation: 0.0495713875210287
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
         J[0, i, (j + 1) % N, k],
         J[1, (i + 1) % N, j, k],
         J[2, i, j, (k + 1) % N]
        ]
        
        site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if interacting_spins[d] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            elif interacting_spins[d] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
              priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          for d in [0, 1]:
            if interacting_spins[d] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
              priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
            elif interacting_spins[d] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_spin
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time06:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
          if all(val > 0 for val in site_same_spin):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif all(val < 0 for val in site_same_spin):
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_same_spin = [J[d, i, (j + d) % N, k] for d in [0, 1]]
          if all(val > 0 for val in site_same_spin):
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          elif all(val < 0 for val in site_same_spin):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0]) - total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0017290000000000003}
#standard deviation: 0.046618612152229504
#island_id: 0
#version_generated: 3
#generate time06:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(6):
    interacting_spins_i = J[i, :, :, :].flatten()
    interacting_spin_energy = sum(J[d, i, j, k] * interacting_spins_i[j*N*N + k] for d in range(6) for j in range(N) for k in range(N))
    
    priorities[:, 0] += np.exp(-abs(interacting_spin_energy)) * (interacting_spins_i < 0).sum()
    priorities[:, 1] -= 2 - 2 * interacting_spin_energy
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time06:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(6):
    interacting_spins = J[i].flatten()
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0920802}
#standard deviation: 0.05673227589265215
#island_id: 0
#version_generated: 3
#generate time06:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the magnetism and interactions
        priorities[i * N * N + j * N + k][0] += -abs(total_spin) * len([val for val in interacting_spins if val < 0]) - total_spin - abs(total_neighbor_spin) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.21648379999999998}
#standard deviation: 0.045650876635175364
#island_id: 2
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.053075000000000004}
#standard deviation: 0.047585078491056414
#island_id: 2
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.30576820000000005}
#standard deviation: 0.04150690145939588
#island_id: 2
#version_generated: 3
#generate time06:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1989958}
#standard deviation: 0.04582168070204322
#island_id: 2
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.28331259999999997}
#standard deviation: 0.04866018579126061
#island_id: 2
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum([spin for spin in site_neighbors if spin < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins - abs(interacting_spins))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.038775000000000004}
#standard deviation: 0.046933810147909365
#island_id: 2
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.07364260000000002}
#standard deviation: 0.04880126294718202
#island_id: 2
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 4
        
        for d in [0, 1]:
          if (i - (d - 1) % 2 == N - 1):
            neighbor_spin = J[d, i - d, j, k]
          else:
            neighbor_spin = J[1 - d, i + d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.0604842}
#standard deviation: 0.047486382788753244
#island_id: 2
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.05080500000000001}
#standard deviation: 0.047399739398017796
#island_id: 2
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                  [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors.sort(reverse=True)
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.19794459999999997}
#standard deviation: 0.04781971236676356
#island_id: 2
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [3, 4]:
          interacting_spins.append(J[d, i - d % N, j, k])
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2065786}
#standard deviation: 0.04778022752185259
#island_id: 2
#version_generated: 3
#generate time06:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, (j+1)%N, (k+1)%N], J[4, (i-1)%N if i else N-1, j, k], J[5, i, (j-1)%N if j else N-1, k]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.0022562000000000007}
#standard deviation: 0.04710547400844195
#island_id: 0
#version_generated: 3
#generate time06:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [3,4])
        
        priorities[i * N * N + j * N + k][0] += -J[5,i,j,k]*total_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.2013298000000001}
#standard deviation: 0.044975393182939506
#island_id: 0
#version_generated: 3
#generate time06:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val < 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val > 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.0022562000000000007}
#standard deviation: 0.04710547400844195
#island_id: 0
#version_generated: 3
#generate time06:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [3,4])
        
        priorities[i * N * N + j * N + k][0] += -J[5,i,j,k]*total_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0022562000000000007}
#standard deviation: 0.04710547400844195
#island_id: 0
#version_generated: 3
#generate time06:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [3,4])
        
        priorities[i * N * N + j * N + k][0] += -J[5,i,j,k]*total_spin
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0012594000000000004}
#standard deviation: 0.04905135871349539
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin - J[5,i,j,k]
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.0012594000000000004}
#standard deviation: 0.04905135871349539
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin - J[5,i,j,k]
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': 0.0024946}
#standard deviation: 0.04624493713737754
#island_id: 0
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][1] -= 2 * J[5,i,j,k]
        else:
          priorities[i * N * N + j * N + k][1] += 2 * J[5,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.48104499999999994}
#standard deviation: 0.04508257063433717
#island_id: 3
#version_generated: 3
#generate time06:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.053075000000000004}
#standard deviation: 0.047585078491056414
#island_id: 2
#version_generated: 3
#generate time06:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
  
  return(priorities)




#score: {'data3D.txt': -0.0424742}
#standard deviation: 0.04413425760517559
#island_id: 2
#version_generated: 3
#generate time06:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.0424742}
#standard deviation: 0.04413425760517559
#island_id: 2
#version_generated: 3
#generate time06:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time06:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.07481660000000001}
#standard deviation: 0.046369405478612735
#island_id: 2
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.sum([abs(a) for a in site_nbr])) * len([val for val in site_nbr if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_nbr)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum([abs(a) for a in site_nbr])) * len([val for val in site_nbr if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_nbr)
        
  return(priorities)




#score: {'data3D.txt': -0.12089980000000003}
#standard deviation: 0.04594617285433032
#island_id: 2
#version_generated: 3
#generate time06:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=0), np.roll(h, -1, axis=1), np.roll(h, -1, axis=2)]
  for i in range(3):
    interacting_spins[i] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.521925}
#standard deviation: 0.04217795745410155
#island_id: 2
#version_generated: 3
#generate time06:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.009721}
#standard deviation: 0.046391901437643185
#island_id: 2
#version_generated: 3
#generate time06:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        interacting_spin_sum = sum([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum - len(site_neighbors) / 2)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        interacting_spins_sum = sum(J[d, i, j, k] for d in [0, 1, 2] if J[d, i, j, k] != 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins_sum
        priorities[i * N * N + j * N + k][1] -= interacting_spins_sum
        
  return(priorities)




#score: {'data3D.txt': -0.12364619999999983}
#standard deviation: 0.04636289449074551
#island_id: 2
#version_generated: 3
#generate time06:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in site_nbrs if val < 0]) - len(site_nbrs) / 2)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.sum([val for val in site_nbrs if val > 0]) - len(site_nbrs) / 2)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i, j, k] for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val < 0]) - len(interacting_spins) / 2)
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.521925}
#standard deviation: 0.04217795745410155
#island_id: 2
#version_generated: 3
#generate time06:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1541757999999999}
#standard deviation: 0.046915934333230554
#island_id: 1
#version_generated: 3
#generate time06:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.30902219999999986}
#standard deviation: 0.0448612227559615
#island_id: 1
#version_generated: 3
#generate time06:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i][j][k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': 0.15152100000000013}
#standard deviation: 0.04827218784144759
#island_id: 1
#version_generated: 3
#generate time06:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [2]:
          if i > 0 and J[d, i-1, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif i > 0 and J[d, i-1, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2]:
          if i < N-1 and J[d, i+1, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif i < N-1 and J[d, i+1, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 1
#version_generated: 3
#generate time06:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2592978}
#standard deviation: 0.04586783442849684
#island_id: 2
#version_generated: 3
#generate time06:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i - d < 0:
            break
          neighbor_spin = J[d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i + d >= N:
            break
          neighbor_spin = J[d, i+d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.17173259999999999}
#standard deviation: 0.04529128456160192
#island_id: 2
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.2867018}
#standard deviation: 0.0420654527701771
#island_id: 2
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbors.sort(reverse=True)
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.2998042}
#standard deviation: 0.04498560683552018
#island_id: 2
#version_generated: 3
#generate time06:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if (i - d < 0 or j - d < 0 or k - d < 0):
            break
          neighbor_spin = J[d, i - d, j - d, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2835662000000001}
#standard deviation: 0.04661564992102973
#island_id: 3
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  return(priorities)




#score: {'data3D.txt': -0.49514660000000005}
#standard deviation: 0.03963150651236968
#island_id: 0
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time06:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.10200140000000005}
#standard deviation: 0.045057202288202494
#island_id: 3
#version_generated: 2
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the local energy
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Calculate the priority based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 2
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 3
#version_generated: 3
#generate time06:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4838782}
#standard deviation: 0.04085590489464161
#island_id: 3
#version_generated: 3
#generate time06:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time06:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time06:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0487826}
#standard deviation: 0.05957511944797089
#island_id: 2
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          def spin_priority(spin):
            return np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          result = minimize(lambda x: -spin_priority(x), [0], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          def spin_priority(spin):
            return np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          result = minimize(lambda x: -spin_priority(x), [0], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2399278}
#standard deviation: 0.05538255923266818
#island_id: 2
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time06:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time06:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0487826}
#standard deviation: 0.05957511944797089
#island_id: 2
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          def spin_priority(spin):
            return np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          result = minimize(lambda x: -spin_priority(x), [0], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          def spin_priority(spin):
            return np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          result = minimize(lambda x: -spin_priority(x), [0], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0487826}
#standard deviation: 0.05957511944797089
#island_id: 2
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          def spin_priority(spin):
            return np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          result = minimize(lambda x: -spin_priority(x), [0], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          def spin_priority(spin):
            return np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          result = minimize(lambda x: -spin_priority(x), [0], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1486422}
#standard deviation: 0.05589774967885559
#island_id: 2
#version_generated: 3
#generate time07:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in range(6):
          if d == 0:
            interacting_spins.append(J[d, (i+1)%N, j, k])
          elif d == 1:
            interacting_spins.append(J[d, i, (j+1)%N, k])
          elif d == 2:
            interacting_spins.append(J[d, i, j, (k+1)%N])
          elif d == 3:
            interacting_spins.append(J[d, (i-1)%N, j, k])
          elif d == 4:
            interacting_spins.append(J[d, i, (j-1)%N, k])
          else:
            interacting_spins.append(J[d, (i-1)%N, (j-1)%N, k])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          def spin_priority(spin):
            return -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          result = minimize(lambda x: spin_priority(x), [1], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          def spin_priority(spin):
            return -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          result = minimize(lambda x: spin_priority(x), [-1], method="SLSQP")
          priorities[i * N * N + j * N + k][0] = -result.fun
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.166283}
#standard deviation: 0.04344167619924443
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the local energy
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Calculate the priority based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
        # Calculate the priority based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.10200140000000005}
#standard deviation: 0.045057202288202494
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the local energy
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Calculate the priority based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0671002}
#standard deviation: 0.046411306380665485
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        
        same_spin_neighbors = sum([1 if val > 0 else -1 for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += -h[i][j][k] + np.exp(-abs(total_spin)) * abs(same_spin_neighbors)
        priorities[i * N * N + j * N + k][1] -= same_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': 0.10200140000000005}
#standard deviation: 0.045057202288202494
#island_id: 3
#version_generated: 3
#generate time07:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority based on the local energy
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Calculate the priority based on the number of nearest neighbors with the same spin
        neighbor_spin = sum([1 if val > 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0036274}
#standard deviation: 0.050032136964555086
#island_id: 0
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        neighbor_sites = [J[3,i,j,k], J[4,(i+1)%N,j,k], J[5,i,(j+1)%N,k]]
        total_site_neighbor_spin = sum(J[d,i,j,k]*neighbor_sites[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin - J[5,i,j,k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2*(total_spin+total_site_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.0025474}
#standard deviation: 0.04750891277686746
#island_id: 0
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2, 3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] += -site_energy
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 0
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin - J[5,i,j,k]
        priorities[i * N * N + j * N + k][1] -= 2

  # Calculate the magnetism at each site
  magnetism = h.flatten()

  # Sort sites by their magnetism in descending order
  sorted_sites = np.argsort(-magnetism)

  # Assign spins to -1 and 1 based on the priority of each site
  for i in range(N**3):
    if priorities[sorted_sites[i]][0] > priorities[sorted_sites[i]][1]:
      priorities[sorted_sites[i]] = [1, 2]
    else:
      priorities[sorted_sites[i]] = [-1, 1]

  return(priorities)




#score: {'data3D.txt': 0.0005566000000000002}
#standard deviation: 0.047933159257866564
#island_id: 0
#version_generated: 3
#generate time07:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin - J[5,i,j,k]
        if interacting_spins[3,i,(j+1)%N,k] == 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][1] += -J[5,i,j,k]
        if interacting_spins[4,(i+1)%N,j,k] == 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][1] += -J[5,i,j,k]
        if interacting_spins[5,i,j,(k+1)%N] == 0:
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][1] += -J[5,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.5611162}
#standard deviation: 0.04011279668085983
#island_id: 0
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.45172899999999994}
#standard deviation: 0.04027110873815123
#island_id: 0
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.3945826}
#standard deviation: 0.04109235716334608
#island_id: 2
#version_generated: 3
#generate time07:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36683499999999997}
#standard deviation: 0.04158578236609238
#island_id: 2
#version_generated: 3
#generate time07:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
        for d in range(3):
          if (i - d >= 0 and j - d >= 0 and k - d >= 0):
            break
          neighbor_spin = J[d, i - d, j - d, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36683499999999997}
#standard deviation: 0.04158578236609238
#island_id: 2
#version_generated: 3
#generate time07:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
        for d in range(3):
          if (i + d >= N or j + d >= N or k + d >= N):
            break
          neighbor_spin = J[d, i + d, j + d, k + d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
        for d in range(3):
          if (i - d >= 0 and j - d >= 0 and k - d >= 0):
            break
          neighbor_spin = J[d, i - d, j - d, k - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
            priorities[i * N * N + j * N + k][1] = -4 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18973099999999998}
#standard deviation: 0.04573787838323942
#island_id: 2
#version_generated: 3
#generate time07:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.18973099999999998}
#standard deviation: 0.04573787838323942
#island_id: 2
#version_generated: 3
#generate time07:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.09235900000000001}
#standard deviation: 0.046407286055101304
#island_id: 2
#version_generated: 3
#generate time07:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.18973099999999998}
#standard deviation: 0.04573787838323942
#island_id: 2
#version_generated: 3
#generate time07:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2616382}
#standard deviation: 0.04416567468928783
#island_id: 2
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2616382}
#standard deviation: 0.04416567468928783
#island_id: 2
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2616382}
#standard deviation: 0.04416567468928783
#island_id: 2
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3495438000000001}
#standard deviation: 0.04467740728332387
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43283620000000006}
#standard deviation: 0.04573224955717792
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48269500000000015}
#standard deviation: 0.04525692670741132
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40439780000000025}
#standard deviation: 0.04777045734719316
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          if d == 0:
            site_neighbors.append(J[3, (i + 1) % N, j, k])
          elif d == 1:
            site_neighbors.append(J[4, i, (j + 1) % N, k])
          else:
            site_neighbors.append(J[5, i, j, (k + 1) % N])
        
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        interacting_spins.extend(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4020182000000001}
#standard deviation: 0.049761914239305545
#island_id: 2
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        x, y, z = i % 3, j % 3, k % 3
        if h[x, y, z] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k],
                   J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], 
                   J[5, i, j, (k + 1) % N]]
        
        site_neighbors = [val for val in interacting_spins if val < 0]
        
        total_spin_sum = sum(val for val in interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors) + total_spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + sum(1 if val > 0 else -1 for val in site_neighbors))
  
  return(priorities)




#score: {'data3D.txt': -0.43283620000000006}
#standard deviation: 0.04573224955717792
#island_id: 2
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48385659999999997}
#standard deviation: 0.04074208679535206
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.36655540000000003}
#standard deviation: 0.042620854646991765
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = sum(J[d, (i + ((k - 1) % 2 - 1)) % N, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in interacting_spins if val > 0]) + 2 * len([val for val in site_neighbors if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.0031466000000000003}
#standard deviation: 0.047021674879144826
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors.sort()
        for i, neighbor in enumerate(site_neighbors):
          if h[i % N, (j + i) % N, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [neighbor] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in [neighbor] if val > 0])
            priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in [neighbor] if val < 0]) + 2 * len([val for val in [neighbor] if val > 0])

        return priorities




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in interacting_spins if val > 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.48385659999999997}
#standard deviation: 0.04074208679535206
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.48385659999999997}
#standard deviation: 0.04074208679535206
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.48385659999999997}
#standard deviation: 0.04074208679535206
#island_id: 0
#version_generated: 3
#generate time07:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time07:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0797718}
#standard deviation: 0.048156259455651246
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin + np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val < 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin + np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val > 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + total_neighbor_spin)

        site_neighbors.append(J[5,i,j,k])
        total_neighbor_spin += J[5,i,j,k]
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[3,site_nbr,j,k], J[5,i,j,k]] if val < 0]) + total_spin + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.2632374000000002}
#standard deviation: 0.0453508738751526
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val < 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val > 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + total_neighbor_spin)

        # Add the priority of the site itself
        priorities[i * N * N + j * N + k][0] += J[5,i,j,k]*h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.1119122}
#standard deviation: 0.04453047957478115
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val < 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val > 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + total_neighbor_spin)

        site_neighbors_independent = [J[5,i,(j+1)%N,k], J[3,site_nbr,j,k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_independent if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors_independent if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.2013298000000001}
#standard deviation: 0.044975393182939506
#island_id: 0
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0, 1, 2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*site_neighbors[d] for d in [0, 1, 2])

        priorities[i * N * N + j * N + k][0] += -J[3,i,j,k]*total_spin - J[4,i,j,k]*total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val < 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin + total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin + total_neighbor_spin)) * len([val for val in [J[5,i,j,k], J[3,site_nbr,j,k]] if val > 0]) + total_spin + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.36655540000000003}
#standard deviation: 0.042620854646991765
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = sum(J[d, (i + ((k - 1) % 2 - 1)) % N, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in interacting_spins if val > 0]) + 2 * len([val for val in site_neighbors if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.36655540000000003}
#standard deviation: 0.042620854646991765
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

        neighbor_spin = sum(J[d, (i + ((k - 1) % 2 - 1)) % N, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in interacting_spins if val > 0]) + 2 * len([val for val in site_neighbors if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': -0.36655540000000003}
#standard deviation: 0.042620854646991765
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = sum(J[d, (i + ((k - 1) % 2 - 1)) % N, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in interacting_spins if val > 0]) + 2 * len([val for val in site_neighbors if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.36655540000000003}
#standard deviation: 0.042620854646991765
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = sum(J[d, (i + ((k - 1) % 2 - 1)) % N, j, k] for d in [0, 1, 2])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in interacting_spins if val > 0]) + 2 * len([val for val in site_neighbors if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.28836379999999995}
#standard deviation: 0.05508404278518417
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          if total_spin > 1:
            priorities[i * N * N + j * N + k][0] += abs(total_spin) - 1
          elif total_spin < -1:
            priorities[i * N * N + j * N + k][0] -= abs(total_spin) + 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          if total_spin > 1:
            priorities[i * N * N + j * N + k][0] -= abs(total_spin) - 1
          elif total_spin < -1:
            priorities[i * N * N + j * N + k][0] += abs(total_spin) + 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.28836379999999995}
#standard deviation: 0.05508404278518417
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.28836379999999995}
#standard deviation: 0.05508404278518417
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          if total_spin > 1:
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          if total_spin < -1:
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.28836379999999995}
#standard deviation: 0.05508404278518417
#island_id: 2
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N)) # calculate all the interactions
 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins[:,i,j,k]]) - sum([val > 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins[:,i,j,k]]) - sum([val < 0 for val in interacting_spins[:,i,j,k]]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.07167939999999999}
#standard deviation: 0.04882921477599246
#island_id: 2
#version_generated: 3
#generate time07:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-val) for val in site_nbr]) - len([val for val in site_nbr if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-val) for val in site_nbr]) - len([val for val in site_nbr if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.22916940000000002}
#standard deviation: 0.049748609464386036
#island_id: 2
#version_generated: 3
#generate time07:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + site_neighbors
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.071557}
#standard deviation: 0.04589921165989673
#island_id: 2
#version_generated: 3
#generate time07:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr_x = (i + 1) % N
        site_nbr_y = (j + 1) % N
        site_nbr_z = (k + 1) % N
        
        interacting_spins_x = [J[d, i, j, k] for d in [0]]
        interacting_spins_y = [J[d, i, j, k] for d in [1]]
        interacting_spins_z = [J[d, i, j, k] for d in [2]]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0])
        total_spin_y = sum(J[d, i, j, k] for d in [1])
        total_spin_z = sum(J[d, i, j, k] for d in [2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0141858}
#standard deviation: 0.045239591491966415
#island_id: 2
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
        
        # Add more site neighbors
        for d in [0, 1, 2]:
          if i > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif i < N-1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.0386138}
#standard deviation: 0.046026013617953054
#island_id: 2
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
        
        if J[0, i, j, k] < 0 and h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        elif J[0, i, j, k] > 0 and h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0300178}
#standard deviation: 0.04343970307403125
#island_id: 2
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()

        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2

        site_neighbors.sort()

        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.0300914}
#standard deviation: 0.045957482155139874
#island_id: 2
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
        
        site_neighbors.sort(reverse=True)
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 1
            priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10440819999999999}
#standard deviation: 0.041552972129078804
#island_id: 0
#version_generated: 2
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.427353}
#standard deviation: 0.041227021126925965
#island_id: 0
#version_generated: 2
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time07:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 2
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 2
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.0079966}
#standard deviation: 0.046290364747320796
#island_id: 3
#version_generated: 2
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+di)%N, (j+dj)%N, (k+dk)%N] 
                  for d,(di,dj,dk) in enumerate([(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)])]
        total_spin = sum(val for val in interacting_spins if val > 0) - sum(val for val in interacting_spins if val < 0)
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 3
#version_generated: 2
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  def calculate_priority(site_spin, site_nbr):
    total_spin = sum(J[d, i, j, k] * site_spin for d in [0, 1, 2])
    return -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val != site_spin]) + total_spin

  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.inf
          for spin in [-1, 1]:
            priority_val = calculate_priority(spin, site_nbr)
            priorities[i * N * N + j * N + k][0] = min(priorities[i * N * N + j * N + k][0], priority_val)
        else:
          priorities[i * N * N + j * N + k][1] = -np.inf
          for spin in [-1, 1]:
            priority_val = calculate_priority(spin, site_nbr)
            priorities[i * N * N + j * N + k][1] = min(priorities[i * N * N + j * N + k][1], priority_val)

  return(priorities)




#score: {'data3D.txt': -0.2004298000000001}
#standard deviation: 0.04499170803559252
#island_id: 1
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.05485220000000022}
#standard deviation: 0.04690532544562505
#island_id: 1
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 1
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.150165}
#standard deviation: 0.04585081825878356
#island_id: 1
#version_generated: 3
#generate time07:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2690282}
#standard deviation: 0.04288417196075961
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[2, i, j, k], J[0, i, j, k - 1]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.49704420000000005}
#standard deviation: 0.0408407699041044
#island_id: 2
#version_generated: 3
#generate time07:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2088834}
#standard deviation: 0.045387163432406744
#island_id: 2
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.18973099999999998}
#standard deviation: 0.04573787838323942
#island_id: 2
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.18973099999999998}
#standard deviation: 0.04573787838323942
#island_id: 2
#version_generated: 3
#generate time07:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, (k-1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.2088834}
#standard deviation: 0.045387163432406744
#island_id: 2
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -len([val for val in interacting_spins if val < 0])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0027502}
#standard deviation: 0.046890616971415514
#island_id: 1
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.38953859999999996}
#standard deviation: 0.04855307065510893
#island_id: 2
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1]] + \
                  [J[0, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.176329}
#standard deviation: 0.051241449228139516
#island_id: 2
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4123554}
#standard deviation: 0.0459620405426043
#island_id: 2
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5104022}
#standard deviation: 0.0422318528501888
#island_id: 1
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39122219999999996}
#standard deviation: 0.043835473616239164
#island_id: 1
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 if spin < 0 else -1 for spin in interacting_spins) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 if spin > 0 else -1 for spin in interacting_spins) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 if spin < 0 else -1 for spin in site_neighbors) + total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.43612220000000035}
#standard deviation: 0.04359978425588823
#island_id: 1
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.427353}
#standard deviation: 0.041227021126925965
#island_id: 0
#version_generated: 3
#generate time07:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time07:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return(priorities)




#score: {'data3D.txt': -0.427353}
#standard deviation: 0.041227021126925965
#island_id: 0
#version_generated: 3
#generate time07:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spin_count = sum([1 for val in interacting_spins if val < 0])
        neighbor_spin_count = sum([1 for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_count + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_count + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
        
  return(priorities)




#score: {'data3D.txt': -0.4125158}
#standard deviation: 0.04540515026249776
#island_id: 3
#version_generated: 3
#generate time07:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.0198522}
#standard deviation: 0.05142731604079684
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - sum(J[d, i, j, k] for d in [0, 1])) 
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] - sum(J[d, i, j, k] for d in [0, 1])) 
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0541174}
#standard deviation: 0.04602041739532574
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h,-1,axis=i)
    interacting_spins[i+3] = np.roll(h,1,axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        
        if J[2,i,j,k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+j*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 1
#version_generated: 3
#generate time08:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5104022}
#standard deviation: 0.0422318528501888
#island_id: 1
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5104022}
#standard deviation: 0.0422318528501888
#island_id: 1
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5104022}
#standard deviation: 0.0422318528501888
#island_id: 1
#version_generated: 3
#generate time08:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2065786}
#standard deviation: 0.04778022752185259
#island_id: 2
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[3, (i+1)%N, (j+1)%N, (k+1)%N], J[4, (i-1)%N if i else N-1, j, k], J[5, i, (j-1)%N if j else N-1, k]]
        site_neighbors.sort()

        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
            priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.12226300000000001}
#standard deviation: 0.0505524210201648
#island_id: 1
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.116093}
#standard deviation: 0.04713157191310301
#island_id: 1
#version_generated: 3
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1, 2] if J[d, i, j, k] < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1, 2] if J[d, i, j, k] > 0) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i+1)%N,j,k], [(i-1+N)%N,j,k], [i,(j+1)%N,k], [i,(j-1+N)%N,k], [i,j,(k+1)%N], [i,j,(k-1+N)%N]
        for neighbor in site_neighbors:
          if J[0, neighbor[0], neighbor[1], neighbor[2]] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, neighbor[0], neighbor[1], neighbor[2]] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += -J[d,i,j,k]*interacting_spins[d-2,i,j,k]
          priorities[i * N * N + j * N + k][1] -= J[d,i,j,k]*interacting_spins[d-2,i,j,k]

  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 1
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31071580000000004}
#standard deviation: 0.04503234116010404
#island_id: 1
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [2, 3]:
          if (i + (d - 2) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[4 - d, i - d, j, k]
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.48892899999999995}
#standard deviation: 0.04333792564255931
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.032893}
#standard deviation: 0.04517604089558978
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

  return priorities




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.376313}
#standard deviation: 0.043603859359006285
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return priorities




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': 0.0073278}
#standard deviation: 0.046140515245931095
#island_id: 1
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2784754000000004}
#standard deviation: 0.04598435076023146
#island_id: 1
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 4 - 2 * total_spin
        
        for d in range(6):
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.08907739999999983}
#standard deviation: 0.04766742922835256
#island_id: 1
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.2813458}
#standard deviation: 0.047365219120785236
#island_id: 2
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum([spin for spin in site_neighbors if spin < 0])
        
        neighbor_spin = 0
        for d in range(6):
          if i == d // N and j == d % N:
            neighbor_spin += J[d, i, j, k]
          elif j == d // N and k == d % N:
            neighbor_spin += J[d, i, j, k]
          elif i == d // N and k == d % N:
            neighbor_spin += J[d, i, j, k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins - abs(interacting_spins)) + 2 * neighbor_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1833454}
#standard deviation: 0.046429539937845606
#island_id: 2
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum([spin for spin in site_neighbors if spin < 0])
        
        neighbor_spin_1 = J[3, (i-1)%N, j, k]
        neighbor_spin_2 = J[4, i, (j-1)%N, k]
        neighbor_spin_3 = J[5, i, j, (k-1)%N]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins - abs(interacting_spins) + neighbor_spin_1 + neighbor_spin_2 + neighbor_spin_3)
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.159409}
#standard deviation: 0.04386824043656185
#island_id: 2
#version_generated: 3
#generate time08:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum([spin for spin in site_neighbors if spin < 0])
        
        site_center = h[i][j][k]
        site_sum = total_spin + abs(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_sum)) * (site_center * interacting_spins - abs(interacting_spins))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * site_center
        
  return(priorities)




#score: {'data3D.txt': -0.016159}
#standard deviation: 0.06152121681989068
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * interacting_spins[d, i, j, k]
          priorities[i * N * N + j * N + k][1] += 2 * J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': 0.08760860000000005}
#standard deviation: 0.04677526917121911
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum(J[d, i, j, k] for d in range(3))
          priorities[i * N * N + j * N + k][0] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - sum(J[d, i, j, k] for d in range(3))
        
  return(priorities)




#score: {'data3D.txt': 0.0938426000000001}
#standard deviation: 0.04904459017302521
#island_id: 2
#version_generated: 3
#generate time08:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,(i+1)%N,j,k], J[1,i,(j+1)%N,k], J[2,i,j,(k+1)%N]]
        interacting_spins.sort()

        site_neighbors = [J[0, i, j, k] for d in [3, 4, 5]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(sum(J[d, i, j, k] for d in range(6)))) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][0] -= 2 - 2 * sum(J[d, i, j, k] for d in range(6))
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in range(6))
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in range(6)))) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.33069859999999973}
#standard deviation: 0.044622488478792834
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) - total_spin
          priorities[i*N*N + j*N + k][1] -= len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0])
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) - total_spin
          priorities[i*N*N + j*N + k][1] = len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.43476940000000014}
#standard deviation: 0.052265315302215495
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.070901}
#standard deviation: 0.04482301193583492
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val < 0]) - total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in range(6)] if val > 0]) - total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0137518}
#standard deviation: 0.046793387105017306
#island_id: 2
#version_generated: 3
#generate time08:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.36329740000000005}
#standard deviation: 0.046431526285919136
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d < 3 else J[d, i, (j+1)%N, k] if d < 6 else J[0, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        interacting_spin_sum = sum([val for val in interacting_spins if val > 0])
        
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum - len(site_neighbors) / 2)
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        elif site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbors_sum - len(site_neighbors) / 2)
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4298574}
#standard deviation: 0.04164046811984707
#island_id: 2
#version_generated: 3
#generate time08:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        interacting_spin_sum = sum([val for val in interacting_spins if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (interacting_spin_sum - len(interacting_spins) / 2)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum - len(site_neighbors) / 2)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.5081686000000001}
#standard deviation: 0.042415719892983074
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.47864100000000015}
#standard deviation: 0.04448953808481271
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if k == 0:
          interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        elif k < N//2:
          interacting_spins = [J[d, i, (j + d) % N, k - 1] for d in [-1, 0, 1]] + \
                     [J[d, i, j, k] for d in [0, 1, 2]]
        else:
          interacting_spins = [J[d, i, (j + d) % N, k - 1] for d in [-1, 0, 1]] + \
                     [J[d, i, (j + d) % N, k - 2] for d in [-1, 0, 1]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time08:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                   for d, e, f in [(1,0,-1), (-1,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3404814}
#standard deviation: 0.045301142303919885
#island_id: 2
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[1-d, (i+d)%N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.10338660000000002}
#standard deviation: 0.047228095244674015
#island_id: 2
#version_generated: 3
#generate time08:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 3
#version_generated: 3
#generate time08:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.2592978}
#standard deviation: 0.04586783442849684
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i - d < 0:
            break
          neighbor_spin = J[d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i + d >= N:
            break
          neighbor_spin = J[d, i+d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2592978}
#standard deviation: 0.04586783442849684
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i - d < 0:
            break
          neighbor_spin = J[d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i + d >= N:
            break
          neighbor_spin = J[d, i+d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.2592978}
#standard deviation: 0.04586783442849684
#island_id: 2
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] +\
                  [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbors.sort()
        
        for neighbor_spin in site_neighbors:
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i - d < 0:
            break
          neighbor_spin = J[d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(3):
          if i + d >= N:
            break
          neighbor_spin = J[d, i+d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 0.5
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) + 0.5
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.35823660000000007}
#standard deviation: 0.04292535638104825
#island_id: 1
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, -1]:
          if (i + d) % N == 0:
            interacting_spins.append(J[1-d, (i+d)%N, j, k])
          else:
            interacting_spins.append(J[d, i+d, j, k])

        total_spin = sum(J[2, i, j, k] for _ in [0])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1], i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1], i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5247978000000001}
#standard deviation: 0.04353059194589479
#island_id: 1
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i-1 if i>0 else N-1,j,k], J[1, i,j-1 if j>0 else N-1,k], J[2, i,(j+2)%N,k]] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i-1 if i>0 else N-1,j,k], J[1, i,j-1 if j>0 else N-1,k], J[2, i,(j+2)%N,k]] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0512378}
#standard deviation: 0.04595606043994633
#island_id: 2
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.27190980000000003}
#standard deviation: 0.040579963331181065
#island_id: 2
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + [J[0, i, (j+1)%N, k], J[1, i, j, (k+1)%N], J[2, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.23042300000000038}
#standard deviation: 0.04501838992012042
#island_id: 2
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          interacting_spins.append(J[d, (i+1)%N, j, k])
          interacting_spins.append(J[d, i, (j+1)%N, k])
          interacting_spins.append(J[d, i, j, (k+1)%N])

        total_spin = sum(J[d, i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3584266}
#standard deviation: 0.04643586429086897
#island_id: 2
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] for d in [0, 1, 2]] + \
                   [J[3, i, (j+1)%N, k], J[4, i, j, (k+1)%N], J[5, (i+1)%N, j, k]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3167134}
#standard deviation: 0.05370274313701303
#island_id: 3
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N))  
  priorities = np.zeros((N**3, 2))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k-1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([J[d, i, j, k]*interacting_spins[d, site_nbr, j, k] for d in range(6)])
          priorities[i * N * N + j * N + k][1] -= 2 - 2*np.sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] -= np.sum([J[d, i, j, k]*interacting_spins[d, site_nbr, j, k] for d in range(6)])
          priorities[i * N * N + j * N + k][1] = -2 + 2*np.sum([J[d, i, j, k] for d in range(6)])
          
  return priorities




#score: {'data3D.txt': -0.4439702}
#standard deviation: 0.0392433743702042
#island_id: 3
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add the diagonal interaction
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[0, i, j, k] if J[0, i, j, k] < 0 else -J[0, i, j, k]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.3010033999999999}
#standard deviation: 0.051957311982434196
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0366494}
#standard deviation: 0.05483704441014304
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.5104022}
#standard deviation: 0.0422318528501888
#island_id: 1
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2774566}
#standard deviation: 0.04474481284394874
#island_id: 2
#version_generated: 2
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= np.sum([2 - 2 * val if val < 0 else -2 + 2 * val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 2
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.026167400000000007}
#standard deviation: 0.048318320513445
#island_id: 2
#version_generated: 2
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, (k + 1) % N]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.010495}
#standard deviation: 0.047087877580116094
#island_id: 0
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Calculate the interaction with the site's neighbors
          neighbor_interactions = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_interactions if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_interactions if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_interactions if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_interactions if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return(priorities)




#score: {'data3D.txt': -0.0681858}
#standard deviation: 0.048065195707081024
#island_id: 0
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.sort()
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return(priorities)




#score: {'data3D.txt': -0.05083139999999997}
#standard deviation: 0.04644809849757039
#island_id: 1
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -1
        
        for d in [0, 1]:
          neighbor_spin = J[d, (i+d)%N, (j+0)%N, (k+0)%N]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-2)
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (2)
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                   for d, e, f in [(1,0,-1), (-1,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d, e, f in [(0, 1, -1), (1, 0, -1), (-1, 0, 1), (0, -1, 1)]:
          neighbor_spin = J[3+d, (i+e)%N, (j+f)%N, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] = -4 + 4 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                   for d, e, f in [(1,0,-1), (-1,0,1)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4357950000000001}
#standard deviation: 0.04493961832281178
#island_id: 3
#version_generated: 2
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_sum
        priorities[i * N * N + j * N + k][1] -= interacting_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4884546}
#standard deviation: 0.04020875947899911
#island_id: 3
#version_generated: 2
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[2, i, j, d] for d in range(N))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -1
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin < 0 else 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time08:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.28914380000000034}
#standard deviation: 0.04472060645340131
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, (j + d) % N, k] for d in [-1, 0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.5104022}
#standard deviation: 0.0422318528501888
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.41815980000000014}
#standard deviation: 0.04542319081658619
#island_id: 1
#version_generated: 3
#generate time08:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.054877}
#standard deviation: 0.045032744875257165
#island_id: 0
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if J[3, i, site_nbr, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[3, i, site_nbr, k]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if J[4, i, site_nbr, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[4, i, site_nbr, k]] if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if J[5, i, j, (k + 1) % N] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[5, i, j, (k + 1) % N]] if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.5284842000000001}
#standard deviation: 0.04476401669153473
#island_id: 2
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[2, i, j, k:] if val < 0]) + len([val for val in J[:, i, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[2, i, j, k:] if val > 0]) + len([val for val in J[:, i, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.45059899999999997}
#standard deviation: 0.040239531296972136
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_interactions = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          
          for neighbor in neighbor_interactions:
            if neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(neighbor)
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            elif neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(neighbor)
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.21931060000000002}
#standard deviation: 0.05465838240965424
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbor = [J[3, i, (site_nbr + 1) % N, k], J[4, (i + 1) % N, site_nbr, k], J[5, i, site_nbr, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.0117974}
#standard deviation: 0.046882902995015144
#island_id: 0
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Calculate the interaction with the site's neighbors
          neighbor_interactions = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_interactions if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighbor_interactions if val < 0])
          
          # Calculate the interaction with the site's magnetic field
          if h[i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if total_spin > 0 else -1)
            priorities[i * N * N + j * N + k][1] -= 1 if total_spin > 0 else 1
          elif h[i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if total_spin < 0 else -1)
            priorities[i * N * N + j * N + k][1] -= 1 if total_spin < 0 else 1
  
  return priorities




#score: {'data3D.txt': 0.12226300000000001}
#standard deviation: 0.0505524210201648
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.12226300000000001}
#standard deviation: 0.0505524210201648
#island_id: 1
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45059899999999997}
#standard deviation: 0.040239531296972136
#island_id: 0
#version_generated: 3
#generate time08:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_interactions = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          
          for neighbor in neighbor_interactions:
            if neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(neighbor)
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            elif neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(neighbor)
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.45059899999999997}
#standard deviation: 0.040239531296972136
#island_id: 0
#version_generated: 3
#generate time08:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_interactions = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          
          for neighbor in neighbor_interactions:
            if neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(neighbor)
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            elif neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(neighbor)
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.49269939999999995}
#standard deviation: 0.0410124303064327
#island_id: 0
#version_generated: 3
#generate time08:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4084626}
#standard deviation: 0.04091739436034509
#island_id: 0
#version_generated: 3
#generate time09:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.21931060000000002}
#standard deviation: 0.05465838240965424
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            
          site_nbr_neighbor = [J[3, i, (site_nbr + 1) % N, k], J[4, (i + 1) % N, site_nbr, k], J[5, i, site_nbr, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
        
  return priorities




#score: {'data3D.txt': -0.21931060000000002}
#standard deviation: 0.05465838240965424
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            
          site_nbr_neighbor = [J[3, i, (site_nbr + 1) % N, k], J[4, (i + 1) % N, site_nbr, k], J[5, i, site_nbr, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.1278934}
#standard deviation: 0.04786027785585871
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        for d in [3, 4, 5]:
          if J[d, i, site_nbr, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, site_nbr, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, site_nbr, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - len([val for val in [J[0, i, site_nbr, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, site_nbr, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, site_nbr, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - len([val for val in [J[0, i, site_nbr, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        
  return priorities




#score: {'data3D.txt': 0.0010037999999999998}
#standard deviation: 0.04862935929621117
#island_id: 0
#version_generated: 3
#generate time09:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2]) + sum(J[l, i, j, k] * interacting_spins[l, i, j, k] for l in [3, 4, 5])
        
        priorities[i*N*N + j*N + k][0] = -total_spin
        priorities[i*N*N + j*N + k][1] = total_spin
        
  return priorities




#score: {'data3D.txt': -0.4738166000000001}
#standard deviation: 0.042433536789195404
#island_id: 3
#version_generated: 3
#generate time09:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k].flatten() if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[2, i, j, :k].flatten() if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = sum(J[2, i, j, d] for d in range(N))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -1
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin < 0 else 1
        
  return(priorities)




#score: {'data3D.txt': -0.21931060000000002}
#standard deviation: 0.05465838240965424
#island_id: 0
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbor = [J[3, i, (site_nbr + 1) % N, k], J[4, (i + 1) % N, site_nbr, k], J[5, i, site_nbr, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.21931060000000002}
#standard deviation: 0.05465838240965424
#island_id: 0
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbor = [J[3, i, (site_nbr + 1) % N, k], J[4, (i + 1) % N, site_nbr, k], J[5, i, site_nbr, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
        
  return priorities




#score: {'data3D.txt': -0.21931060000000002}
#standard deviation: 0.05465838240965424
#island_id: 0
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr_neighbor = [J[3, i, (site_nbr + 1) % N, k], J[4, (i + 1) % N, site_nbr, k], J[5, i, site_nbr, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbr_neighbor if val < 0]) - len([val for val in site_nbr_neighbor if val > 0])
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
        
  return priorities




#score: {'data3D.txt': -0.38333659999999997}
#standard deviation: 0.044869082678833536
#island_id: 2
#version_generated: 3
#generate time09:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.07208700000000011}
#standard deviation: 0.043551191843622376
#island_id: 2
#version_generated: 3
#generate time09:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors.append(h[i][j][k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors.append(-h[i][j][k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        neighbor_spin = h[(i + 1) % N, (j + 1) % N, (k + 1) % N]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.0243078}
#standard deviation: 0.047658595228562924
#island_id: 0
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(neighbor)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(neighbor)
            priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        interacting_spins.sort()
        
        for d in [0, 1]:
          if d == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(val for val in interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            
          neighbor_interactions = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
          
          for neighbor in neighbor_interactions:
            if neighbor > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
              priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
            elif neighbor < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
              priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
            
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
          priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.4595542}
#standard deviation: 0.04574033780330006
#island_id: 0
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(neighbor)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(neighbor)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.30578500000000003}
#standard deviation: 0.04282750675675622
#island_id: 2
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbor_sum = sum(val for val in site_neighbors)
          if np.sum(np.array(interacting_spins) > 0) > len([val for val in interacting_spins if val < 0]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_sum - sum(val for val in site_neighbors if val < 0))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_neighbor_sum = sum(val for val in site_neighbors)
          if np.sum(np.array(interacting_spins) < 0) > len([val for val in interacting_spins if val > 0]):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_sum - sum(val for val in site_neighbors if val > 0))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.38333659999999997}
#standard deviation: 0.044869082678833536
#island_id: 2
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.38333659999999997}
#standard deviation: 0.044869082678833536
#island_id: 2
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.38333659999999997}
#standard deviation: 0.044869082678833536
#island_id: 2
#version_generated: 3
#generate time09:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.017169399999999994}
#standard deviation: 0.05192359601992142
#island_id: 1
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] + interacting_spins[d][i,j,k]) for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.001641}
#standard deviation: 0.05436568659549881
#island_id: 1
#version_generated: 3
#generate time09:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6)))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin - sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6)))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3190494000000002}
#standard deviation: 0.04427443144344148
#island_id: 1
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d) % N, j, k] for d in [-1, 0, 1])
        total_spin += sum(J[d, i, (j + d) % N, k] for d in [-1, 0, 1])
        total_spin += sum(J[d, i, j, (k + d) % N] for d in [-1, 0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.21738900000000028}
#standard deviation: 0.04297540783983324
#island_id: 1
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                 for d,e,f in itertools.product([-1,0,1], [-1,0,1], [-1,0,1]))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.2897194000000003}
#standard deviation: 0.04452208377468422
#island_id: 1
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+d)%N, (k+d)%N] for d in [-1,0,1])
        if h[i][j][k]>0:
          priorities[i*N*N+j*N+k][0]=np.exp(-abs(total_spin))
          priorities[i*N*N+j*N+k][1]=-total_spin
        else:
          priorities[i*N*N+j*N+k][0]=-np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1]=-total_spin
  return(priorities)




#score: {'data3D.txt': -0.3190494000000002}
#standard deviation: 0.04427443144344148
#island_id: 1
#version_generated: 3
#generate time09:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i + d) % N, j, k] for d in [-1, 0, 1]) + \
                     sum(J[d, i, (j + d) % N, k] for d in [-1, 0, 1]) + \
                     sum(J[d, i, j, (k + d) % N] for d in [-1, 0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.4151034}
#standard deviation: 0.042243243109874984
#island_id: 3
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a term to prioritize spins that align with the neighbors
        priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [0, 1, 2]) / 3
        priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2]) / 3
  
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 3
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37647620000000004}
#standard deviation: 0.04826303837886711
#island_id: 3
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], total_spin, *site_neighbors]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time09:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.021661800000000002}
#standard deviation: 0.05989589752862878
#island_id: 0
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
   for j in range(N):
    for k in range(N):
     total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
     neighbor_spins = interacting_spins[:,i,j,k]
     
     if (total_spin + np.sum(neighbor_spins)) > 0:
      priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * 1
      priorities[i * N * N + j * N + k][1] -= 1
     elif (total_spin + np.sum(neighbor_spins)) < 0:
      priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * 1
      priorities[i * N * N + j * N + k][1] += 1
     else:
      priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
      priorities[i * N * N + j * N + k][1] -= 1 if h[i, j, k] > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.40161660000000005}
#standard deviation: 0.04276238913391065
#island_id: 0
#version_generated: 3
#generate time09:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if J[0, i, j, k] > 0 or J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] < 0 else -1)
        elif J[0, i, j, k] < 0 or J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if h[i, j, k] > 0 else -1)
        
  return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 2
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 2
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4596114}
#standard deviation: 0.03983148290033903
#island_id: 1
#version_generated: 3
#generate time09:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4489026000000001}
#standard deviation: 0.04430593451491572
#island_id: 1
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[0, i, j, k] + J[1, i, j, k] + J[2, i, j, k]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (J[0, i, j, k] + J[1, i, j, k] + J[2, i, j, k]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4594202}
#standard deviation: 0.04010680480866059
#island_id: 1
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 3
#generate time09:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 3
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.04613980000000024}
#standard deviation: 0.04405848222487923
#island_id: 1
#version_generated: 3
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.1995209999999999}
#standard deviation: 0.04593450423156868
#island_id: 1
#version_generated: 3
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4484578000000003}
#standard deviation: 0.043854338658335726
#island_id: 1
#version_generated: 3
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] if d in [-1, 0] else J[d, i, j, k] for d in range(-2, 3)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.29539900000000036}
#standard deviation: 0.04455285264716503
#island_id: 1
#version_generated: 3
#generate time09:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] if d != 0 else J[1, i, j, k] for d in [-1, 0, 1]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time09:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time09:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.034341800000000006}
#standard deviation: 0.04521340965642826
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.44435739999999996}
#standard deviation: 0.04123392468878023
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 3
#version_generated: 3
#generate time09:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.14675380000000035}
#standard deviation: 0.04798457987270494
#island_id: 1
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1]:
          interacting_spins.append(J[2-d, (i+d)%N, j, k])
        interacting_spins.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = sum(interacting_spins[len(interacting_spins)//2:])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = -sum(interacting_spins[len(interacting_spins)//2:])

  return(priorities)




#score: {'data3D.txt': -0.3806462000000001}
#standard deviation: 0.0429011830321729
#island_id: 1
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0,1,-1]:
          interacting_spins.append(J[d,i,j,k])
        
        total_spin = sum(i for i in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.26781420000000006}
#standard deviation: 0.044343261025323794
#island_id: 1
#version_generated: 3
#generate time09:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1]:
          interacting_spins.append(J[2-d, (i+d)%N, j, k])
          interacting_spins.append(J[4-d, i, (j+d)%N, k])
          interacting_spins.append(J[5-d, i, j, (k+d)%N])
        total_spin = sum(1 if val > 0 else -1 for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.135849}
#standard deviation: 0.04505233266990734
#island_id: 2
#version_generated: 3
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, (j + d) % N, (k + d) % N] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors.append(h[i][j][k])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_neighbors.append(-h[i][j][k])
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.1995209999999999}
#standard deviation: 0.04593450423156868
#island_id: 1
#version_generated: 3
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  return(priorities)




#score: {'data3D.txt': 0.019557000000000123}
#standard deviation: 0.0470397520295335
#island_id: 1
#version_generated: 3
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, (j + d) % N, k] for d in [-1, 0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1995209999999999}
#standard deviation: 0.04593450423156868
#island_id: 1
#version_generated: 3
#generate time09:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] for d in [-1, 0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.33684979999999964}
#standard deviation: 0.045083975423203304
#island_id: 0
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_site_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.22061220000000015}
#standard deviation: 0.04717372543227848
#island_id: 0
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if J[2, i, j, k - 1] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          if J[2, i, j, k - 1] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 0
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time09:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3068782000000001}
#standard deviation: 0.04469763220529696
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2723254000000001}
#standard deviation: 0.04548475431218685
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4489026000000001}
#standard deviation: 0.04430593451491572
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4489026000000001}
#standard deviation: 0.04430593451491572
#island_id: 1
#version_generated: 3
#generate time09:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4859934000000002}
#standard deviation: 0.043276272441604764
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 2
#generate time09:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34751419999999994}
#standard deviation: 0.04422057211705883
#island_id: 1
#version_generated: 3
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3000318000000001}
#standard deviation: 0.0450052466803594
#island_id: 1
#version_generated: 3
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.5081686000000001}
#standard deviation: 0.042415719892983074
#island_id: 1
#version_generated: 3
#generate time09:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 2
#version_generated: 3
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.1348854}
#standard deviation: 0.04494730099616661
#island_id: 2
#version_generated: 3
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        site_neighbors_2 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors_2])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_2)
        
  return(priorities)




#score: {'data3D.txt': -0.3605274}
#standard deviation: 0.04223800053553672
#island_id: 2
#version_generated: 3
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3605274}
#standard deviation: 0.04223800053553672
#island_id: 2
#version_generated: 3
#generate time09:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.002955}
#standard deviation: 0.04699308475722785
#island_id: 3
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[2, i, j, :k].flatten() if val < 0]) - total_spin) + 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[2, i, j, :k].flatten() if val > 0]) - total_spin) - 1
          priorities[i * N * N + j * N + k][1] += 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.06160419999999999}
#standard deviation: 0.047981307426538514
#island_id: 1
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] + interacting_spins[d][i,j,k]) for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.tanh(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * np.tanh(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0123398}
#standard deviation: 0.04465807716371138
#island_id: 1
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+d)%N, j, k] + J[1, i, (j+d)%N, k] + J[2, i, j, (k+d)%N] 
                   for d in range(3)]
        interacting_spins.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = sum(interacting_spins[len(interacting_spins)//2:])
        else:
          priorities[i * N * N + j * N + k][0] = sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = -sum(interacting_spins[len(interacting_spins)//2:])
  
  return(priorities)




#score: {'data3D.txt': 0.14675380000000035}
#standard deviation: 0.04798457987270494
#island_id: 1
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1]:
          interacting_spins.append(J[2-d, (i+d)%N, j, k])
        interacting_spins.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = sum(interacting_spins[len(interacting_spins)//2:])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = -sum(interacting_spins[len(interacting_spins)//2:])

  return(priorities)




#score: {'data3D.txt': 0.14675380000000035}
#standard deviation: 0.04798457987270494
#island_id: 1
#version_generated: 3
#generate time09:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1]:
          interacting_spins.append(J[2-d, (i+d)%N, j, k])
        interacting_spins.sort()
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = sum(interacting_spins[len(interacting_spins)//2:])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(interacting_spins[:len(interacting_spins)//2]) - len(interacting_spins) // 2
          priorities[i * N * N + j * N + k][1] = -sum(interacting_spins[len(interacting_spins)//2:])
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :].flatten() for d in [0, 1, 2]]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time09:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.42383180000000004}
#standard deviation: 0.0474637527884174
#island_id: 0
#version_generated: 3
#generate time09:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - abs(total_neighbor_spin) / 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + abs(total_neighbor_spin) / 3
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time09:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.22846500000000036}
#standard deviation: 0.04392800171872151
#island_id: 1
#version_generated: 3
#generate time09:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+0)%N, (k+0)%N] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -1
        
  return priorities




#score: {'data3D.txt': -0.3428186000000002}
#standard deviation: 0.050617487235539466
#island_id: 2
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_2 = (i + ((k - 1) % 2)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_3 = (i + ((k + 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.1888046}
#standard deviation: 0.05401580897144835
#island_id: 2
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.4859934000000002}
#standard deviation: 0.043276272441604764
#island_id: 2
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.448979}
#standard deviation: 0.04752174659037692
#island_id: 2
#version_generated: 3
#generate time09:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - sum([1 if val > 0 else 1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.22824540000000001}
#standard deviation: 0.055041730158489746
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          if h[i][j][k] * interacting_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([spin for spin in interacting_spins if spin < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([spin for spin in interacting_spins if spin > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        if site_neighbors[0] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([spin for spin in interacting_spins if spin < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([spin for spin in interacting_spins if spin > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a term to prioritize spins that align with the neighbors
        priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [0, 1, 2]) / 3
        priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2]) / 3
  
  return(priorities)




#score: {'data3D.txt': -0.014701400000000002}
#standard deviation: 0.04714773035937149
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          interacting_spins[d] = -J[d, i, j, k]
        interacting_spins[-1] = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += sum([np.exp(-abs(val)) * len([spin for spin in site_neighbors if spin < 0]) for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([val > 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.37647620000000004}
#standard deviation: 0.04826303837886711
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], total_spin, *site_neighbors]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.40360820000000003}
#standard deviation: 0.04562541805572854
#island_id: 3
#version_generated: 3
#generate time09:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], total_spin, *site_neighbors]]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.13321300000000003}
#standard deviation: 0.04491105466363488
#island_id: 0
#version_generated: 3
#generate time09:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i+d][j][k]
          else:
            neighbor_spin = J[1-d][i-d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d][i+d][j][k]
          else:
            neighbor_spin = J[1-d][i-d][j][k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time10:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.11015019999999999}
#standard deviation: 0.05119901522451384
#island_id: 2
#version_generated: 3
#generate time10:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
  
  return(priorities)




#score: {'data3D.txt': -0.3605274}
#standard deviation: 0.04223800053553672
#island_id: 2
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3605274}
#standard deviation: 0.04223800053553672
#island_id: 2
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.3605274}
#standard deviation: 0.04223800053553672
#island_id: 2
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.0009221999999999954}
#standard deviation: 0.05581917723471029
#island_id: 2
#version_generated: 3
#generate time10:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 0
#version_generated: 3
#generate time10:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.37647620000000004}
#standard deviation: 0.04826303837886711
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(h[i][j][k])) * len([spin for spin in interacting_spins if spin < 0]) + sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [total_spin, *site_neighbors]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.34257219999999994}
#standard deviation: 0.049704149395799944
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors]]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.37647620000000004}
#standard deviation: 0.04826303837886711
#island_id: 3
#version_generated: 3
#generate time10:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], total_spin, *site_neighbors]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.4357950000000001}
#standard deviation: 0.04493961832281178
#island_id: 3
#version_generated: 3
#generate time10:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_sum
        priorities[i * N * N + j * N + k][1] -= interacting_spin_sum
        
  return(priorities)




#score: {'data3D.txt': 0.022740599999999993}
#standard deviation: 0.04692616446759739
#island_id: 3
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': 0.11405459999999999}
#standard deviation: 0.042308026884268664
#island_id: 3
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, (i+1)%N, (j+1)%N, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[1, (i+1)%N, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, (i+1)%N, (j+1)%N, k]]
        
        total_spin_x = sum([1 if spin < 0 else -1 for spin in interacting_spins_x])
        total_spin_y = sum([1 if spin < 0 else -1 for spin in interacting_spins_y])
        total_spin_z = sum([1 if spin < 0 else -1 for spin in interacting_spins_z])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x+total_spin_y+total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x+total_spin_y+total_spin_z))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x+total_spin_y+total_spin_z)
        
  return priorities




#score: {'data3D.txt': -0.14737220000000004}
#standard deviation: 0.05568273185791086
#island_id: 1
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) / (len([val for val in J[0, i, j, :] if val < 0]) + len([val for val in J[1, i, j, :] if val < 0]))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) / (len([val for val in J[0, i, j, :] if val > 0]) + len([val for val in J[1, i, j, :] if val > 0]))
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.43612220000000035}
#standard deviation: 0.04359978425588823
#island_id: 1
#version_generated: 3
#generate time10:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) - abs(total_spin)
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': 0.025410199999999997}
#standard deviation: 0.05122378603695748
#island_id: 1
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k] * h[(i+d)%N,(j+f)%N,k] for d,f in [(0,0),(1,0),(-1,0),(0,1),(0,-1)])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.16986939999999998}
#standard deviation: 0.044742924620994544
#island_id: 3
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N],
                  J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return priorities




#score: {'data3D.txt': -0.034341800000000006}
#standard deviation: 0.04521340965642826
#island_id: 3
#version_generated: 3
#generate time10:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.034341800000000006}
#standard deviation: 0.04521340965642826
#island_id: 3
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.39848219999999995}
#standard deviation: 0.044257267009610975
#island_id: 3
#version_generated: 3
#generate time10:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        interacting_spin = J[0, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0, i, j, :] if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins[1, i, :, k] if val < 0]) + np.exp(-abs(total_spin)) * len([val for val in interacting_spins[2, :, j, k] if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.35285659999999996}
#standard deviation: 0.05296098296330989
#island_id: 3
#version_generated: 3
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[1, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        interacting_spins_y = [J[3, i, j, k], J[4, (i+1)%N, j, k], J[5, i, (j+1)%N, k]]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_spin_y = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x + total_spin_y)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y)
  
  return priorities




#score: {'data3D.txt': 0.022740599999999993}
#standard deviation: 0.04692616446759739
#island_id: 3
#version_generated: 3
#generate time10:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.31537779999999976}
#standard deviation: 0.046098323040648655
#island_id: 0
#version_generated: 3
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins[0] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.20684540000000004}
#standard deviation: 0.045904565119822244
#island_id: 0
#version_generated: 3
#generate time10:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        if J[2, i, j, k-1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.31537779999999976}
#standard deviation: 0.046098323040648655
#island_id: 0
#version_generated: 3
#generate time10:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins[0] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 0
#version_generated: 3
#generate time10:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins[0] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * sum([1 if val > 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] += len(site_neighbors)
  
  return priorities




#score: {'data3D.txt': -0.31537779999999976}
#standard deviation: 0.046098323040648655
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins[0] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.31537779999999976}
#standard deviation: 0.046098323040648655
#island_id: 0
#version_generated: 3
#generate time10:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, :, :, :].flatten() for d in range(6)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins[0] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.215325}
#standard deviation: 0.047254634640424426
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) 
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.215325}
#standard deviation: 0.047254634640424426
#island_id: 2
#version_generated: 3
#generate time10:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) 
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.40360820000000003}
#standard deviation: 0.04562541805572854
#island_id: 3
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the priority for each spin
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors]]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
  
  return(priorities)




#score: {'data3D.txt': 0.2990734}
#standard deviation: 0.049758968763831915
#island_id: 3
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) - np.exp(abs(val)) * len([spin for spin in interacting_spins if spin > 0]) for val in [h[i][j][k], *site_neighbors]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.26281219999999994}
#standard deviation: 0.05371279597228206
#island_id: 3
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priority_down = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors]])
        priority_up = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
        priorities[i * N * N + j * N + k] = np.array([priority_down, priority_up])
  return(priorities)




#score: {'data3D.txt': -0.34257219999999994}
#standard deviation: 0.049704149395799944
#island_id: 3
#version_generated: 3
#generate time10:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        interacting_spins.sort()
        site_neighbors.sort()
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors]]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return(priorities)




#score: {'data3D.txt': -0.39462620000000004}
#standard deviation: 0.04286663403580925
#island_id: 2
#version_generated: 3
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
              for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_1 = J[0, i, (j+1)%N, k]
        site_nbr_2 = J[1, (i+1)%N, j, k]
        site_nbr_3 = J[2, i, j, (k+1)%N]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [site_nbr_1, site_nbr_2, site_nbr_3]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors = [site_nbr_1, site_nbr_2, site_nbr_3]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.3428186000000002}
#standard deviation: 0.050617487235539466
#island_id: 2
#version_generated: 3
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_2 = (i + ((k - 1) % 2)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_3 = (i + ((k + 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.490453}
#standard deviation: 0.04429713885794432
#island_id: 2
#version_generated: 3
#generate time10:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.215325}
#standard deviation: 0.047254634640424426
#island_id: 2
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) 
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.215325}
#standard deviation: 0.047254634640424426
#island_id: 2
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) 
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.215325}
#standard deviation: 0.047254634640424426
#island_id: 2
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) 
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) 
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.001279800000000001}
#standard deviation: 0.04724782653159825
#island_id: 2
#version_generated: 3
#generate time10:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          interacting_spins.append(J[0, i, j, k]) 
          interacting_spins.append(J[1, i, j, k]) 
          interacting_spins.append(J[2, i, j, k])
          interacting_spins.extend([J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                        for d, f, g in [(0, 1, -1), (1, 0, -1), (-1, 0, -1)]])
          interacting_spins.extend([J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])
        else:
          interacting_spins.append(-J[0, i, j, k]) 
          interacting_spins.append(-J[1, i, j, k]) 
          interacting_spins.append(-J[2, i, j, k])
          interacting_spins.extend([J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                        for d, f, g in [(0, 1, -1), (1, 0, -1), (-1, 0, -1)]])
          interacting_spins.extend([J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) 
        priorities[i * N * N + j * N + k][1] -= len(interacting_spins) - 2
  
  return(priorities)




#score: {'data3D.txt': -0.34093260000000014}
#standard deviation: 0.05048371279175097
#island_id: 2
#version_generated: 3
#generate time10:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_2 = (i + ((k - 1) % 2)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_3 = (i + ((k + 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_4 = (i + ((k + 1) % 2)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3428186000000002}
#standard deviation: 0.050617487235539466
#island_id: 2
#version_generated: 3
#generate time10:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_2 = (i + ((k - 1) % 2)) % N
        site_nbr_3 = (i + ((k + 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr_4 = (i + ((k + 1) % 2)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0030789999999999997}
#standard deviation: 0.046279355645903276
#island_id: 1
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin = h[i][j][k]
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if spin > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+k][1] -= 2*total_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+k][1] = -2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.4733618}
#standard deviation: 0.040420891884766726
#island_id: 1
#version_generated: 3
#generate time10:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] if d!=0 else J[1, i, j, k] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1348854}
#standard deviation: 0.04494730099616661
#island_id: 2
#version_generated: 3
#generate time10:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        site_neighbors_2 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors_2])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors_2)
        
  return(priorities)




#score: {'data3D.txt': -0.0788038}
#standard deviation: 0.049885234143582015
#island_id: 3
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_sum
        priorities[i * N * N + j * N + k][1] -= interacting_spin_sum
        
        # Add a new term based on the priority of the site's neighbors
        for d in [0, 1, 2]:
          for neighbor in [(i + 1) % N, (j + 1) % N, (k + 1) % N]:
            if h[neighbor][d % N][d % N] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, neighbor, d % N, k]
              priorities[i * N * N + j * N + k][1] -= J[d, neighbor, d % N, k]
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, neighbor, d % N, k]
              priorities[i * N * N + j * N + k][1] = -J[d, neighbor, d % N, k]
  
  return priorities




#score: {'data3D.txt': -0.46864260000000013}
#standard deviation: 0.04676742098127712
#island_id: 3
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spins
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + interacting_spin_sum)
        priorities[i * N * N + j * N + k][1] -= h[i][j][k] - interacting_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3562582000000001}
#standard deviation: 0.05101673777065719
#island_id: 3
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        interacting_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(interacting_spin_sum)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(interacting_spin_sum)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.1136126}
#standard deviation: 0.04685174363073374
#island_id: 3
#version_generated: 3
#generate time10:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d<3 else J[d, i, (j+1)%N, k] if 3<=d<6 else J[d, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(val for val in interacting_spins)
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        interacting_spin_sum = sum(val for val in site_neighbors if val*h[i][j][k]>0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val*h[i][j][k]<0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5680113999999999}
#standard deviation: 0.039877099067509914
#island_id: 2
#version_generated: 3
#generate time10:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.43614420000000004}
#standard deviation: 0.04234293478680948
#island_id: 3
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        x_direction = [J[3, i, (j + 1) % N, k], J[4, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in x_direction if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in x_direction if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.195607}
#standard deviation: 0.05242208915142547
#island_id: 3
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.04569100000000001}
#standard deviation: 0.04692355825169272
#island_id: 3
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:3] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:3] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [3, 4])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.41825739999999995}
#standard deviation: 0.04654327819610476
#island_id: 3
#version_generated: 3
#generate time10:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': 0.2198114}
#standard deviation: 0.043953785616713384
#island_id: 0
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - abs(total_neighbor_spin) / 3
          
          # Add the priority of the next site along each axis
          for d in [0, 1, 2]:
            site_nbr = (i + ((k - 1) % 2 - 1)) % N
            if h[i][j][k] > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in [J[e, site_nbr, j, k] for e in [0, 1, 2]] if val < 0])
              priorities[i * N * N + j * N + k][1] += 2 - 2 * J[d, i, j, k]
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in [J[e, site_nbr, j, k] for e in [0, 1, 2]] if val > 0])
              priorities[i * N * N + j * N + k][1] -= -2 + 2 * J[d, i, j, k]
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + abs(total_neighbor_spin) / 3
          
          # Add the priority of the next site along each axis
          for d in [0, 1, 2]:
            site_nbr = (i + ((k - 1) % 2 - 1)) % N
            if h[i][j][k] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in [J[e, site_nbr, j, k] for e in [0, 1, 2]] if val < 0])
              priorities[i * N * N + j * N + k][1] -= -2 + 2 * J[d, i, j, k]
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in [J[e, site_nbr, j, k] for e in [0, 1, 2]] if val > 0])
              priorities[i * N * N + j * N + k][1] += 2 - 2 * J[d, i, j, k]
  
  return priorities




#score: {'data3D.txt': -0.3325086000000001}
#standard deviation: 0.051039159926864
#island_id: 0
#version_generated: 3
#generate time10:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - abs(total_neighbor_spin) / 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + abs(total_neighbor_spin) / 3
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]) + total_spin - abs(J[3, i, j, k] + J[4, i, j, k] + J[5, i, j, k]) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - abs(J[3, i, j, k] + J[4, i, j, k] + J[5, i, j, k]) / 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]) + total_spin + abs(J[3, i, j, k] + J[4, i, j, k] + J[5, i, j, k]) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + abs(J[3, i, j, k] + J[4, i, j, k] + J[5, i, j, k]) / 3
        
  return priorities




#score: {'data3D.txt': -0.17129900000000015}
#standard deviation: 0.17863084906868698
#island_id: 0
#version_generated: 3
#generate time10:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - abs(total_neighbor_spin) / 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + abs(total_neighbor_spin) / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + abs(total_neighbor_spin) / 3
        
  # Add interactions with next-nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors_2 = [J[0, (i + 1) % N, (j + 1) % N, k], J[1, i, (k + 1) % N, (j + 1) % N], J[2, (i + 1) % N, j, (k + 1) % N]]
        total_neighbor_spin_2 = sum(site_neighbors_2)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val < 0]) + total_neighbor_spin_2 / 3
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - total_neighbor_spin_2 / 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors_2 if val > 0]) + total_neighbor_spin_2 / 3
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + total_neighbor_spin_2 / 3
        
  return(priorities)




#score: {'data3D.txt': -0.06238820000000005}
#standard deviation: 0.045196183696856546
#island_id: 1
#version_generated: 3
#generate time10:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        interacting_spins_y = [J[1, (i+e)%N, j, k] for e in range(3)]
        interacting_spins_z = [J[2, i, j, (k+f)%N] for f in range(3)]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        total_spin_y = sum(J[d, i, j, k] for d in [1, 2])
        total_spin_z = sum(J[3+d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': 0.016350999999999997}
#standard deviation: 0.04774715194647739
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in J[::, i, j, k] if val < 0]) - len([val for val in J[::, i, j, k] if val > 0]))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4596114}
#standard deviation: 0.03983148290033903
#island_id: 1
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40035260000000006}
#standard deviation: 0.04618784551416097
#island_id: 3
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors]]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        
  return priorities




#score: {'data3D.txt': -0.40035260000000006}
#standard deviation: 0.04618784551416097
#island_id: 3
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors]]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))

  return(priorities)




#score: {'data3D.txt': -0.23646300000000003}
#standard deviation: 0.04451369037723114
#island_id: 3
#version_generated: 3
#generate time10:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [h[i][j][k]] + site_neighbors + [J[d, i, j, k] for d in [3, 4, 5]] if val < 0]) - 2 * np.exp(-abs(total_spin)) * abs(site_nbr)
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        interacting_spin_sum_0 = sum(site_neighbors_0)
        interacting_spin_sum_1 = sum(site_neighbors_1)
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(interacting_spin_sum_0)) - site_spin * np.exp(-abs(interacting_spin_sum_1))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': 0.09040300000000004}
#standard deviation: 0.04579572502974487
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(site_neighbors_0) + site_spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
          priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        else:
          priorities[i * N * N + j * N + k][0] = site_spin * np.exp(-abs(sum(site_neighbors_0))) + site_spin * np.exp(-abs(sum(site_neighbors_1)))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time10:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin_0 = sum(val for val in site_neighbors_0 if val < 0)
        total_spin_1 = sum(val for val in site_neighbors_1 if val > 0)
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(total_spin_0)) - site_spin * np.exp(-abs(total_spin_1))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2506761999999999}
#standard deviation: 0.04501109900413453
#island_id: 2
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
              for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_1 = J[0, i, j, k]
        site_nbr_2 = J[1, (i+1)%N, j, k]
        site_nbr_3 = J[2, i, (j+1)%N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.490453}
#standard deviation: 0.04429713885794432
#island_id: 2
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.490453}
#standard deviation: 0.04429713885794432
#island_id: 2
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.40762180000000015}
#standard deviation: 0.04925359321673902
#island_id: 2
#version_generated: 3
#generate time10:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_1 = (i + ((k - 1) % 2 - 1)) % N
        site_nbr_2 = (i + ((k - 1) % 2)) % N
        site_nbr_3 = (i + ((k + 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.07276940000000001}
#standard deviation: 0.049926319948900705
#island_id: 3
#version_generated: 3
#generate time10:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)  
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in range(6)) + site_spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [site_spin] + list(interacting_spins[:,i,j,k]) if val < 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.07385939999999999}
#standard deviation: 0.045684269849041045
#island_id: 3
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors, J[3, i, (j + 1) % N, k], J[4, i, j, (k + 1) % N]]])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin > 0]) for val in [h[i][j][k], *site_neighbors, J[3, i, (j + 1) % N, k], J[4, i, j, (k + 1) % N]]])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
          
  return(priorities)




#score: {'data3D.txt': -0.20472460000000026}
#standard deviation: 0.0459337161009209
#island_id: 3
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_direction = [J[3, i, (j + 1) % N, k], J[4, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]) + len([val for val in x_direction if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors]))
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in x_direction if val > 0])
          priorities[i * N * N + j * N + k][1] = -(-2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors])))
        
  return priorities




#score: {'data3D.txt': -0.3623582}
#standard deviation: 0.04985921271700948
#island_id: 3
#version_generated: 3
#generate time10:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        x_direction = [J[3, i, (j + 1) % N, k], J[4, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([np.exp(-abs(val)) * len([spin for spin in interacting_spins if spin < 0]) for val in [h[i][j][k], *site_neighbors, *x_direction]]) + np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + len([val for val in x_direction if val > 0]))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin + sum([val > 0 for val in site_neighbors + x_direction]))

  return priorities




#score: {'data3D.txt': -0.09441300000000012}
#standard deviation: 0.054566245527798596
#island_id: 2
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
        site_neighbor_sum = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(J[d, i, (j + 1) % N, k] for d in [3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] += site_spin * np.exp(-abs(site_neighbor_sum))
        priorities[i * N * N + j * N + k][1] -= len([d for d in range(6) if J[d, i, j, k] > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10200060000000008}
#standard deviation: 0.0468097335993274
#island_id: 2
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        site_spin_neighbor_sum = sum([site_spin if val > 0 else -site_spin for val in site_neighbors_0]) + sum([site_spin if val < 0 else -site_spin for val in site_neighbors_1])
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1))) - site_spin_neighbor_sum
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
    
  return(priorities)




#score: {'data3D.txt': -0.002323}
#standard deviation: 0.04681909814381307
#island_id: 2
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
        for d in range(6):
            if J[d, i, j, k] > 0:
                site_neighbors_d = [J[d, (i + 1) % N, j, k], J[d, i, (j + 1) % N, k], J[d, i, j, (k + 1) % N]]
                if all(x < 0 for x in site_neighbors_d):
                    priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(site_neighbors_0))) - sum([1 if val > 0 else -1 for val in site_neighbors_d])
                elif all(x > 0 for x in site_neighbors_d):
                    priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_neighbors_0))) - sum([1 if val < 0 else 1 for val in site_neighbors_d])
        
        return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time10:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + site_spin
        interacting_spin_sum_0 = sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        interacting_spin_sum_1 = sum([J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]])
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2095570000000003}
#standard deviation: 0.04635900981470593
#island_id: 3
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        if site_nbr == i:
          site_neighbors.append(J[2, i, (j + 1) % N, k])
        elif site_nbr == j:
          site_neighbors.append(J[0, (i + 1) % N, j, k])
        elif site_nbr == k:
          site_neighbors.append(J[1, i, j, (k + 1) % N])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3772962}
#standard deviation: 0.04362924690571681
#island_id: 3
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if neighbor_spin_sum > 0:
          priorities[i * N * N + j * N + k][0] -= 2 * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] += 2 * np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.23776380000000036}
#standard deviation: 0.04703389426318002
#island_id: 3
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 2
#generate time10:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 0
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.10916739999999983}
#standard deviation: 0.04350428596402888
#island_id: 0
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3042242}
#standard deviation: 0.045095437622446895
#island_id: 0
#version_generated: 2
#generate time10:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22793820000000034}
#standard deviation: 0.04545482131479565
#island_id: 3
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(s)) for s in interacting_spins]) - len([s for s in site_neighbors if s < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(s)) for s in interacting_spins]) + len([s for s in site_neighbors if s > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1673638000000002}
#standard deviation: 0.04659576986766074
#island_id: 3
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if site_nbr == i:
          site_neighbors.append(J[2, i, (j + 1) % N, k])
        elif site_nbr == j:
          site_neighbors.append(J[0, (i + 1) % N, j, k])
        elif site_nbr == k:
          site_neighbors.append(J[1, i, j, (k + 1) % N])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.20850140000000028}
#standard deviation: 0.04567905688649888
#island_id: 3
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors.sort()
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.20881340000000032}
#standard deviation: 0.04716324437991941
#island_id: 3
#version_generated: 3
#generate time10:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.005197400000000001}
#standard deviation: 0.04990606970339379
#island_id: 1
#version_generated: 3
#generate time10:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, j, k] + J[d, i, (j+d)%N, k] + J[d, i, j, (k+d)%N] 
                 for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.003164999999999999}
#standard deviation: 0.04755498391336076
#island_id: 1
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.001641}
#standard deviation: 0.05436568659549881
#island_id: 1
#version_generated: 3
#generate time10:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6)))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin - sum(J[d, i, j, k] * interacting_spins[d][i,j,k] for d in range(6)))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22777140000000037}
#standard deviation: 0.04421603354033466
#island_id: 0
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin - 2
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin - 2
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.33210699999999976}
#standard deviation: 0.04513136416063666
#island_id: 0
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2411094000000004}
#standard deviation: 0.04601258688272156
#island_id: 0
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                  J[1, i, (j + 1) % N, k], 
                  J[2, i, j, (k + 1) % N]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
  
  return(priorities)




#score: {'data3D.txt': -0.2329554000000004}
#standard deviation: 0.045971841499335225
#island_id: 0
#version_generated: 3
#generate time10:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Calculate priority based on the number of neighboring spins
        neighboring_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighboring_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.3672982}
#standard deviation: 0.046814919809394104
#island_id: 2
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
              for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
        neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in neighbors]) - len(neighbors)
        priorities[i * N * N + j * N + k][1] -= len(neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': 0.0890522}
#standard deviation: 0.05313518791874176
#island_id: 2
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_1 = J[0, i, j, k]
        site_nbr_2 = J[1, (i+1)%N, j, k]
        site_nbr_3 = J[2, i, (j+1)%N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbrs = [site_nbr_1, site_nbr_2, site_nbr_3]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_nbrs]) - len(site_nbrs)
        priorities[i * N * N + j * N + k][1] -= len(site_nbrs) - 2
        
  return priorities




#score: {'data3D.txt': 0.0890522}
#standard deviation: 0.05313518791874176
#island_id: 2
#version_generated: 3
#generate time11:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
             for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr_1 = J[0, i, j, k]
        site_nbr_2 = J[1, (i+1)%N, j, k]
        site_nbr_3 = J[2, i, (j+1)%N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [site_nbr_1, site_nbr_2, site_nbr_3]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - len(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        
  return priorities




#score: {'data3D.txt': -0.33210699999999976}
#standard deviation: 0.04513136416063666
#island_id: 0
#version_generated: 3
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.33210699999999976}
#standard deviation: 0.04513136416063666
#island_id: 0
#version_generated: 3
#generate time11:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.17803620000000026}
#standard deviation: 0.04525239716921083
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) + interacting_spin_counts[0]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) - interacting_spin_counts[1]
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11542220000000018}
#standard deviation: 0.0448442356068202
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add interaction with next layer
        for d in range(3):
          for l in [i + (d - 1) % 2, i - (d - 1) % 2]:
            if l < N:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in [J[d, l, j, k], J[1 - d, i, j, k]] if val < 0])) + total_spin
              priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in range(3):
          for l in [i + (d - 1) % 2, i - (d - 1) % 2]:
            if l < N:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, l, j, k], J[1 - d, i, j, k]] if val > 0])) + total_spin
              priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19740380000000024}
#standard deviation: 0.045490097664876473
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a term that encourages the same spin as neighboring sites
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (-neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15630020000000025}
#standard deviation: 0.04629947299872863
#island_id: 0
#version_generated: 3
#generate time11:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a term to prioritize the magnetism at each site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] += np.abs(h[i][j][k])
        else:
          priorities[i * N * N + j * N + k][0] += np.abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= np.abs(h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.21020419999999998}
#standard deviation: 0.04975581516124522
#island_id: 1
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.22016020000000036}
#standard deviation: 0.04650536373322974
#island_id: 1
#version_generated: 3
#generate time11:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2780518000000002}
#standard deviation: 0.046791257268425666
#island_id: 0
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                 J[1, i, (j + 1) % N, k], 
                 J[2, i, j, (k + 1) % N]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
        
        site_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_spin)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * site_spin
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2411094000000004}
#standard deviation: 0.04601258688272156
#island_id: 0
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                 J[1, i, (j + 1) % N, k], 
                 J[2, i, j, (k + 1) % N]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2411094000000004}
#standard deviation: 0.04601258688272156
#island_id: 0
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                 J[1, i, (j + 1) % N, k], 
                 J[2, i, j, (k + 1) % N]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.2411094000000004}
#standard deviation: 0.04601258688272156
#island_id: 0
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                 J[1, i, (j + 1) % N, k], 
                 J[2, i, j, (k + 1) % N]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          spin_weights = np.exp(-np.abs(interacting_spins)) * (interacting_spins < 0).sum() 
          priorities[i * N * N + j * N + k][0] += spin_weights
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
        else:
          spin_weights = np.exp(-np.abs(interacting_spins)) * (interacting_spins > 0).sum() 
          priorities[i * N * N + j * N + k][0] -= spin_weights
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
        
        # Add the priority based on the magnetism
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.29539900000000036}
#standard deviation: 0.04455285264716503
#island_id: 1
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, (j + d) % N, k] if d != 0 else J[1, i, j, k] for d in [-1, 0, 1]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3279254000000003}
#standard deviation: 0.04534959663370777
#island_id: 1
#version_generated: 3
#generate time11:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, (i + d) % N, k] if d != 0 else J[1, i, i, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, j, (j + d) % N] if d != 0 else J[2, i, j, j] for d in [-1, 0, 1]]
        interacting_spins_z = [J[3, i, j, (k + d) % N] if d != 0 else J[4, i, j, k] for d in [-1, 0, 1]]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
          priorities[i * N * N + j * N + k][1] -= total_spin_x + total_spin_y + total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z))
          priorities[i * N * N + j * N + k][1] = -total_spin_x - total_spin_y - total_spin_z

  return(priorities)




#score: {'data3D.txt': -0.2329554000000004}
#standard deviation: 0.045971841499335225
#island_id: 0
#version_generated: 3
#generate time11:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Calculate priority based on the number of neighboring spins
        neighboring_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighboring_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val > 0])
  
  return priorities




#score: {'data3D.txt': 0.0013434000000000002}
#standard deviation: 0.047512412235541146
#island_id: 0
#version_generated: 3
#generate time11:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])

        neighbor_spin = sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Calculate priority based on the number of neighboring spins
        neighboring_spins = list(itertools.chain(*[[J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] for _ in range(N)]))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighboring_spins if val < 0]) - len([val for val in neighboring_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in neighboring_spins if val < 0]) - len([val for val in neighboring_spins if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.041855399999999994}
#standard deviation: 0.04681495670018291
#island_id: 0
#version_generated: 3
#generate time11:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 2 * neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - 2 * neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0016877999999999995}
#standard deviation: 0.04658877044052569
#island_id: 1
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins_x = [J[0].flatten() for _ in range(N)]
  interacting_spins_y = [J[1].flatten() for _ in range(N)]
  interacting_spins_z = [J[2].flatten() for _ in range(N)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = np.sum(J[0, :, i, k]) * h[i, j, k]
        total_spin_y = np.sum(J[1, i, :, k]) * h[i, j, k]
        total_spin_z = np.sum(J[2, i, j, :]) * h[i, j, k]

        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
          priorities[i*N*N+k][1] -= total_spin_x + total_spin_y + total_spin_z
        else:
          priorities[i*N*N+k][0] -= np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z))
          priorities[i*N*N+k][1] = -total_spin_x - total_spin_y - total_spin_z

  return(priorities)




#score: {'data3D.txt': -0.002013000000000001}
#standard deviation: 0.04724020100507618
#island_id: 1
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin))
        priorities[i*N*N+k][1] -= 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.0030789999999999997}
#standard deviation: 0.046279355645903276
#island_id: 1
#version_generated: 3
#generate time11:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N+k][1] -= 2*total_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(abs(total_spin))
          priorities[i*N*N+k][1] = -2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3444706}
#standard deviation: 0.04322763671125222
#island_id: 2
#version_generated: 3
#generate time11:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 0
#version_generated: 3
#generate time11:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.1967778000000003}
#standard deviation: 0.046385986969773536
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, i, j, (k + 1) % N], J[5, (i + 1) % N, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) + interacting_spin_counts[0]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) - interacting_spin_counts[1]
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.24626500000000043}
#standard deviation: 0.04789304558075211
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], 
                 J[1, i, (j + 1) % N, k], 
                 J[2, i, j, (k + 1) % N]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
          
          site_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin
          
          # Add the priority based on the magnetism
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
          
          site_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_spin)) 
          priorities[i * N * N + j * N + k][1] += 2 - 2 * site_spin
          
          # Add the priority based on the magnetism
          priorities[i * N * N + j * N + k][0] -= h[i][j][k]
          priorities[i * N * N + j * N + k][1] += h[i][j][k]
  
  return priorities




#score: {'data3D.txt': -0.17987500000000023}
#standard deviation: 0.04510869201162898
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[d, (i + d) % N, j, k] for d in [0, 1, 2]]
        
        interacting_spins = sum(val for val in site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin < 0), sum(1 for spin in site_neighbors if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(interacting_spins)) * (site_neighbor_counts[0] - site_neighbor_counts[1])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spins
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin < 0), sum(1 for spin in site_neighbors if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(interacting_spins)) * (site_neighbor_counts[0] - site_neighbor_counts[1])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * interacting_spins
        
  return priorities




#score: {'data3D.txt': -0.17803620000000026}
#standard deviation: 0.04525239716921083
#island_id: 0
#version_generated: 3
#generate time11:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) + interacting_spin_counts[0]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + total_spin + neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) - interacting_spin_counts[1]
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i*N*N+j*N+k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [0, 1]]
        interacting_spins.append(J[2, i, (j + 1) % N, k])
        
        total_spin = sum([val for val in interacting_spins if val < 0]) - sum([val for val in interacting_spins if val > 0])
        
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11073899999999999}
#standard deviation: 0.0453493188372218
#island_id: 3
#version_generated: 3
#generate time11:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.09173460000000003}
#standard deviation: 0.046126722004061815
#island_id: 3
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors.append(J[2, i, (j + 1) % N, k])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': 0.12526660000000012}
#standard deviation: 0.04556675810763807
#island_id: 2
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        interacting_spin_sum_0 = sum(site_neighbors_0)
        interacting_spin_sum_1 = sum(site_neighbors_1)
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(interacting_spin_sum_0)) - site_spin * np.exp(-abs(interacting_spin_sum_1))
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (interacting_spin_sum_0 > 0)
        else:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * (interacting_spin_sum_1 < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        interacting_spin_sum_0 = sum(site_neighbors_0)
        interacting_spin_sum_1 = sum(site_neighbors_1)
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(interacting_spin_sum_0)) - site_spin * np.exp(-abs(interacting_spin_sum_1))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        interacting_spin_sum_0 = sum(site_neighbors_0)
        interacting_spin_sum_1 = sum(site_neighbors_1)
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(interacting_spin_sum_0)) - site_spin * np.exp(-abs(interacting_spin_sum_1))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time11:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        interacting_spin_sum_0 = sum(site_neighbors_0)
        interacting_spin_sum_1 = sum(site_neighbors_1)
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(interacting_spin_sum_0)) - site_spin * np.exp(-abs(interacting_spin_sum_1))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time11:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + site_spin
        interacting_spin_sum_0 = sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        interacting_spin_sum_1 = sum([J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]])
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + site_spin
        interacting_spin_sum_0 = sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        interacting_spin_sum_1 = sum([J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]])
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
    
  return(priorities)




#score: {'data3D.txt': -0.0028245999999999996}
#standard deviation: 0.0473882651596363
#island_id: 2
#version_generated: 3
#generate time11:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        site_neighbors_0 = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_1 = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + site_spin
        interacting_spin_sum_0 = sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        interacting_spin_sum_1 = sum([J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]])
        
        priorities[i * N * N + j * N + k][0] = -site_spin * np.exp(-abs(sum(site_neighbors_0))) - site_spin * np.exp(-abs(sum(site_neighbors_1)))
        priorities[i * N * N + j * N + k][1] = 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.40440539999999997}
#standard deviation: 0.04220058495850502
#island_id: 3
#version_generated: 3
#generate time11:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[0, i, (j + 1) % N, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.1072954}
#standard deviation: 0.045336032235298224
#island_id: 1
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, k] if d!=0 else J[1, i, j, k] for d,e in [(1,0),(-1,0)]]
        interacting_spins_y = [J[1, i, (j+f)%N, k] if f!=0 else J[2, i, j, k] for f in [-1, 1]]
        interacting_spins_z = [J[3, (i+d)%N, j, (k+e)%N] if e!=0 else J[4, i, j, k] for d,e in [(1,0),(-1,0)]]
        
        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
          priorities[i * N * N + j * N + k][1] -= total_spin_x + total_spin_y + total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z))
          priorities[i * N * N + j * N + k][1] = -total_spin_x - total_spin_y - total_spin_z
        
        for d, e in [(0, 1), (1, 0), (-1, 0)]:
          neighbor_spin = J[3+d, (i+e)%N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
            priorities[i * N * N + j * N + k][1] -= total_spin_x + total_spin_y + total_spin_z
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z))
            priorities[i * N * N + j * N + k][1] = -total_spin_x - total_spin_y - total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.21526659999999997}
#standard deviation: 0.04456937967304459
#island_id: 1
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] if d != 0 else J[1, i, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, (j+e)%N, k] if e != 0 else J[2, i, j, k] for e in [-1, 0, 1]]
        interacting_spins_z = [J[3, i, j, (k+f)%N] if f != 0 else J[4, i, j, k] for f in [-1, 0, 1]]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y + total_spin_z)

  return(priorities)




#score: {'data3D.txt': -0.3464914000000002}
#standard deviation: 0.04595779722789159
#island_id: 1
#version_generated: 3
#generate time11:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, (j+e)%N, k] for e in [-1, 0, 1]]
        interacting_spins_z = [J[3, i, j, (k+f)%N] for f in [-1, 0, 1]]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
          priorities[i * N * N + j * N + k][1] -= total_spin_x + total_spin_y + total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z))
          priorities[i * N * N + j * N + k][1] = -total_spin_x - total_spin_y - total_spin_z

        for d in range(6):
          if d < 3:
            interacting_spins = interacting_spins_x
          elif d == 3:
            interacting_spins = interacting_spins_y
          else:
            interacting_spins = interacting_spins_z

          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * sum(interacting_spins)

  return(priorities)




#score: {'data3D.txt': -0.1986682000000003}
#standard deviation: 0.0459884875676511
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        neighbor_spin_sum += J[2, i, (j + 1) % N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.3415093999999997}
#standard deviation: 0.045639942940805686
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 2
          priorities[i * N * N + j * N + k][1] -= 4
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - 2
          priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.08666420000000002}
#standard deviation: 0.04582185241083124
#island_id: 3
#version_generated: 3
#generate time11:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (1 if site_nbr == i or site_nbr == j else 2) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (1 if site_nbr == i or site_nbr == j else 2) - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44169780000000003}
#standard deviation: 0.03997206818717291
#island_id: 0
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
        interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) + interacting_spin_counts[0]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin + neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11276300000000021}
#standard deviation: 0.0476217029409911
#island_id: 0
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) + interacting_spin_counts[0]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) - interacting_spin_counts[1]
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1126670000000002}
#standard deviation: 0.04746286665383793
#island_id: 0
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) + interacting_spin_counts[0]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbor_counts = [sum(1 for spin in site_neighbors if spin == -1), sum(1 for spin in site_neighbors if spin == 1)]
          interacting_spin_counts = [sum(1 for spin in interacting_spins if spin < 0), sum(1 for spin in interacting_spins if spin > 0)]
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbor_counts[0] - site_neighbor_counts[1]) - interacting_spin_counts[1]
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1879946000000003}
#standard deviation: 0.045760123370026
#island_id: 0
#version_generated: 3
#generate time11:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((total_spin + total_neighbor_spin) / (1 + abs(total_spin)))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * ((total_spin + total_neighbor_spin) / (1 + abs(total_spin)))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4829646000000001}
#standard deviation: 0.042529164426778954
#island_id: 2
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + J[3, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - J[3, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2975098}
#standard deviation: 0.043258012713947
#island_id: 2
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
    
  return(priorities)




#score: {'data3D.txt': -0.49659820000000016}
#standard deviation: 0.043862890428698384
#island_id: 2
#version_generated: 3
#generate time11:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4859934000000002}
#standard deviation: 0.043276272441604764
#island_id: 2
#version_generated: 3
#generate time11:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time11:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.03638059999999999}
#standard deviation: 0.04471072425760961
#island_id: 1
#version_generated: 3
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+1)%N, j, k]] + [J[5, i, (j+1)%N, k]] + [J[4, i, j, (k+1)%N]]
        interacting_spins_y = [J[2, i, (j+1)%N, k]] + [J[3, (i+1)%N, j, k]] + [J[5, i, j, (k+1)%N]]
        interacting_spins_z = [J[1, i, j, (k+1)%N]] + [J[4, (i+1)%N, j, k]] + [J[0, i, (j+1)%N, k]]
        
        total_spin_x = sum(1 if val > 0 else -1 for val in interacting_spins_x)
        total_spin_y = sum(1 if val > 0 else -1 for val in interacting_spins_y)
        total_spin_z = sum(1 if val > 0 else -1 for val in interacting_spins_z)
        
        total_spin = total_spin_x + total_spin_y + total_spin_z
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0758562}
#standard deviation: 0.044955292475525065
#island_id: 1
#version_generated: 3
#generate time11:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [-1, 0, 1]:
          interacting_spins.append(J[5, (i+d)%N, (j+d)%N, (k+d)%N])
        total_spin = sum(1 if val > 0 else -1 for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.16515780000000024}
#standard deviation: 0.04727631224154439
#island_id: 3
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        neighbor_spin_sum += J[2, i, (j + 1) % N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + site_neighbors_sum
        
        # Add the term related to the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i * N * N + j * N + k][1] -= neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.16147020000000037}
#standard deviation: 0.047377011218100284
#island_id: 3
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * (len([val for val in interacting_spins if val > 0]) + 1)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 4 - 2 * (len([val for val in interacting_spins if val < 0]) + 1)
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        neighbor_spin_sum += J[2, i, (j + 1) % N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + site_neighbors_sum
        
  return(priorities)




#score: {'data3D.txt': -0.1783266000000004}
#standard deviation: 0.04654395097582499
#island_id: 3
#version_generated: 3
#generate time11:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                  for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.3728918}
#standard deviation: 0.04227268069048851
#island_id: 2
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.1138878000000001}
#standard deviation: 0.04328838748625317
#island_id: 2
#version_generated: 3
#generate time11:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+f)%N, (k+g)%N] 
                   for d, f, g in [(0, 0, -1), (0, 1, 0), (1, 0, 0), (-1, 0, 0)]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(interacting_spins) + len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum(interacting_spins) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2
        
  return priorities




#score: {'data3D.txt': -0.03415939999999999}
#standard deviation: 0.04539007459390214
#island_id: 3
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        for d in [0, 1, 2]:
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - 2
            priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - 2
            priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.16867460000000023}
#standard deviation: 0.046821970001698986
#island_id: 3
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        # Add the interactions from other sites
        if i > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[1, i-1, j, k]
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * J[1, i-1, j, k]
        if j > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[2, i, j-1, k]
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * J[2, i, j-1, k]
        if k > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[0, i, j, k-1]
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * J[0, i, j, k-1]
        
  return priorities




#score: {'data3D.txt': -0.14260700000000026}
#standard deviation: 0.047709341548589836
#island_id: 3
#version_generated: 3
#generate time11:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if site_nbr == i:
          site_neighbors.append(J[2, i, (j + 1) % N, k])
        elif site_nbr == j:
          site_neighbors.append(J[0, (i + 1) % N, j, k])
        elif site_nbr == k:
          site_neighbors.append(J[1, i, j, (k + 1) % N])

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])

        site_neighbors.sort()

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) - len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) - len(site_neighbors)

  return priorities




#score: {'data3D.txt': -0.3806462000000001}
#standard deviation: 0.0429011830321729
#island_id: 1
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0,1,-1]:
          interacting_spins.append(J[d,i,j,k])
        
        total_spin = sum(i for i in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3430994}
#standard deviation: 0.041169156411566175
#island_id: 1
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0,1,-1]:
          interacting_spins.append(J[d,i,j,k])
          
        total_spin = sum(i for i in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3615990000000002}
#standard deviation: 0.0467869259409079
#island_id: 1
#version_generated: 3
#generate time11:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        site_neighbors = []
        for d in [0,1,-1]:
          interacting_spins.append(J[d,i,j,k])
          if d == 0:
            site_neighbors.append(J[3,(i+d)%N,j,k]) 
            site_neighbors.append(J[4,(i+2)%N,j,k])
          elif d == 1:
            site_neighbors.append(J[5,i,(j+d)%N,k])
            site_neighbors.append(J[0,i,(j-1)%N,k])
          else:
            site_neighbors.append(J[1,i,j,(k+d)%N]) 
            site_neighbors.append(J[2,i,j,(k-1)%N])
        
        total_spin = sum(i for i in interacting_spins)
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2095570000000003}
#standard deviation: 0.04635900981470593
#island_id: 3
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
          
          if site_nbr == i:
            site_neighbors.append(J[2, i, (j + 1) % N, k])
          elif site_nbr == j:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif site_nbr == k:
            site_neighbors.append(J[1, i, j, (k + 1) % N])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
          
          if site_nbr == i:
            site_neighbors.append(J[2, i, (j + 1) % N, k])
          elif site_nbr == j:
            site_neighbors.append(J[0, (i + 1) % N, j, k])
          elif site_nbr == k:
            site_neighbors.append(J[1, i, j, (k + 1) % N])
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 3
#version_generated: 3
#generate time11:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20059540000000026}
#standard deviation: 0.046098177174808116
#island_id: 3
#version_generated: 3
#generate time11:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_spin = h[i][j][k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - (len([val for val in site_neighbors if val > 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - (len([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin

        result = minimize(lambda x: np.sum(np.square(x)), np.zeros(2))
        if result.success:
          priorities[i * N * N + j * N + k][0] -= (result.fun) / (2 * len(interacting_spins))
          priorities[i * N * N + j * N + k][1] += (result.fun) / (2 * len(interacting_spins))

  return priorities




#score: {'data3D.txt': -0.1104546}
#standard deviation: 0.047047117008803
#island_id: 3
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
          
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
  
  return priorities




#score: {'data3D.txt': 0.23353300000000035}
#standard deviation: 0.045715896042842694
#island_id: 3
#version_generated: 3
#generate time11:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]] if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins[:,i,j,k] if val > 0]) - 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]] if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins[:,i,j,k] if val < 0]) - 2
        
  return priorities




#score: {'data3D.txt': -0.02184619999999999}
#standard deviation: 0.04697371675266925
#island_id: 3
#version_generated: 3
#generate time11:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
        for d in range(3):
          if d == 0:
            site_neighbors = [J[d, i, (j + 1) % N, k]]
          elif d == 1:
            site_neighbors = [J[d, (i + 1) % N, j, k]]
          else:
            site_neighbors = [J[d, i, j, (k + 1) % N]]
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.5045814000000001}
#standard deviation: 0.04235008776897635
#island_id: 0
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[1 - d, i - d, j, k] > 0))
        site_same_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] < 0) or ((i + (d - 1) % 2 == 1) and J[1 - d, i - d, j, k] < 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors

  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3880014000000001}
#standard deviation: 0.04444477874891493
#island_id: 0
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 0
#version_generated: 2
#generate time11:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] += len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.25679700000000005}
#standard deviation: 0.04804647199326919
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[1 - d, i - d, j, k] > 0))
        site_same_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] < 0) or ((i + (d - 1) % 2 == 1) and J[1 - d, i - d, j, k] < 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors - site_same_neighbors
        priorities[i * N * N + j * N + k][1] -= site_same_neighbors + site_opposite_neighbors
        
  return priorities




#score: {'data3D.txt': -0.2563438}
#standard deviation: 0.04769282547260123
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time11:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.21526659999999997}
#standard deviation: 0.04456937967304459
#island_id: 1
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] if d != 0 else J[1, i, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, (j+e)%N, k] if e != 0 else J[2, i, j, k] for e in [-1, 0, 1]]
        interacting_spins_z = [J[3, i, j, (k+f)%N] if f != 0 else J[4, i, j, k] for f in [-1, 0, 1]]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y + total_spin_z)

  return(priorities)




#score: {'data3D.txt': -0.21526659999999997}
#standard deviation: 0.04456937967304459
#island_id: 1
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] if d != 0 else J[1, i, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, (j+e)%N, k] if e != 0 else J[2, i, j, k] for e in [-1, 0, 1]]
        interacting_spins_z = [J[3, i, j, (k+f)%N] if f != 0 else J[4, i, j, k] for f in [-1, 0, 1]]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y + total_spin_z)

  return(priorities)




#score: {'data3D.txt': -0.020545}
#standard deviation: 0.04635211036188104
#island_id: 1
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] if d != 0 else J[1, i, j, k] 
                   for d in [-1, 0, 1]]
        
        total_spin = sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.21526659999999997}
#standard deviation: 0.04456937967304459
#island_id: 1
#version_generated: 3
#generate time11:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] if d != 0 else J[1, i, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[1, i, (j+e)%N, k] if e != 0 else J[2, i, j, k] for e in [-1, 0, 1]]
        interacting_spins_z = [J[3, i, j, (k+f)%N] if f != 0 else J[4, i, j, k] for f in [-1, 0, 1]]

        total_spin_x = sum(interacting_spins_x)
        total_spin_y = sum(interacting_spins_y)
        total_spin_z = sum(interacting_spins_z)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x + total_spin_y + total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin_x) + abs(total_spin_y) + abs(total_spin_z)) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x + total_spin_y + total_spin_z)

  return(priorities)




#score: {'data3D.txt': -0.15604980000000018}
#standard deviation: 0.0456867687625203
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin - len([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.2644530000000004}
#standard deviation: 0.04275075708101553
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 3
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 3
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        neighbor_spin_sum += J[2, i, (j + 1) % N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + site_neighbors_sum
        
        # Add the term related to the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i * N * N + j * N + k][1] -= neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.14887860000000017}
#standard deviation: 0.04758487513948104
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2 * total_spin
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        neighbor_spin_sum += J[2, i, (j + 1) % N, k]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + site_neighbors_sum
        
        # Add the term related to the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum - 2 * neighbor_spin_sum
        priorities[i * N * N + j * N + k][1] -= 4 * neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.17361900000000022}
#standard deviation: 0.04757929380518379
#island_id: 3
#version_generated: 3
#generate time11:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum - len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + site_neighbors_sum
        
        # Add the term related to the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin_sum
        priorities[i * N * N + j * N + k][1] -= neighbor_spin_sum
        
  return priorities




#score: {'data3D.txt': 0.1703866}
#standard deviation: 0.04657998991455451
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_up_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_up_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0006777999999999996}
#standard deviation: 0.04659471630088544
#island_id: 0
#version_generated: 3
#generate time11:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 2
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.32893539999999966}
#standard deviation: 0.04554537459325589
#island_id: 2
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
        # Add a new term based on the neighbors' spin
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 2
#version_generated: 2
#generate time11:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.24423460000000036}
#standard deviation: 0.04450028452538253
#island_id: 0
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
        
        # Add a term based on the spin of the current site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time11:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])

  return priorities




#score: {'data3D.txt': -0.27985460000000034}
#standard deviation: 0.045750080424410186
#island_id: 1
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])

        spin_magnetism = h[i][j][k]
        interacting_spin_sum = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])

        if spin_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += interacting_spin_sum
          priorities[i * N * N + j * N + k][1] -= abs(spin_magnetism)
        else:
          priorities[i * N * N + j * N + k][0] -= interacting_spin_sum
          priorities[i * N * N + j * N + k][1] = 2 - 2 * abs(spin_magnetism)

  return(priorities)




#score: {'data3D.txt': -0.3231310000000002}
#standard deviation: 0.04421620697210469
#island_id: 1
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
        interacting_spin = J[3, i, (j+1)%N, k]
        priorities[i * N * N + j * N + k][0] += -interacting_spin
        priorities[i * N * N + j * N + k][1] -= interacting_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15684620000000002}
#standard deviation: 0.12168048284568894
#island_id: 1
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
        interacting_spin = sum(J[::, i, j, k]) / (8 * J[3, 0, 0, 0])
        priorities[i * N * N + j * N + k][0] += 2 * interacting_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2897466000000001}
#standard deviation: 0.045588183429919646
#island_id: 1
#version_generated: 3
#generate time11:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])

        spin_magnetism = h[(i+1)%N, j, k]
        
        if spin_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_magnetism)) * len([val for val in J[3:, i, j, k] if val < 0]) + spin_magnetism
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(spin_magnetism)) * len([val for val in J[3:, i, j, k] if val > 0]) + spin_magnetism
          priorities[i * N * N + j * N + k][1] = -2 + 2 * spin_magnetism
  
  return(priorities)




#score: {'data3D.txt': -0.29300899999999996}
#standard deviation: 0.04766316606143574
#island_id: 0
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0]) + sum([val for val in interacting_spins if val < 0])
        
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time11:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2871610000000001}
#standard deviation: 0.04719367117527517
#island_id: 3
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin - neighbor_spin_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] += 4 - 2 * total_spin + neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.15257180000000015}
#standard deviation: 0.04485247155687187
#island_id: 3
#version_generated: 3
#generate time12:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin_sum = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin - neighbor_spin_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin + neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.17053659999999998}
#standard deviation: 0.05147921697578548
#island_id: 2
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 2
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.17845700000000003}
#standard deviation: 0.04682049541600346
#island_id: 2
#version_generated: 3
#generate time12:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5321806}
#standard deviation: 0.04123060202859037
#island_id: 2
#version_generated: 3
#generate time12:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[2, i, j, site_nbr]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.3124974}
#standard deviation: 0.04280644149237355
#island_id: 2
#version_generated: 3
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (h[i][j][k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        priorities[i * N * N + j * N + k][0] = -total_spin if site_spin > 0 else total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1783266000000004}
#standard deviation: 0.04654395097582499
#island_id: 3
#version_generated: 3
#generate time12:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.031358200000000266}
#standard deviation: 0.04400616744003049
#island_id: 3
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.08003580000000031}
#standard deviation: 0.048777645272809145
#island_id: 3
#version_generated: 3
#generate time12:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i][j][k] + interacting_spins[d][i, j, k]) for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) + total_spin - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.16614699999999977}
#standard deviation: 0.04542932567186089
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        priorities[i * N * N + j * N + k][0] = -total_spin if site_spin > 0 else total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        priorities[i * N * N + j * N + k][0] = -total_spin if site_spin > 0 else total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.32963339999999963}
#standard deviation: 0.04521696810313579
#island_id: 2
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': 0.003927400000000002}
#standard deviation: 0.04734232069977136
#island_id: 0
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
  
  return(priorities)




#score: {'data3D.txt': 0.003927400000000002}
#standard deviation: 0.04734232069977136
#island_id: 0
#version_generated: 3
#generate time12:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
        
  return(priorities)




#score: {'data3D.txt': 0.003927400000000002}
#standard deviation: 0.04734232069977136
#island_id: 0
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.04484260000000025}
#standard deviation: 0.0490369809963868
#island_id: 0
#version_generated: 3
#generate time12:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) + np.exp(-2*total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) - np.exp(2*total_spin)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1673638000000002}
#standard deviation: 0.04659576986766074
#island_id: 3
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if site_nbr == i:
          site_neighbors.append(J[2, i, (j + 1) % N, k])
        elif site_nbr == j:
          site_neighbors.append(J[0, (i + 1) % N, j, k])
        elif site_nbr == k:
          site_neighbors.append(J[1, i, j, (k + 1) % N])
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.09559980000000003}
#standard deviation: 0.046067659371407194
#island_id: 3
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 4
          priorities[i * N * N + j * N + k][1] -= 8 - 8 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - 4
          priorities[i * N * N + j * N + k][1] += 8 - 8 * total_spin
        
        for d in [0, 1, 2]:
          if site_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * (J[d, i, j, k] < 0)
            priorities[i * N * N + j * N + k][1] += J[d, i, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * (J[d, i, j, k] > 0)
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, k]
  
  return priorities




#score: {'data3D.txt': -0.16689660000000017}
#standard deviation: 0.04581109983879453
#island_id: 3
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= 4 - 4 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] += 4 - 4 * total_spin
        
        site_neighbors.sort()
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        priorities[i * N * N + j * N + k][0] = -total_spin if site_spin > 0 else total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
  return(priorities)




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin1_p = -total_spin if site_spin > 0 else total_spin
        spin1_m = -2 if site_spin > 0 else 2
        
        priorities[i * N * N + j * N + k][0] += spin1_p
        priorities[i * N * N + j * N + k][1] += spin1_m
  
  return(priorities)




#score: {'data3D.txt': -0.4022034000000002}
#standard deviation: 0.05311320314611048
#island_id: 2
#version_generated: 3
#generate time12:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin_value = 1 if site_spin > 0 else -1
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = -2 * (spin_value == 1)
  
  return(priorities)




#score: {'data3D.txt': -0.28222379999999997}
#standard deviation: 0.04366638562510069
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3231310000000002}
#standard deviation: 0.04421620697210469
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2302418000000001}
#standard deviation: 0.04697641506926641
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 4 - 2 * total_spin
        
        for d in range(6):
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in range(3):
          site_nbr = (i + ((j - 1) % 2 - 1)) % N
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in range(3):
          site_nbr = (i + ((j - 1) % 2 - 1)) % N
          if J[d+3, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif J[d+3, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3231310000000002}
#standard deviation: 0.04421620697210469
#island_id: 1
#version_generated: 3
#generate time12:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
        interacting_spin = J[3, i, (j+1)%N, k]
        priorities[i * N * N + j * N + k][0] += -interacting_spin
        priorities[i * N * N + j * N + k][1] -= interacting_spin
        
  return(priorities)




#score: {'data3D.txt': 0.08813900000000012}
#standard deviation: 0.05773411191834513
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
  
        priorities[i * N * N + j * N + k][0] = total_energy
        priorities[i * N * N + j * N + k][1] = np.sign(site_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.32963339999999963}
#standard deviation: 0.04521696810313579
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = min(-2, total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(2, -total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.24687460000000022}
#standard deviation: 0.04709374815025872
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          if d < 3:  # x-direction
            total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
          elif d < 6:  # y or z direction
            total_spin += J[d, i//2**(i%2+1), (j+k)//2**(i%2+1)%N if i%2 else j, k]

        priorities[i * N * N + j * N + k][0] = -total_spin if site_spin > 0 else total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.0008262000000000002}
#standard deviation: 0.04715945455112898
#island_id: 2
#version_generated: 3
#generate time12:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.2563438}
#standard deviation: 0.04769282547260123
#island_id: 0
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])

  return priorities




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.16614699999999977}
#standard deviation: 0.04542932567186089
#island_id: 2
#version_generated: 3
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3402101999999996}
#standard deviation: 0.044649618318189456
#island_id: 2
#version_generated: 3
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2
        
        # Add a new term based on the local energy
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.06300260000000034}
#standard deviation: 0.045595905443800544
#island_id: 2
#version_generated: 3
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = total_spin + spin_energy
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.05121460000000003}
#standard deviation: 0.04407686634551055
#island_id: 0
#version_generated: 3
#generate time12:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.16267420000000002}
#standard deviation: 0.04599194162415846
#island_id: 0
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': 0.16710540000000002}
#standard deviation: 0.046735772710419586
#island_id: 0
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': 0.014091}
#standard deviation: 0.047691366084439225
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k] * (h[(i+d)%N,(j+f)%N,k] - h[i,j,k]) for d,f in [(0,0),(1,0),(-1,0),(0,1),(0,-1)])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': 0.020497}
#standard deviation: 0.04909067030505899
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_sum = sum(J[d,i,j,k] * (h[(i+d)%N,(j+f)%N,k] + h[i,(j+f)%N,(k+g)%N]) for d,f,g in [(0,0,0),(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)])
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0024478}
#standard deviation: 0.045596565607071766
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * h[(i+d)%N,(j+f)%N,k] for d,f in [(0,0),(1,0),(-1,0),(0,1),(0,-1)])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': -0.0009677999999999995}
#standard deviation: 0.047425025916281796
#island_id: 1
#version_generated: 3
#generate time12:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * h[(i+d)%N,(j+f)%N,k] for d,f in [(0,0),(1,0),(-1,0),(0,1),(0,-1)])
        interacting_spins_sum = sum(J[d,i,j,k] * h[(i+d)%N,(j+f)%N,k] for d,f in [(0,0),(1,0),(-1,0),(0,1),(0,-1)] if abs(d+f) == 1)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * interacting_spins_sum
          priorities[i * N * N + j * N + k][1] = -total_spin

  return(priorities)




#score: {'data3D.txt': 0.03653820000000001}
#standard deviation: 0.04752797640085257
#island_id: 1
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, j, k] for d in [-1, 0, 1]]
        interacting_spins_y = [J[3, i, (j+d)%N, k] for d in [-1, 0, 1]]
        interacting_spins_z = [J[5, i, j, (k+d)%N] for d in [-1, 0, 1]]
        
        total_spin_x = sum(1 if val > 0 else -1 for val in interacting_spins_x)
        total_spin_y = sum(1 if val > 0 else -1 for val in interacting_spins_y)
        total_spin_z = sum(1 if val > 0 else -1 for val in interacting_spins_z)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) + total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y + 2 * total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.0165126}
#standard deviation: 0.04555800962772628
#island_id: 1
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d1 in [-1, 0, 1]:
          for d2 in [-1, 0, 1]:
            for d3 in [-1, 0, 1]:
              interacting_spins.append(J[5, (i+d1)%N, (j+d2)%N, (k+d3)%N])
        total_spin = sum(1 if val > 0 else -1 for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.151443}
#standard deviation: 0.044696932679994944
#island_id: 1
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1]:
          interacting_spins.append(J[4-d, (i+d)%N, (j+d)%N, (k+d)%N])
        total_spin = sum(1 if val > 0 else -1 for val in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0659138}
#standard deviation: 0.049150189923946375
#island_id: 2
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 1 else min(2, total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_spin) if total_spin > -1 else max(-2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0008262000000000002}
#standard deviation: 0.04715945455112898
#island_id: 2
#version_generated: 3
#generate time12:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_spin)
        else:
          priorities[i * N * N + j * N + k][0] = 0
          priorities[i * N * N + j * N + k][1] = -1
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0027674}
#standard deviation: 0.047808277287934145
#island_id: 2
#version_generated: 3
#generate time12:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_spin)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_energy = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += site_energy
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += -site_energy
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.1104546}
#standard deviation: 0.047047117008803
#island_id: 3
#version_generated: 3
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
        
  return priorities




#score: {'data3D.txt': 0.0005834}
#standard deviation: 0.04737448854014152
#island_id: 3
#version_generated: 3
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
          
        # Add neighboring sites
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
        
        # Add neighboring sites
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0])
        
        # Add neighboring sites
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[2, i, j, (k+1)%N]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[2, i, j, (k+1)%N]] if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.1104546}
#standard deviation: 0.047047117008803
#island_id: 3
#version_generated: 3
#generate time12:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.0008262000000000002}
#standard deviation: 0.04715945455112898
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.3078074}
#standard deviation: 0.04263201033542753
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (h[i][j][k] < 0)

        # Add a term that favors the site spin to align with its neighbors
        priorities[i * N * N + j * N + k][1] += h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.018363000000000008}
#standard deviation: 0.047687249773917556
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_neighbor_spin = sum(J[d, (i+1)%N if d==0 else (i-1)%N if d==1 else (j+1)%N if d==2 else (k+1)%N if d==3 else i, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_neighbor_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          spin1_p = -total_spin
          spin1_m = -2
        else:
          spin1_p = total_spin
          spin1_m = 2

        priorities[i * N * N + j * N + k][0] += spin1_p
        priorities[i * N * N + j * N + k][1] += spin1_m

  return(priorities)




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin1_p = -total_spin if site_spin > 0 else total_spin
        spin1_m = -2 if site_spin > 0 else 2
        
        priorities[i * N * N + j * N + k][0] += spin1_p
        priorities[i * N * N + j * N + k][1] += spin1_m
  
  return(priorities)




#score: {'data3D.txt': -0.3241033999999997}
#standard deviation: 0.044791547287853305
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        spin1_p = -total_spin if site_spin > 0 else total_spin
        spin1_m = -2 if site_spin > 0 else 2

        priorities[i * N * N + j * N + k][0] += spin1_p
        priorities[i * N * N + j * N + k][1] += spin1_m

  return(priorities)




#score: {'data3D.txt': 0.3426437999999996}
#standard deviation: 0.044617552169073545
#island_id: 2
#version_generated: 3
#generate time12:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          spin1_p = -total_spin
          spin1_m = 2
        else:
          spin1_p = total_spin
          spin1_m = -2
        
        priorities[i * N * N + j * N + k][0] += spin1_p
        priorities[i * N * N + j * N + k][1] += spin1_m
  
  return(priorities)




#score: {'data3D.txt': -0.06238820000000005}
#standard deviation: 0.045196183696856546
#island_id: 1
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        interacting_spins_y = [J[1, (i+e)%N, j, k] for e in range(3)]
        interacting_spins_z = [J[2, i, j, (k+f)%N] for f in range(3)]

        total_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        total_spin_y = sum(J[d, i, j, k] for d in [1, 2])
        total_spin_z = sum(J[3+d, i, j, k] for d in range(3))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z

  return(priorities)




#score: {'data3D.txt': -0.06238820000000005}
#standard deviation: 0.045196183696856546
#island_id: 1
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        interacting_spins_y = [J[1, (i+e)%N, j, k] for e in range(3)]
        interacting_spins_z = [J[2, i, j, (k+f)%N] for f in range(3)]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        total_spin_y = sum(J[d, i, j, k] for d in [1, 2])
        total_spin_z = sum(J[3+d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
  
  return(priorities)




#score: {'data3D.txt': -0.06238820000000005}
#standard deviation: 0.045196183696856546
#island_id: 1
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        interacting_spins_y = [J[1, (i+e)%N, j, k] for e in range(3)]
        interacting_spins_z = [J[2, i, j, (k+f)%N] for f in range(3)]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        total_spin_y = sum(J[d, i, j, k] for d in [1, 2])
        total_spin_z = sum(J[3+d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.06238820000000005}
#standard deviation: 0.045196183696856546
#island_id: 1
#version_generated: 3
#generate time12:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        interacting_spins_y = [J[1, (i+e)%N, j, k] for e in range(3)]
        interacting_spins_z = [J[2, i, j, (k+f)%N] for f in range(3)]
        
        total_spin_x = sum(J[d, i, j, k] for d in [0, 1])
        total_spin_y = sum(J[d, i, j, k] for d in [1, 2])
        total_spin_z = sum(J[3+d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_z
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val > 0]) - total_spin_x
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_x
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val > 0]) - total_spin_y
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_y
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val > 0]) - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_z
  
  return(priorities)




#score: {'data3D.txt': 0.08640980000000005}
#standard deviation: 0.04638528413150016
#island_id: 3
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(s)) for s in interacting_spins]) - len([s for s in site_neighbors if s < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(s)) for s in interacting_spins]) + len([s for s in site_neighbors if s > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.22793820000000034}
#standard deviation: 0.04545482131479565
#island_id: 3
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(s)) for s in interacting_spins]) - len([s for s in site_neighbors if s < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(s)) for s in interacting_spins]) + len([s for s in site_neighbors if s > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.27838060000000037}
#standard deviation: 0.04695163195928336
#island_id: 3
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + n) % N, (j + m) % N, (k + o) % N] 
                   for d in [0, 1, 2] 
                   for n, m, o in [(-1, 0, 0), (0, -1, 0), (0, 0, -1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(s)) for s in interacting_spins]) - len([s for s in interacting_spins if s < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(s)) for s in interacting_spins]) + len([s for s in interacting_spins if s > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.05908900000000026}
#standard deviation: 0.04926403433540539
#island_id: 3
#version_generated: 3
#generate time12:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([np.exp(-abs(s)) for s in interacting_spins]) - len([s for s in site_neighbors if s < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.sum([np.exp(-abs(s)) for s in interacting_spins]) + len([s for s in site_neighbors if s > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add the spin at the center of the cube
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] if h[i][j][k] > 0 else -h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2

  return priorities




#score: {'data3D.txt': -0.2349070000000003}
#standard deviation: 0.047468747097432415
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_neighbors = sum(1 for val in site_neighbors if val < 0)
        site_same_neighbors = len(site_neighbors) - site_opposite_neighbors

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - site_opposite_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_same_neighbors
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - site_opposite_neighbors
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + site_same_neighbors

  return(priorities)




#score: {'data3D.txt': 0.1653138}
#standard deviation: 0.04729244812398698
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [
          J[0, (i+1)%N, j, k],  # right
          J[1, i, (j+1)%N, k],  # down
          J[2, i, j, (k+1)%N]   # front
        ]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the opposite spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': 0.0744562}
#standard deviation: 0.04609870281862604
#island_id: 0
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        edge_neighbors = [J[3, i, j, (k + 1) % N], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) - sum([val for val in edge_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) - sum([val for val in edge_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -1.8000000000002458e-06}
#standard deviation: 0.04588348849815149
#island_id: 1
#version_generated: 3
#generate time12:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3): 
    interacting_spins[i+3] = np.roll(h, 1, axis=i)    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in [0,1,2])
        interacting_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(J[d,i,j,k]*interacting_neighbors[d] for d in [0,1,2])
        priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (sum(1 if spin < 0 else -1 for spin in [total_spin]+interacting_neighbors) + total_neighbor_spin)
        priorities[i*N*N+k][1] -= 2*total_spin
  return(priorities)




#score: {'data3D.txt': -0.011914599999999994}
#standard deviation: 0.04862547179041042
#island_id: 3
#version_generated: 3
#generate time12:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
        site_spin_neighbors = [h[(i+d)%N][j][k] for d in [0, 1, 2]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.11073899999999999}
#standard deviation: 0.0453493188372218
#island_id: 3
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
          
        # Add the magnetism of the current site
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.11853020000000013}
#standard deviation: 0.04675498826820514
#island_id: 3
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+d)%N, j, k] if d in [0, 1] else J[2, i, (j+1)%N, k] if d == 2 else J[1, i, j, (k+1)%N] for d in range(3)]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(interacting_spins)) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(interacting_spins)) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(interacting_spins)
  
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0,1,2]:
          interacting_spins.append(J[d,(i+d)%N,j,k])
        
        total_spin = sum([val for val in interacting_spins if val<0]) - sum([val for val in interacting_spins if val>0])
        
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val<0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - len([val for val in interacting_spins if val>0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1171502}
#standard deviation: 0.04870764252106644
#island_id: 2
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - np.sum([J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]])
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]])
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  site_interactions = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        site_spin = h[i][j][k]
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.22818620000000034}
#standard deviation: 0.04667205426762357
#island_id: 2
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0012394}
#standard deviation: 0.04551092536567456
#island_id: 2
#version_generated: 3
#generate time12:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  # additional improvement: normalize the priority based on site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] /= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] /= np.abs(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.006107000000000043}
#standard deviation: 0.04290561957366425
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        spin_value = 1 if site_spin > 0 else -1

        priorities[i * N * N + j * N + k][0] = total_spin
        priorities[i * N * N + j * N + k][1] = np.exp(-total_spin) if spin_value == 1 else np.exp(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))

        priority_1 = -total_spin + spin_energy
        priority_2 = -2 * (site_spin == 1)

        priorities[i * N * N + j * N + k][0] = max(priority_1, priority_2)
        priorities[i * N * N + j * N + k][1] = min(priority_1, priority_2)

  return(priorities)




#score: {'data3D.txt': 0.003877}
#standard deviation: 0.04696698618178518
#island_id: 2
#version_generated: 3
#generate time12:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        spin_value = np.sign(total_spin)
        
        priorities[i * N * N + j * N + k][0] = -total_spin if site_spin*spin_value > 0 else -2
        priorities[i * N * N + j * N + k][1] = -total_spin if site_spin*spin_value < 0 else -2

  return(priorities)




#score: {'data3D.txt': 0.09112780000000008}
#standard deviation: 0.04639027686013526
#island_id: 0
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) + np.exp(-2*total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_up_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_up_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) - np.exp(-2*total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_up_neighbors if val > 0]) - sum([val for val in site_up_neighbors if val < 0])
          
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val < 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in site_up_neighbors if val < 0]) + sum([val for val in site_up_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.12544380000000038}
#standard deviation: 0.04764560380098042
#island_id: 0
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val > 0]) + np.exp(-2*total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) + sum([val for val in site_up_neighbors if val < 0]) - np.exp(2*total_spin)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1588638000000002}
#standard deviation: 0.04476851806303175
#island_id: 0
#version_generated: 3
#generate time12:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-2*abs(sum(J[d, i, j, k] for d in range(6)))) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 4*abs(sum(J[d, i, j, k] for d in range(6)))
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-2*abs(sum(J[d, i, j, k] for d in range(6)))) * sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 4*abs(sum(J[d, i, j, k] for d in range(6)))
  
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.13644060000000002}
#standard deviation: 0.04470747131789048
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.2346234}
#standard deviation: 0.04822684037380016
#island_id: 0
#version_generated: 3
#generate time12:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.4940786}
#standard deviation: 0.048009857550715566
#island_id: 0
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        site_opposite_neighbors = sum(1 for d in [0, 1] if ((i + (d - 1) % 2 == 0) and J[d, i + d, j, k] > 0) or ((i + (d - 1) % 2 == 1) and J[2, i, j, (k + 1) % N] > 0))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_opposite_neighbors
        priorities[i * N * N + j * N + k][1] -= site_opposite_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time12:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.30027780000000015}
#standard deviation: 0.04525196732916701
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(sum(interacting_spins))) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(sum(interacting_spins))) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more logic here based on the problem requirements
        # For example, you can add more conditions to handle different cases
        
  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time12:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.013930999999999997}
#standard deviation: 0.04603898520819068
#island_id: 3
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs(J[:, i, j, k]))) - np.sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -np.sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs(J[:, i, j, k]))) - np.sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = np.sum([val for val in site_neighbors if val < 0])
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum(np.abs(J[:, (i+d)%N, j, k]))) - np.sum([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += np.sum([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-np.sum(np.abs(J[:, i, (j+1)%N, k]))) - np.sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        priorities[i * N * N + j * N + k][1] += np.sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.154277}
#standard deviation: 0.04840346465905101
#island_id: 3
#version_generated: 3
#generate time12:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = h[i][j][k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1, 2]:
          if h[(i+d)%N][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[d, (i+d)%N, j, k], J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0]) + len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val < 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0]) + len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k]] if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.1189446}
#standard deviation: 0.0466511994576774
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0]) - np.exp(2*total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0]) - np.exp(2*total_spin)
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.0339382}
#standard deviation: 0.04444075945300665
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in [-1, 0, 1]]
        total_spin = sum(J[d, (i + d) % N, j, k] for d in [-1, 0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': 0.18143139999999994}
#standard deviation: 0.044783479253403265
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the magnetism at the current site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.18143139999999994}
#standard deviation: 0.044783479253403265
#island_id: 0
#version_generated: 3
#generate time12:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the interaction with the magnetism at the site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.3000318000000001}
#standard deviation: 0.0450052466803594
#island_id: 1
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3000318000000001}
#standard deviation: 0.0450052466803594
#island_id: 1
#version_generated: 3
#generate time12:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.486099}
#standard deviation: 0.042062227223484024
#island_id: 3
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_opposite_nbr if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.4731538}
#standard deviation: 0.045975653400033366
#island_id: 3
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4732766}
#standard deviation: 0.04057077189849855
#island_id: 3
#version_generated: 2
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[0, i + d, j, k] or J[1, i - d, j, k] for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 2
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 2
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 2
#version_generated: 3
#generate time12:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2 - np.sum(np.sign(total_spin))
        else:
          priorities[i * N * N + j * N + k][1] = -2 + np.sum(np.sign(total_spin))

  return(priorities)




#score: {'data3D.txt': 0.1085174000000001}
#standard deviation: 0.04512484833481438
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif interacting_spins[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.0012902000000000005}
#standard deviation: 0.06523569440084163
#island_id: 2
#version_generated: 3
#generate time12:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin)
        else:
          priorities[i * N * N + j * N + k][1] = min(2, total_spin)

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            if site_spin > 0:
              priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
            else:
              priorities[i * N * N + j * N + k][0] -= J[d, i, j, k]
          elif interacting_spins[d, i, j, k] < 0:
            if site_spin > 0:
              priorities[i * N * N + j * N + k][0] -= -J[d, i, j, k]
            else:
              priorities[i * N * N + j * N + k][0] += J[d, i, j, k]

  return(priorities)




#score: {'data3D.txt': 0.12841060000000012}
#standard deviation: 0.04566565106992345
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2 - 4 * np.exp(-abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][1] = -2 - 4 * np.exp(-abs(total_spin))

  return(priorities)




#score: {'data3D.txt': 0.3425773999999996}
#standard deviation: 0.04446965357679322
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            if site_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif site_spin < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          elif interacting_spins[d, i, j, k] < 0:
            if site_spin > 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif site_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.018363000000000008}
#standard deviation: 0.047687249773917556
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_neighbor_spin = sum(J[d, ((i+1)%N if d==0 else (i-1)%N if d==1 else (j+1)%N if d==2 else (k+1)%N if d==3 else i), j, k] for d in range(6))
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_neighbor_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0015746000000000028}
#standard deviation: 0.04999051864943992
#island_id: 2
#version_generated: 3
#generate time12:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_neighbor_spin = sum(J[d, (i+1)%N if d==0 else (i-1)%N if d==1 else (j+1)%N if d==2 else (k+1)%N if d==3 else i, j, k] for d in range(6))
        total_neighbor_spin += J[5, i, j, k] * site_spin
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_neighbor_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = min(2, total_neighbor_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.34261739999999963}
#standard deviation: 0.04467739358154187
#island_id: 2
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            if site_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + abs(interacting_spins[d, i, j, k]))
              priorities[i * N * N + j * N + k][1] -= 2
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] += 1

          elif interacting_spins[d, i, j, k] < 0:
            if site_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(interacting_spins[d, i, j, k]))
              priorities[i * N * N + j * N + k][1] += 2
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
              priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.21057220000000001}
#standard deviation: 0.05518736872836031
#island_id: 2
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins[d, i, j, k] > 0) - total_spin
            priorities[i * N * N + j * N + k][1] += 1 if interacting_spins[d, i, j, k] > 0 else -1
          elif interacting_spins[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (interacting_spins[d, i, j, k] < 0) + total_spin
            priorities[i * N * N + j * N + k][1] += 1 if interacting_spins[d, i, j, k] < 0 else -1

  return(priorities)




#score: {'data3D.txt': 0.09525060000000002}
#standard deviation: 0.04758259639448021
#island_id: 2
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]))
            priorities[i * N * N + j * N + k][1] += 2
          elif interacting_spins[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]) - len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]))
            priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': 0.14148100000000016}
#standard deviation: 0.04641674395086326
#island_id: 2
#version_generated: 3
#generate time12:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][1] = -2

        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins[d, i, j, k] == site_spin)
            priorities[i * N * N + j * N + k][1] += interacting_spins[d, i, j, k]
          elif interacting_spins[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins[d, i, j, k] == -site_spin)
            priorities[i * N * N + j * N + k][1] -= interacting_spins[d, i, j, k]

  return(priorities)




#score: {'data3D.txt': 0.028242999999999983}
#standard deviation: 0.04811252925174481
#island_id: 2
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          spin1_p = -total_spin
          spin1_m = 2
        else:
          spin1_p = total_spin
          spin1_m = -2
        
        if np.sum(h[i:i+2,j,k]) < 0 and site_spin > 0:
          priorities[i * N * N + j * N + k][0] += spin1_p / (1 + spin1_m)
          priorities[i * N * N + j * N + k][1] = spin1_m
        elif np.sum(h[i:i+2,j,k]) > 0 and site_spin < 0:
          priorities[i * N * N + j * N + k][0] += spin1_p / (1 + spin1_m)
          priorities[i * N * N + j * N + k][1] = spin1_m
        else:
          if total_spin > 0:
            priorities[i * N * N + j * N + k][0] += -total_spin
            priorities[i * N * N + j * N + k][1] = max(-2, -total_spin)
          elif total_spin < 0:
            priorities[i * N * N + j * N + k][0] += total_spin
            priorities[i * N * N + j * N + k][1] = min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.00012300000000000033}
#standard deviation: 0.045074720531579564
#island_id: 2
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin < 0 else min(2, total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin > 0 else min(2, -total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0008262000000000002}
#standard deviation: 0.04715945455112898
#island_id: 2
#version_generated: 3
#generate time12:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          spin1_p = -total_spin
          spin1_m = max(-2, -total_spin)
        else:
          spin1_p = total_spin
          spin1_m = min(2, total_spin)
        
        priorities[i * N * N + j * N + k][0] += spin1_p
        priorities[i * N * N + j * N + k][1] += spin1_m
  
  return(priorities)




#score: {'data3D.txt': -0.43195859999999997}
#standard deviation: 0.04010711864544746
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin * np.exp(-abs(site_spin)) * 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.423015}
#standard deviation: 0.041440403171301314
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin * np.exp(-abs(neighbor_spin)) * 1
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.32071140000000004}
#standard deviation: 0.04167002123877549
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1171502}
#standard deviation: 0.04870764252106644
#island_id: 2
#version_generated: 3
#generate time12:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - np.sum([J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]])
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin - np.sum([J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]])
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)

  return(priorities)




#score: {'data3D.txt': -0.4248842}
#standard deviation: 0.04604558165948172
#island_id: 3
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.37195860000000003}
#standard deviation: 0.044627982320960914
#island_id: 3
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4289542}
#standard deviation: 0.04855353192467052
#island_id: 3
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)

        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)

  return(priorities)




#score: {'data3D.txt': -0.486099}
#standard deviation: 0.042062227223484024
#island_id: 3
#version_generated: 3
#generate time12:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3817358}
#standard deviation: 0.042076993219097775
#island_id: 1
#version_generated: 3
#generate time13:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.09884180000000001}
#standard deviation: 0.04404584853036663
#island_id: 1
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
        for d in [0, 1]:
          neighbor_spin = J[d, (i+d)%N, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          neighbor_spin = J[d, i, (j+d)%N, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          neighbor_spin = J[d, i, j, (k+d)%N]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3000318000000001}
#standard deviation: 0.0450052466803594
#island_id: 1
#version_generated: 3
#generate time13:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3000318000000001}
#standard deviation: 0.0450052466803594
#island_id: 1
#version_generated: 3
#generate time13:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighboring_spins = [J[3+d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)]]
        
        if np.prod(np.sign(neighboring_spins)) > 0:
          priorities[i * N * N + j * N + k][0] += len([val for val in neighboring_spins if val > 0])
        elif np.prod(np.sign(neighboring_spins)) < 0:
          priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.27445820000000004}
#standard deviation: 0.04437063637993037
#island_id: 1
#version_generated: 3
#generate time13:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.416751}
#standard deviation: 0.04271488685458502
#island_id: 3
#version_generated: 3
#generate time13:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
        site_neighbors[0] = J[0, i, j, k]
        site_neighbors[1] = J[1, (i+1)%N, j, k]
        site_neighbors[2] = J[2, i, (j+1)%N, k]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        site_opposite_nbr[0] = J[0, i, (j-1)%N, k]
        site_opposite_nbr[1] = J[1, (i-1)%N, j, k]
        site_opposite_nbr[2] = J[2, i, j, (k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.486099}
#standard deviation: 0.042062227223484024
#island_id: 3
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.486099}
#standard deviation: 0.042062227223484024
#island_id: 3
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2461302}
#standard deviation: 0.04548926519476876
#island_id: 3
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.486099}
#standard deviation: 0.042062227223484024
#island_id: 3
#version_generated: 3
#generate time13:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        magnetism = h[i][j][k]
        
        if magnetism > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3645034000000001}
#standard deviation: 0.04661502406349267
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          elif site_nbr == (i + 1) % N:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          elif site_nbr == (i + 1) % N:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.03300380000000001}
#standard deviation: 0.047663262430933113
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d) % N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i + d) % N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 2
#version_generated: 3
#generate time13:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14188979999999998}
#standard deviation: 0.04475028464669248
#island_id: 1
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3817358}
#standard deviation: 0.042076993219097775
#island_id: 1
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3817358}
#standard deviation: 0.042076993219097775
#island_id: 1
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[:, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.1042358}
#standard deviation: 0.04851231470832947
#island_id: 2
#version_generated: 3
#generate time13:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

        # Add more weights based on the site magnetism and neighboring spins
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        if total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= 2
        elif total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': -0.11131300000000001}
#standard deviation: 0.05497043997458998
#island_id: 2
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)
        
        if J[3, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.17053659999999998}
#standard deviation: 0.05147921697578548
#island_id: 2
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': 0.1225554}
#standard deviation: 0.05143758908463732
#island_id: 2
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (any(J[d, i, j, k] > 0 for d in range(6)))
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (any(J[d, i, j, k] < 0 for d in range(6)))

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + len([val for val in site_opposite_nbr if val < 0])
          priorities[i*N*N+j*N+k][1] = -2
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.3456698}
#standard deviation: 0.047676458425096976
#island_id: 3
#version_generated: 3
#generate time13:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val < 0])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.45029140000000006}
#standard deviation: 0.042497555765479034
#island_id: 3
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        site_opposite_nbr_sum = sum(site_opposite_nbr)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]) + len([val for val in site_opposite_nbr if val > 0]))
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]) - len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1213322}
#standard deviation: 0.044210555336480446
#island_id: 3
#version_generated: 3
#generate time13:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        for val in site_neighbors:
          if val < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          else:
            priorities[i*N*N+j*N+k][1] -= 1
        
        for val in site_opposite_nbr:
          if val > 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * 1
          else:
            priorities[i*N*N+j*N+k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.14188979999999998}
#standard deviation: 0.04475028464669248
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.27445820000000004}
#standard deviation: 0.04437063637993037
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0103286}
#standard deviation: 0.04682584737129698
#island_id: 1
#version_generated: 3
#generate time13:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                 for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[::, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
    
    return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(np.mean(interacting_spins)))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(np.mean(interacting_spins)))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0017834000000000003}
#standard deviation: 0.04701928034795939
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        for d in [0, 1]:
          neighbor_spin = J[1 - d, (i + d) % N, j, k]
          total_spin += neighbor_spin
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * len([val for val in interacting_spins if val > 0])
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * len([val for val in interacting_spins if val < 0])
        
        return priorities




#score: {'data3D.txt': -0.439653}
#standard deviation: 0.04180757480409501
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        
        interacting_spins = [J[d, (i + d - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(interacting_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        z_direction_spin = J[2, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if z_direction_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if z_direction_spin > 0 else -1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        # Calculate priority for -1 spin
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins))) * (site_spin < 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 if site_spin < 0 else -1
        
        # Calculate priority for 1 spin
        elif site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(np.exp(-np.abs(interacting_spins))) * (site_spin > 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 1
        
  return priorities




#score: {'data3D.txt': 0.1335042}
#standard deviation: 0.05458894450674056
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (h[i][j][k] < 0)

        if J[3, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (h[i][j][k] < 0)

        if J[4, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (h[i][j][k] < 0)

  return(priorities)




#score: {'data3D.txt': 0.08914980000000003}
#standard deviation: 0.04646402651471352
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.27752659999999996}
#standard deviation: 0.04336457185814245
#island_id: 2
#version_generated: 3
#generate time13:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.0009814000000000001}
#standard deviation: 0.05737427310249778
#island_id: 2
#version_generated: 3
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] -= (2 - 4 * total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][1] = -(2 - 4 * total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0022134}
#standard deviation: 0.046451576727168264
#island_id: 2
#version_generated: 3
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] -= 2 - 4 * total_spin
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][1] = -2 - 4 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11885860000000004}
#standard deviation: 0.04446081832400298
#island_id: 2
#version_generated: 3
#generate time13:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2 - total_spin
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1210685999999998}
#standard deviation: 0.04693141180531436
#island_id: 0
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_neighbors = sum(1 for val in site_neighbors if val < 0)
        site_same_neighbors = len(site_neighbors) - site_opposite_neighbors

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - site_opposite_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_same_neighbors
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - site_opposite_neighbors
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + site_same_neighbors

        site_neighbors = [J[3, i, j, (k + 1) % N], J[4, (i + 1) % N, j, k], J[5, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.2349070000000003}
#standard deviation: 0.047468747097432415
#island_id: 0
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_neighbors = sum(1 for val in site_neighbors if val < 0)
        site_same_neighbors = len(site_neighbors) - site_opposite_neighbors

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - site_opposite_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_same_neighbors
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - site_opposite_neighbors
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + site_same_neighbors

  return(priorities)




#score: {'data3D.txt': 0.0309594}
#standard deviation: 0.04682866292816826
#island_id: 0
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):  
    interacting_spins[i] = np.roll(h, -1, axis=i)   
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_opposite_neighbors = 0
        for l in range(6):
          if interacting_spins[l][i][j][k] < 0:
            total_spin += -1 * J[l, i, j, k]
          else:
            total_spin += 1 * J[l, i, j, k]
          if interacting_spins[l][i][j][k] == 1:
            site_opposite_neighbors += 1
          elif interacting_spins[l][i][j][k] == -1:
            site_opposite_neighbors -= 1
        priorities[i*N*N + j*N + k][0] = total_spin
        priorities[i*N*N + j*N + k][1] = site_opposite_neighbors
  
  return(priorities)




#score: {'data3D.txt': -0.3322257999999997}
#standard deviation: 0.04445133085026813
#island_id: 0
#version_generated: 3
#generate time13:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_neighbors = sum(1 for val in site_neighbors if val < 0)
        site_same_neighbors = len(site_neighbors) - site_opposite_neighbors
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - site_opposite_neighbors + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - site_same_neighbors
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - site_opposite_neighbors - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin + site_same_neighbors
        
        # Add a new term based on the number of nearest neighbors with the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] += len(site_neighbors) - 2
        
  return(priorities)




#score: {'data3D.txt': -0.0012394}
#standard deviation: 0.04551092536567456
#island_id: 2
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  # additional improvement: normalize the priority based on site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] /= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] /= np.abs(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.0006285999999999997}
#standard deviation: 0.0448564182925922
#island_id: 2
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  # additional improvement: normalize the priority based on site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] /= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] /= np.abs(h[i][j][k])
  
  # additional improvement: consider the interactions with all nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            total_spin += 1
          elif interacting_spins[d, i, j, k] < 0:
            total_spin -= 1
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0012394}
#standard deviation: 0.04551092536567456
#island_id: 2
#version_generated: 3
#generate time13:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  # additional improvement: normalize the priority based on site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] /= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] /= np.abs(h[i][j][k])
  
  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more logic here based on the problem requirements
        # For example, you can add more conditions to handle different cases
    
  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more logic here based on the problem requirements
        # For example, you can add more conditions to handle different cases
        
  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more logic here based on the problem requirements
        # For example, you can add more conditions to handle different cases
        
  return(priorities)




#score: {'data3D.txt': -0.07895939999999999}
#standard deviation: 0.04609217191280966
#island_id: 0
#version_generated: 3
#generate time13:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_up_neighbors = [J[3, (i - 1) % N, (j - 1) % N, k], J[4, (i - 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_up_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - sum([val for val in site_neighbors if val > 0]) + sum([val for val in site_up_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        # Add more logic here based on the problem requirements
        # For example, you can add more conditions to handle different cases
        
  return(priorities)




#score: {'data3D.txt': -0.3042646}
#standard deviation: 0.053583530555946016
#island_id: 2
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if i + d == 0:
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2974466}
#standard deviation: 0.04586863970557662
#island_id: 2
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) + 8 * ((i % 2 == 0 and total_neighbor_spin > 0) or (j % 2 == 0 and total_neighbor_spin < 0))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) - 8 * ((i % 2 == 0 and total_neighbor_spin < 0) or (j % 2 == 0 and total_neighbor_spin > 0))

  return(priorities)




#score: {'data3D.txt': -0.17053659999999998}
#standard deviation: 0.05147921697578548
#island_id: 2
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': -0.09436139999999997}
#standard deviation: 0.04873027385558181
#island_id: 2
#version_generated: 3
#generate time13:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - 2 * (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + 2 * (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': 0.1969482}
#standard deviation: 0.04467249978185685
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2 * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) + 2 * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.025261000000000006}
#standard deviation: 0.05351878547762459
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': 0.2998898000000001}
#standard deviation: 0.047288795881899985
#island_id: 2
#version_generated: 3
#generate time13:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
         J[0, i, (j + 1) % N, k],
         J[1, (i + 1) % N, j, k],
         J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin + np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 4 + 4 * total_spin - 6 * (total_neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin - np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] = -4 - 4 * total_spin + 6 * (total_neighbor_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.3645034000000001}
#standard deviation: 0.04661502406349267
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          elif site_nbr == (i + 1) % N:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          elif site_nbr == (i + 1) % N:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.0006285999999999997}
#standard deviation: 0.0448564182925922
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  # additional improvement: normalize the priority based on site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] /= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] /= np.abs(h[i][j][k])
  
  # additional improvement: consider the interactions with all nearest neighbors
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if interacting_spins[d, i, j, k] > 0:
            total_spin += 1
          elif interacting_spins[d, i, j, k] < 0:
            total_spin -= 1
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, -total_spin) if total_spin < 0 else min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin) if total_spin > 0 else min(2, total_spin)
  
  return priorities




#score: {'data3D.txt': -0.3189345999999996}
#standard deviation: 0.04482692854568557
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = min(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.22038980000000002}
#standard deviation: 0.0445766613370719
#island_id: 2
#version_generated: 3
#generate time13:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = min(2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(-2, total_spin)
  
  # additional improvement: consider the interactions with all nearest neighbors and normalize based on site's magnetism
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][0] /= np.abs(h[i][j][k])
        priorities[i * N * N + j * N + k][1] /= np.abs(h[i][j][k])
  
  # additional improvement: use the sign of site's magnetism to set priority
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = -2
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][1] = 2
  
  return(priorities)




#score: {'data3D.txt': -0.27445820000000004}
#standard deviation: 0.04437063637993037
#island_id: 1
#version_generated: 3
#generate time13:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.27445820000000004}
#standard deviation: 0.04437063637993037
#island_id: 1
#version_generated: 3
#generate time13:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, (i+d)%N, (j+e)%N, (k+f)%N] for d,e,f in [(0,0,0), (-1,-1,0), (0,-1,0)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.07592260000000003}
#standard deviation: 0.04726567178449916
#island_id: 2
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        interacting_spins = []
        
        # Compute interactions along each axis
        for d in range(6):
          if d < 3:
            interacting_spin = np.roll(h, -1, axis=d // 3)[i][j][k]
          else:
            interacting_spin = np.roll(h, 1, axis=(d - 3) // 3)[i][j][k]
          
          total_spin += J[d, i, j, k] * interacting_spin
          interacting_spins.append(interacting_spin)
        
        # Compute priority based on interactions and site's magnetism
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (np.sum(interacting_spins) > 0) - 6 * site_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (np.sum(interacting_spins) > 0) + 6 * site_spin
  
  return priorities




#score: {'data3D.txt': 0.0728742}
#standard deviation: 0.057771722272752096
#island_id: 2
#version_generated: 3
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  total_spin_sum = np.sum(J, axis=(0, 1, 2, 3))
  site_neighbors_sum = [np.sum(J[:, i, j, :], axis=0) for i in range(N) for j in range(N)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, :]))) * len([val for val in interacting_spins[0][i][j].flatten() if val < 0]) - abs(site_neighbors_sum[i][j])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum(J[:, i, j, :]) - 4 * (site_neighbors_sum[i][j] > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(np.sum(J[:, i, j, :]))) * len([val for val in interacting_spins[0][i][j].flatten() if val > 0]) - abs(site_neighbors_sum[i][j])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum(J[:, i, j, :]) + 4 * (site_neighbors_sum[i][j] > 0) + 6 * (h[i][j][k] < 0)

  return priorities




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 2
#generate time13:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.5420358}
#standard deviation: 0.04009336451783512
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3002426}
#standard deviation: 0.042375632446489814
#island_id: 1
#version_generated: 2
#generate time13:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.4481218}
#standard deviation: 0.04221486757956254
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.29589180000000004}
#standard deviation: 0.04434131000275024
#island_id: 2
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        neighbor_spins = [
          J[3, (i + 1) % N, j, k],
          J[4, i, (j + 1) % N, k],
          J[5, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': 0.1782998}
#standard deviation: 0.04524172764119425
#island_id: 2
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2 * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) + 2 * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  # Add the magnetism as a priority
  for i in range(N):
    for j in range(N):
      for k in range(N):
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': 0.14231580000000013}
#standard deviation: 0.04501350453319537
#island_id: 2
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[3, i, (j + 1) % N, k],
          J[4, (i + 1) % N, j, k],
          J[5, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) - abs(total_neighbor_spin) - 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) - abs(total_neighbor_spin) + 2
          priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.0023726}
#standard deviation: 0.047011123888288396
#island_id: 2
#version_generated: 3
#generate time13:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2 * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) + 2 * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.0023726}
#standard deviation: 0.047011123888288396
#island_id: 2
#version_generated: 3
#generate time13:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2 * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) + 2 * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.0023726}
#standard deviation: 0.047011123888288396
#island_id: 2
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2 * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) + 2 * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  return(priorities)




#score: {'data3D.txt': -0.0023726}
#standard deviation: 0.047011123888288396
#island_id: 2
#version_generated: 3
#generate time13:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spins = [
          J[0, i, (j + 1) % N, k],
          J[1, (i + 1) % N, j, k],
          J[2, i, j, (k + 1) % N]
        ]
        total_neighbor_spin = sum(neighbor_spin for neighbor_spin in neighbor_spins)
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val < 0]) - abs(total_neighbor_spin) - 2 * (total_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (site_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_spins if val > 0]) - abs(total_neighbor_spin) + 2 * (total_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin > 0) + 6 * (site_spin < 0)

  return(priorities)




#score: {'data3D.txt': 0.17790300000000006}
#standard deviation: 0.04839893212664926
#island_id: 2
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priority_1 = -total_spin + spin_energy
        priority_2 = -2 * (site_spin == 1)
        
        priorities[i * N * N + j * N + k][0] = max(priority_1, priority_2)
        priorities[i * N * N + j * N + k][1] = min(priority_1, priority_2) if site_spin == 1 else -min(priority_1, priority_2)
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        priority_1 = -total_spin + np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        priority_2 = -2 * (site_spin == 1)

        priorities[i * N * N + j * N + k][0] = max(priority_1, priority_2)
        priorities[i * N * N + j * N + k][1] = min(priority_1, priority_2)

  return(priorities)




#score: {'data3D.txt': -0.3189345999999996}
#standard deviation: 0.04482692854568557
#island_id: 2
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = min(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(2, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time13:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        priority_1 = -total_spin if site_spin > 0 else total_spin
        priority_2 = -2 * (site_spin == 1)
        
        priorities[i * N * N + j * N + k][0] = max(priority_1, priority_2)
        priorities[i * N * N + j * N + k][1] = min(priority_1, priority_2)
  
  return(priorities)




#score: {'data3D.txt': -0.5649985999999999}
#standard deviation: 0.04050641872641915
#island_id: 0
#version_generated: 3
#generate time13:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2932150000000003}
#standard deviation: 0.04629609805372369
#island_id: 3
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i*N*N+j*N+k][1] -= sum(1 for val in site_neighbors if val > 0)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_opposite_nbr if val > 0)
        priorities[i*N*N+j*N+k][1] += sum(1 for val in site_opposite_nbr if val < 0)

  return priorities




#score: {'data3D.txt': 0.20635260000000027}
#standard deviation: 0.04801333932606647
#island_id: 3
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -abs(total_spin) * sum(1 for val in interacting_spins if val < 0)
          priorities[i*N*N+j*N+k][1] = total_spin
        else:
          priorities[i*N*N+j*N+k][0] = abs(total_spin) * sum(1 for val in interacting_spins if val > 0)
          priorities[i*N*N+j*N+k][1] = -total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        for spin in site_neighbors:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][0] -= abs(spin)
          else:
            priorities[i*N*N+j*N+k][0] += abs(spin)
        
        for spin in site_opposite_nbr:
          if h[i][j][k] > 0:
            priorities[i*N*N+j*N+k][1] -= abs(spin)
          else:
            priorities[i*N*N+j*N+k][1] += abs(spin)
  
  return priorities




#score: {'data3D.txt': -0.20507820000000035}
#standard deviation: 0.046348455904808745
#island_id: 3
#version_generated: 3
#generate time14:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        for spin in site_neighbors:
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [spin] if val < 0])
          else:
            priorities[i*N*N+j*N+k][1] -= len([val for val in [spin] if val > 0])
        
        for spin in site_opposite_nbr:
          if spin < 0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [spin] if val < 0])
          else:
            priorities[i*N*N+j*N+k][1] -= len([val for val in [spin] if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.30009940000000035}
#standard deviation: 0.04705756814413597
#island_id: 2
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
        
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_energy
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][1] = 4 - 2 * total_energy
        
  return(priorities)




#score: {'data3D.txt': 0.0317842}
#standard deviation: 0.05661800235225542
#island_id: 2
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
        
        if total_energy > 0:
          priorities[i * N * N + j * N + k][0] = total_energy
          priorities[i * N * N + j * N + k][1] = -1
        else:
          priorities[i * N * N + j * N + k][0] = total_energy
          priorities[i * N * N + j * N + k][1] = 1
  
  return(priorities)




#score: {'data3D.txt': -0.1557274000000001}
#standard deviation: 0.058125592721623064
#island_id: 2
#version_generated: 3
#generate time14:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
        
        priorities[i * N * N + j * N + k][0] = total_energy
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = -1
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][1] = 1
  
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2840298000000001}
#standard deviation: 0.04764635759383922
#island_id: 0
#version_generated: 3
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[0:3, i, j, k] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0:3, i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = len([val for val in J[0:3, i, j, k] if val < 0])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time14:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5258550000000001}
#standard deviation: 0.04204373407536491
#island_id: 1
#version_generated: 3
#generate time14:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][site_nbr] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2081802}
#standard deviation: 0.054264281880072825
#island_id: 0
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1306254}
#standard deviation: 0.043640372533240365
#island_id: 0
#version_generated: 3
#generate time14:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val < 0]) + len([val for val in interacting_spins_y if val < 0]) + len([val for val in interacting_spins_z if val < 0])) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x+total_spin_y+total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val > 0]) + len([val for val in interacting_spins_y if val > 0]) + len([val for val in interacting_spins_z if val > 0])) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x+total_spin_y+total_spin_z)
        
  return(priorities)




#score: {'data3D.txt': -0.2461302}
#standard deviation: 0.04548926519476876
#island_id: 3
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.34001540000000025}
#standard deviation: 0.046366419344607585
#island_id: 3
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        # Add more logic here to improve the priority calculation.
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2461302}
#standard deviation: 0.04548926519476876
#island_id: 3
#version_generated: 3
#generate time14:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return priorities




#score: {'data3D.txt': 0.3286309999999996}
#standard deviation: 0.04453417967134905
#island_id: 2
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        priorities[i * N * N + j * N + k][0] = total_spin - site_spin
        priorities[i * N * N + j * N + k][1] = 2 if site_spin > 0 else -2

  return(priorities)




#score: {'data3D.txt': -0.06759540000000029}
#standard deviation: 0.04483566369353754
#island_id: 2
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
          
        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = total_spin + spin_energy
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        min_val = np.inf
        for s in [-1, 1]:
          total_spin = 0
          for d in range(6):
            total_spin += J[d, i, j, k] * h[i][(j+s)%N][k]
          spin_energy = np.exp(-abs(total_spin)) if s == -1 else np.exp(abs(total_spin))
          val = total_spin + spin_energy
          if val < min_val:
            min_val = val
            priorities[i * N * N + j * N + k][0] += 2 * (s == 1)
            priorities[i * N * N + j * N + k][1] += -2 * (s == 1)
        
  return(priorities)




#score: {'data3D.txt': -0.24212899999999973}
#standard deviation: 0.04513937481844425
#island_id: 2
#version_generated: 3
#generate time14:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          if J[d, i, j, k] > 0:
            total_spin -= interacting_spins[d, i, j, k]
          else:
            total_spin += interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.4915497999999999}
#standard deviation: 0.042563394600994876
#island_id: 1
#version_generated: 3
#generate time14:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time14:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.08813900000000012}
#standard deviation: 0.05773411191834513
#island_id: 2
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
        
        priorities[i * N * N + j * N + k][0] = total_energy
        priorities[i * N * N + j * N + k][1] = np.sign(site_spin)
  
  return(priorities)




#score: {'data3D.txt': 0.3822714}
#standard deviation: 0.043525676813118024
#island_id: 2
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
        
        if np.exp(-total_energy) > np.exp(-total_energy):
          priorities[i * N * N + j * N + k][0] = -total_energy
          priorities[i * N * N + j * N + k][1] = 2
        else:
          priorities[i * N * N + j * N + k][0] = -total_energy
          priorities[i * N * N + j * N + k][1] = -2
  
  return(priorities)




#score: {'data3D.txt': -0.42910340000000013}
#standard deviation: 0.04712386983727037
#island_id: 2
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_energy = 0
        for d in range(6):
          spin = interacting_spins[d, i, j, k] * 2 * site_spin - 1
          total_energy += J[d, i, j, k] * spin
        
        energy_ratio = np.exp(-total_energy) if site_spin > 0 else np.exp(total_energy)
        
        priorities[i * N * N + j * N + k][0] = total_energy
        priorities[i * N * N + j * N + k][1] = -np.log(energy_ratio)
  
  return(priorities)




#score: {'data3D.txt': -0.24212899999999973}
#standard deviation: 0.04513937481844425
#island_id: 2
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          if J[d, i, j, k] > 0:
            total_spin -= interacting_spins[d, i, j, k]
          else:
            total_spin += interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.24212899999999973}
#standard deviation: 0.04513937481844425
#island_id: 2
#version_generated: 3
#generate time14:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          if J[d, i, j, k] > 0:
            total_spin -= interacting_spins[d, i, j, k]
          else:
            total_spin += interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.24212899999999973}
#standard deviation: 0.04513937481844425
#island_id: 2
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          if J[d, i, j, k] > 0:
            total_spin -= interacting_spins[d, i, j, k]
          else:
            total_spin += interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.24212899999999973}
#standard deviation: 0.04513937481844425
#island_id: 2
#version_generated: 3
#generate time14:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          if J[d, i, j, k] > 0:
            total_spin -= interacting_spins[d, i, j, k]
          else:
            total_spin += interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = -total_spin
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  return(priorities)




#score: {'data3D.txt': -0.3397841999999996}
#standard deviation: 0.04504520163524634
#island_id: 2
#version_generated: 3
#generate time14:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = sum(J[d, i, j, k] * (h[(i+d)%N][j][k] if d < 3 else h[i][(j+d)%N][k] if d < 6 else h[i][j][(k+d)%N]) for d in range(6))

        if site_spin > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = min(-2, -total_spin)
        elif site_spin < 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = max(2, total_spin)

  return(priorities)




#score: {'data3D.txt': 0.157921}
#standard deviation: 0.05012470806897533
#island_id: 2
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + (total_neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin < 0) + 6 * (h[i][j][k] < 0)

        if J[3, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + (total_neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin < 0) + 6 * (h[i][j][k] < 0)

        if J[4, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + (total_neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 4 * (total_neighbor_spin > 0) - 6 * (h[i][j][k] > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - abs(total_neighbor_spin) + (total_neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 4 * (total_neighbor_spin < 0) + 6 * (h[i][j][k] < 0)

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time14:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5530166}
#standard deviation: 0.04004969019156079
#island_id: 0
#version_generated: 3
#generate time14:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.37195860000000003}
#standard deviation: 0.044627982320960914
#island_id: 3
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.30373580000000017}
#standard deviation: 0.04891176462120334
#island_id: 3
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
        # Add additional calculation based on the site's own value and its neighbors' values
        site_val = h[i][j][k]
        neighbor_vals = [h[i_ % N, j % N, k] for i_ in range(N) for j_ in range(N)]
        if site_val > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighbor_vals if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in neighbor_vals if val > 0]) - total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in neighbor_vals if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46711659999999994}
#standard deviation: 0.04488217513044571
#island_id: 3
#version_generated: 3
#generate time14:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val < 0]) + len([val for val in interacting_spins_y if val < 0]) + len([val for val in interacting_spins_z if val < 0])) - total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x+total_spin_y+total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val > 0]) + len([val for val in interacting_spins_y if val > 0]) + len([val for val in interacting_spins_z if val > 0])) - total_spin_x - total_spin_y - total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x+total_spin_y+total_spin_z)
        
  return(priorities)




#score: {'data3D.txt': -0.0176386}
#standard deviation: 0.04559418109846913
#island_id: 0
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N]]
        interacting_spins_y = [J[1, i, j, k], J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        interacting_spins_z = [J[2, i, j, k], J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val < 0]) + len([val for val in interacting_spins_y if val < 0]) + len([val for val in interacting_spins_z if val < 0])) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x+total_spin_y+total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val > 0]) + len([val for val in interacting_spins_y if val > 0]) + len([val for val in interacting_spins_z if val > 0])) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x+total_spin_y+total_spin_z)
        
  return(priorities)




#score: {'data3D.txt': -0.3465646000000003}
#standard deviation: 0.04504422789703471
#island_id: 0
#version_generated: 3
#generate time14:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        total_energy_x = np.exp(-abs(total_spin_x))
        total_energy_y = np.exp(-abs(total_spin_y))
        total_energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_energy_x * len([val for val in interacting_spins_x if val < 0]) + total_energy_y * len([val for val in interacting_spins_y if val < 0]) + total_energy_z * len([val for val in interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - total_energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - total_energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - total_energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= total_energy_x * len([val for val in interacting_spins_x if val > 0]) + total_energy_y * len([val for val in interacting_spins_y if val > 0]) + total_energy_z * len([val for val in interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - total_energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - total_energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - total_energy_z) * len([val for val in interacting_spins_z if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0027041999999999995}
#standard deviation: 0.04663299842772283
#island_id: 0
#version_generated: 3
#generate time14:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = [J[0, i, j, k] for i in range(3) for j in range(N) for k in range(N)]
  interacting_spins_y = [J[1, i, j, k] for i in range(N) for j in range(3) for k in range(N)]
  interacting_spins_z = [J[2, i, j, k] for i in range(N) for j in range(N) for k in range(3)]
  
  total_spin_x = sum([val if val < 0 else -val for val in interacting_spins_x])
  total_spin_y = sum([val if val < 0 else -val for val in interacting_spins_y])
  total_spin_z = sum([val if val < 0 else -val for val in interacting_spins_z])
  
  site_neighbors = [J[0, i, j, k] for i in range(N) for j in range(N) for k in range(6)]
  priorities = np.array([[np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in site_neighbors if val < 0]) + len([val for val in interacting_spins_x if val < 0])) - total_spin_x, 
              len([val for val in site_neighbors if val > 0]),] for _ in range(N**3)])
  
  return priorities




#score: {'data3D.txt': -0.486099}
#standard deviation: 0.042062227223484024
#island_id: 3
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.16527060000000018}
#standard deviation: 0.04587990513983219
#island_id: 3
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += -len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= -len([val for val in site_opposite_nbr if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.42051500000000025}
#standard deviation: 0.047361240006993065
#island_id: 3
#version_generated: 3
#generate time14:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        site_neighbors_sum = sum(site_neighbors)
        site_opposite_nbr_sum = sum(site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + (site_neighbors_sum / len(site_neighbors))
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + (site_opposite_nbr_sum / len(site_opposite_nbr))
          priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.0333494}
#standard deviation: 0.04727914254340914
#island_id: 3
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_neighbors = [(i+1)%N, (j+1)%N, (k+1)%N]
        site_opposite_nbr = [(i-1)%N, (j-1)%N, (k-1)%N]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + np.sum([np.prod([J[d, s, t, k] for d in [0,1,2]]) for s,t in itertools.product(site_neighbors, site_opposite_nbr) if all([val for val in [J[0, s, t, k], J[1, i, j, t], J[2, i, s, k]]])])
          priorities[i*N*N+j*N+k][1] = -2
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.sum([np.prod([J[d, s, t, k] for d in [0,1,2]]) for s,t in itertools.product(site_neighbors, site_opposite_nbr) if all([val for val in [J[0, s, t, k], J[1, i, j, t], J[2, i, s, k]]])])
          priorities[i*N*N+j*N+k][1] = -2

  return priorities




#score: {'data3D.txt': -0.0019506}
#standard deviation: 0.046899454150768106
#island_id: 3
#version_generated: 3
#generate time14:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + 2 * len([val for val in site_opposite_nbr if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -np.exp(abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 2 * len([val for val in site_opposite_nbr if val > 0])
        
        return(priorities)




#score: {'data3D.txt': -0.33116900000000016}
#standard deviation: 0.04966418386523632
#island_id: 3
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for spin in site_neighbors + site_opposite_nbr if spin > 0) - 2 * total_spin
          priorities[i*N*N+j*N+k][1] = -3
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum(1 for spin in site_neighbors + site_opposite_nbr if spin < 0) - 2 * total_spin
          priorities[i*N*N+j*N+k][1] = 3
        
  return(priorities)




#score: {'data3D.txt': -0.3878698000000001}
#standard deviation: 0.04508640735254918
#island_id: 3
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_nbr if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.47821940000000007}
#standard deviation: 0.04319324557890968
#island_id: 3
#version_generated: 3
#generate time14:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_sum = sum(val for val in site_neighbors)
          opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_sum = sum(val for val in site_neighbors)
          opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_opposite_nbr if val < 0])
          
  return priorities




#score: {'data3D.txt': -0.2461302}
#standard deviation: 0.04548926519476876
#island_id: 3
#version_generated: 3
#generate time14:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.0725206}
#standard deviation: 0.047307397895466625
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
        
        priorities[i*N*N+j*N+k][0] += np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.506147}
#standard deviation: 0.04369664278866284
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        spin_product = np.prod([np.sign(val) for val in interacting_spins])
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) * spin_product
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)

  return(priorities)




#score: {'data3D.txt': -0.3624802}
#standard deviation: 0.043384964307464864
#island_id: 3
#version_generated: 3
#generate time14:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        site_opposite_nbr.sort()
        
        priorities[i*N*N+j*N+k][0] += -np.exp(-abs(total_spin)) * sum(val < 0 for val in site_neighbors) + np.exp(-abs(total_spin)) * sum(val > 0 for val in site_opposite_nbr)
        priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2081802}
#standard deviation: 0.054264281880072825
#island_id: 0
#version_generated: 3
#generate time14:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.5286317999999999}
#standard deviation: 0.041519094267095956
#island_id: 1
#version_generated: 3
#generate time14:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4248842}
#standard deviation: 0.04604558165948172
#island_id: 3
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)

        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)

  return(priorities)




#score: {'data3D.txt': -0.4248842}
#standard deviation: 0.04604558165948172
#island_id: 3
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4248842}
#standard deviation: 0.04604558165948172
#island_id: 3
#version_generated: 3
#generate time14:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val > 0]) - total_spin)
        
        site_opposite_nbr = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_nbr if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.42268740000000005}
#standard deviation: 0.039013256224519385
#island_id: 1
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time14:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time14:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.06759540000000029}
#standard deviation: 0.04483566369353754
#island_id: 2
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]

        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))

        priorities[i * N * N + j * N + k][0] = total_spin + spin_energy
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2

  for i in range(N):
    for j in range(N):
      for k in range(N):
        min_val = np.inf
        for s in [-1, 1]:
          total_spin = 0
          for d in range(6):
            total_spin += J[d, i, j, k] * h[i][(j+s)%N][k]
          spin_energy = np.exp(-abs(total_spin)) if s == -1 else np.exp(abs(total_spin))
          val = total_spin + spin_energy
          if val < min_val:
            min_val = val
            priorities[i * N * N + j * N + k][0] += 2 * (s == 1)
            priorities[i * N * N + j * N + k][1] += -2 * (s == 1)

  return(priorities)




#score: {'data3D.txt': -0.06019140000000027}
#standard deviation: 0.044893368397125204
#island_id: 2
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = total_spin + spin_energy
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        min_val = np.inf
        for s in [-1, 1]:
          total_spin = 0
          for d in range(6):
            total_spin += J[d, i, (j+s)%N, k]
          spin_energy = np.exp(-abs(total_spin)) if s == -1 else np.exp(abs(total_spin))
          val = total_spin + spin_energy
          if val < min_val:
            min_val = val
            priorities[i * N * N + j * N + k][0] += 2 * (s == 1)
            priorities[i * N * N + j * N + k][1] += -2 * (s == 1)
        
  return(priorities)




#score: {'data3D.txt': -0.06759540000000029}
#standard deviation: 0.04483566369353754
#island_id: 2
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = total_spin + spin_energy
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        min_val = np.inf
        for s in [-1, 1]:
          total_spin = 0
          for d in range(6):
            total_spin += J[d, i, j, k] * h[i][(j+s)%N][k]
          spin_energy = np.exp(-abs(total_spin)) if s == -1 else np.exp(abs(total_spin))
          val = total_spin + spin_energy
          if val < min_val:
            min_val = val
            priorities[i * N * N + j * N + k][0] += 2 * (s == 1)
            priorities[i * N * N + j * N + k][1] += -2 * (s == 1)
        
  return(priorities)




#score: {'data3D.txt': -0.06759540000000029}
#standard deviation: 0.04483566369353754
#island_id: 2
#version_generated: 3
#generate time14:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = h[i][j][k]
        total_spin = 0
        for d in range(6):
          total_spin += J[d, i, j, k] * interacting_spins[d, i, j, k]
        
        spin_energy = np.exp(-abs(total_spin)) if site_spin > 0 else np.exp(abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] = total_spin + spin_energy
        priorities[i * N * N + j * N + k][1] = -2 if site_spin > 0 else 2
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        min_val = np.inf
        for s in [-1, 1]:
          total_spin = 0
          for d in range(6):
            total_spin += J[d, i, j, k] * h[i][(j+s)%N][k]
          spin_energy = np.exp(-abs(total_spin)) if s == -1 else np.exp(abs(total_spin))
          val = total_spin + spin_energy
          if val < min_val:
            min_val = val
            priorities[i * N * N + j * N + k][0] += 2 * (s == 1)
            priorities[i * N * N + j * N + k][1] += -2 * (s == 1)
        
  return(priorities)




#score: {'data3D.txt': 0.23917740000000026}
#standard deviation: 0.04695749321716394
#island_id: 3
#version_generated: 3
#generate time15:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        # Add more logic here to improve the priority calculation.
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += -np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
        
        priorities[i*N*N+j*N+k][0] += -np.exp(-abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] += len([val for val in site_opposite_nbr if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.178155}
#standard deviation: 0.04776089713353383
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(site_neighbors_sum)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
        priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.26373620000000036}
#standard deviation: 0.04712135449623661
#island_id: 3
#version_generated: 3
#generate time15:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        # Add more logic here to improve the priority calculation.
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
          
          priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += -2 + 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.3954538}
#standard deviation: 0.04076617256451727
#island_id: 1
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0]) + plane_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.4105074000000002}
#standard deviation: 0.04286490901938321
#island_id: 1
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.391697}
#standard deviation: 0.04918704047815847
#island_id: 1
#version_generated: 3
#generate time15:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 1
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N if h[i][j][k] > 0 else (i - 1) % N, 
                  (j + 1) % N if h[i][j][k] > 0 else (j - 1) % N, 
                  (k + 1) % N if h[i][j][k] > 0 else (k - 1) % N]
        
        priorities[i * N * N + j * N + k][0] = total_spin
        priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3002426}
#standard deviation: 0.042375632446489814
#island_id: 1
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3002426}
#standard deviation: 0.042375632446489814
#island_id: 1
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3002426}
#standard deviation: 0.042375632446489814
#island_id: 1
#version_generated: 3
#generate time15:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.47628139999999997}
#standard deviation: 0.040549173777525975
#island_id: 2
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] += 2 * same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 2
#generate time15:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.4958174}
#standard deviation: 0.042108595526804266
#island_id: 3
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time15:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.11596180000000032}
#standard deviation: 0.05015236884495088
#island_id: 1
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
        for d in range(6):
          interacting_spins = [J[d, i, j, k]]
          total_spin = J[d, i, j, k]
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.3430038}
#standard deviation: 0.043893518719282466
#island_id: 1
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.3430038}
#standard deviation: 0.043893518719282466
#island_id: 1
#version_generated: 3
#generate time15:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.47628139999999997}
#standard deviation: 0.040549173777525975
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] += 2 * same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47628139999999997}
#standard deviation: 0.040549173777525975
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] += 2 * same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47628139999999997}
#standard deviation: 0.040549173777525975
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] += 2 * same_spin
        
  return priorities




#score: {'data3D.txt': -0.47628139999999997}
#standard deviation: 0.040549173777525975
#island_id: 2
#version_generated: 3
#generate time15:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] += 2 * same_spin
        
  return priorities




#score: {'data3D.txt': -0.018427400000000003}
#standard deviation: 0.04514124332846848
#island_id: 0
#version_generated: 3
#generate time15:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k], J[0, i, j, (k+1)%N]]
        interacting_spins_y = [J[1, i, j, k], J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[1, i, j, (k+1)%N]]
        interacting_spins_z = [J[2, i, j, k], J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val < 0]) + len([val for val in interacting_spins_y if val < 0]) + len([val for val in interacting_spins_z if val < 0])) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (total_spin_x+total_spin_y+total_spin_z)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * (len([val for val in interacting_spins_x if val > 0]) + len([val for val in interacting_spins_y if val > 0]) + len([val for val in interacting_spins_z if val > 0])) + total_spin_x + total_spin_y + total_spin_z
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin_x+total_spin_y+total_spin_z)
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the site to its left
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * h[i-1][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i-1][j][k]
        
        # Add a new term based on the site to its right
        if i < N-1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * h[i+1][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i+1][j][k]
        
        # Add a new term based on the site above
        if j > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * h[i][j-1][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j-1][k]
        
        # Add a new term based on the site below
        if j < N-1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x+total_spin_y+total_spin_z)) * h[i][j+1][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j+1][k]
  
  return priorities




#score: {'data3D.txt': -0.48243020000000003}
#standard deviation: 0.04016253985942622
#island_id: 3
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4958174}
#standard deviation: 0.042108595526804266
#island_id: 3
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time15:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy
        priorities[i * N * N + j * N + k][0] = np.exp(-energy)
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
  
  return(priorities)




#score: {'data3D.txt': -0.4958174}
#standard deviation: 0.042108595526804266
#island_id: 3
#version_generated: 3
#generate time15:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1323374}
#standard deviation: 0.05291246092594824
#island_id: 1
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0]) - len([val for val in plane_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in plane_neighbors if val < 0]) - len([val for val in plane_neighbors if val > 0]))

  return priorities




#score: {'data3D.txt': -0.3954538}
#standard deviation: 0.04076617256451727
#island_id: 1
#version_generated: 3
#generate time15:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0]) + plane_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3203094}
#standard deviation: 0.04132666441463671
#island_id: 0
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        total_energy_x = np.exp(-abs(total_spin_x))
        total_energy_y = np.exp(-abs(total_spin_y))
        total_energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (total_energy_x * len([val for val in interacting_spins_x if val < 0])) + (total_energy_y * len([val for val in interacting_spins_y if val < 0])) + (total_energy_z * len([val for val in interacting_spins_z if val < 0]))
          priorities[i * N * N + j * N + k][1] -= (2 - total_energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - total_energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - total_energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (total_energy_x * len([val for val in interacting_spins_x if val > 0])) + (total_energy_y * len([val for val in interacting_spins_y if val > 0])) + (total_energy_z * len([val for val in interacting_spins_z if val > 0]))
          priorities[i * N * N + j * N + k][1] = -(2 - total_energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - total_energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - total_energy_z) * len([val for val in interacting_spins_z if val < 0])
  
  return priorities




#score: {'data3D.txt': -0.32487820000000034}
#standard deviation: 0.047499920892144644
#island_id: 0
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        total_energy_x = np.exp(-abs(total_spin_x))
        total_energy_y = np.exp(-abs(total_spin_y))
        total_energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (total_energy_x + total_energy_y + total_energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - total_energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - total_energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - total_energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (total_energy_x + total_energy_y + total_energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - total_energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - total_energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - total_energy_z) * len([val for val in interacting_spins_z if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.3465646000000003}
#standard deviation: 0.04504422789703471
#island_id: 0
#version_generated: 3
#generate time15:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        total_energy_x = np.exp(-abs(total_spin_x))
        total_energy_y = np.exp(-abs(total_spin_y))
        total_energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_energy_x * len([val for val in interacting_spins_x if val < 0]) + total_energy_y * len([val for val in interacting_spins_y if val < 0]) + total_energy_z * len([val for val in interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - total_energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - total_energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - total_energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= total_energy_x * len([val for val in interacting_spins_x if val > 0]) + total_energy_y * len([val for val in interacting_spins_y if val > 0]) + total_energy_z * len([val for val in interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - total_energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - total_energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - total_energy_z) * len([val for val in interacting_spins_z if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.37885179999999996}
#standard deviation: 0.048345524681815175
#island_id: 1
#version_generated: 3
#generate time15:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26373620000000036}
#standard deviation: 0.04712135449623661
#island_id: 3
#version_generated: 3
#generate time15:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
          
          priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += -2 + 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.42657540000000016}
#standard deviation: 0.046708665521935006
#island_id: 3
#version_generated: 3
#generate time15:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        opposite_neighbor_sum = sum(val for val in [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + opposite_neighbor_sum
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(sum(site_neighbors))) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0]) + opposite_neighbor_sum
        
  return(priorities)




#score: {'data3D.txt': -0.0641022}
#standard deviation: 0.04353004382216954
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        site_center_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        site_center_nbr = np.sum([val for val in interacting_spins if val > 0]) - np.sum([val for val in site_center_neighbors if val < 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr + site_center_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.10887820000000002}
#standard deviation: 0.050024023876133764
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        site_nbr = sum([val for val in [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]] if val < 0]) - sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # add interactions from the six neighboring sites
        for l in range(6):
          if l < 3:  # x-direction
            d = (l % 3)
            site_nbr += J[l, (i+d) % N, j, k]
          elif l < 6:  # y and z directions
            d = (l-3) % 3
            site_nbr += J[l, i, (j+d) % N, k]
        
  return(priorities)




#score: {'data3D.txt': -0.0997774}
#standard deviation: 0.046315737382017365
#island_id: 2
#version_generated: 3
#generate time15:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        site_center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr + site_center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2081802}
#standard deviation: 0.054264281880072825
#island_id: 0
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.310839}
#standard deviation: 0.05379942638170039
#island_id: 0
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Added logic to consider the effect of neighboring spins
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Added logic to consider the effect of diagonal spins
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.35607420000000034}
#standard deviation: 0.04540881384004651
#island_id: 0
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2
        elif h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.2283794}
#standard deviation: 0.057239162953698054
#island_id: 0
#version_generated: 3
#generate time15:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.4098282}
#standard deviation: 0.04163693222080608
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.509271}
#standard deviation: 0.04203098903190359
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(interacting_spins) + len(site_neighbors))
            priorities[i * N * N + j * N + k][1] -= len(interacting_spins) + len(site_neighbors)
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(interacting_spins) + len(site_neighbors))
            priorities[i * N * N + j * N + k][1] += len(interacting_spins) + len(site_neighbors)
  
  return(priorities)




#score: {'data3D.txt': -0.3678866}
#standard deviation: 0.04152443016394084
#island_id: 0
#version_generated: 3
#generate time15:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.17430740000000008}
#standard deviation: 0.051580247626780554
#island_id: 2
#version_generated: 3
#generate time15:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.21654980000000001}
#standard deviation: 0.041223128459155066
#island_id: 3
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spins = [J[0, i+1 if i < N-1 else i, j, k], J[0, i, j+1 if j < N-1 else j, k]]
        for d in range(2):
          if neighbor_spins[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.32407820000000004}
#standard deviation: 0.043256232900704614
#island_id: 3
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.48243020000000003}
#standard deviation: 0.04016253985942622
#island_id: 3
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3018606000000001}
#standard deviation: 0.0463134853756441
#island_id: 3
#version_generated: 3
#generate time15:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = 1 / (1 + np.exp(-energy))
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]
  
  return(priorities)




#score: {'data3D.txt': 0.03560579999999999}
#standard deviation: 0.047549621306168154
#island_id: 3
#version_generated: 3
#generate time15:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-energy) * (neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-energy) * (neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20633100000000001}
#standard deviation: 0.046894489217817484
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(sum(interacting_spins))) * sum([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = -2 + 2 * sum(interacting_spins)
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(sum(interacting_spins))) * sum([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] = 2 + 2 * sum(interacting_spins)
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(site_neighbors_sum)) * len([val for val in site_neighbors if val > 0]) + sum(interacting_spins)
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - sum(interacting_spins))
        
        priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - sum(interacting_spins))
        
  return(priorities)




#score: {'data3D.txt': -0.19163500000000017}
#standard deviation: 0.04589121239409567
#island_id: 3
#version_generated: 3
#generate time15:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47628139999999997}
#standard deviation: 0.040549173777525975
#island_id: 2
#version_generated: 3
#generate time15:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin = sum(1 for d in [0, 1, 2] if J[d, i, j, k] == h[i][j][k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin
        priorities[i * N * N + j * N + k][1] += 2 * same_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time15:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] += 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.0997774}
#standard deviation: 0.046315737382017365
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        site_center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr + site_center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.033227400000000004}
#standard deviation: 0.04589209789538935
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        
        site_spin = total_spin - np.sum([val for val in site_neighbors if val < 0])
        center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_spin + center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0726086}
#standard deviation: 0.04604648570781488
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.sum([val for val in J[[0, 1, 2], (i+1)%N, j, k] if val < 0]) - np.sum([val for val in J[[0, 1, 2], i, (j+1)%N, k] if val > 0])
        
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        site_center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_neighbors + site_center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22293059999999998}
#standard deviation: 0.04363614308849947
#island_id: 2
#version_generated: 3
#generate time15:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        site_center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])

        site_nbr = np.sum([val for val in interacting_spins if val < 0]) - np.sum([val for val in site_neighbors if val > 0])
        center_nbr = np.sum([val for val in site_center if val > 0]) - np.sum([val for val in site_center if val < 0])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_nbr + center_nbr
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.532349}
#standard deviation: 0.041072352732708164
#island_id: 2
#version_generated: 3
#generate time15:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.302179}
#standard deviation: 0.0524474769555219
#island_id: 1
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for d in range(3):
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time15:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 1
#version_generated: 3
#generate time15:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.43197259999999993}
#standard deviation: 0.041765729602629954
#island_id: 2
#version_generated: 3
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 2
#version_generated: 3
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.43197259999999993}
#standard deviation: 0.041765729602629954
#island_id: 2
#version_generated: 3
#generate time15:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.25356660000000003}
#standard deviation: 0.056793237312553334
#island_id: 0
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2283794}
#standard deviation: 0.057239162953698054
#island_id: 0
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.2632962}
#standard deviation: 0.05559010978186677
#island_id: 0
#version_generated: 3
#generate time15:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 2 * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 2 * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2-d, i, j, k-1]
          
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.32487820000000034}
#standard deviation: 0.047499920892144644
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        energy_x = np.exp(-abs(total_spin_x))
        energy_y = np.exp(-abs(total_spin_y))
        energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (energy_x + energy_y + energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (energy_x + energy_y + energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - energy_z) * len([val for val in interacting_spins_z if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.3328386000000001}
#standard deviation: 0.042604862516384207
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        total_energy_x = np.exp(-abs(total_spin_x))
        total_energy_y = np.exp(-abs(total_spin_y))
        total_energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (total_energy_x + total_energy_y + total_energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - total_energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - total_energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - total_energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (total_energy_x + total_energy_y + total_energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - total_energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - total_energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - total_energy_z) * len([val for val in interacting_spins_z if val < 0])
        
        # add the contributions from the neighboring sites
        if i > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * len([val for val in interacting_spins_x if val < 0]) - (total_spin_x)
          priorities[i * N * N + j * N + k][1] -= (2 - np.exp(-abs(total_spin_x))) * len([val for val in interacting_spins_x if val > 0])
        if j > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * len([val for val in interacting_spins_y if val < 0]) - (total_spin_y)
          priorities[i * N * N + j * N + k][1] -= (2 - np.exp(-abs(total_spin_y))) * len([val for val in interacting_spins_y if val > 0])
        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * len([val for val in interacting_spins_z if val < 0]) - (total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - np.exp(-abs(total_spin_z))) * len([val for val in interacting_spins_z if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.32487820000000034}
#standard deviation: 0.047499920892144644
#island_id: 0
#version_generated: 3
#generate time16:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        total_energy_x = np.exp(-abs(total_spin_x))
        total_energy_y = np.exp(-abs(total_spin_y))
        total_energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (total_energy_x + total_energy_y + total_energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - total_energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - total_energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - total_energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (total_energy_x + total_energy_y + total_energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - total_energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - total_energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - total_energy_z) * len([val for val in interacting_spins_z if val < 0])
        
  return priorities




#score: {'data3D.txt': 0.1570918}
#standard deviation: 0.04558747649036959
#island_id: 2
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]

        site_spin = total_spin - np.sum([val for val in site_neighbors if val < 0])
        center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])

        spin_diff = abs(site_spin) - abs(center_spin)

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_spin + center_spin
        if site_spin > 0:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        elif spin_diff < 0.5:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (total_spin - site_spin)
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]

        site_spin = total_spin - np.sum([val for val in site_neighbors if val < 0])
        center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_spin + center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_center = sum(J[d, i, j, k] for d in [3, 4, 5])

        site_spin = total_spin - np.sum([val for val in interacting_spins if val < 0]) + np.sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += site_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.033227400000000004}
#standard deviation: 0.04589209789538935
#island_id: 2
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_center = [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]]
        
        site_spin = total_spin - np.sum([val for val in site_neighbors if val < 0])
        center_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_spin + center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0118698}
#standard deviation: 0.04768140065014869
#island_id: 2
#version_generated: 3
#generate time16:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0] * 6
        total_spin = sum(J[d, i, j, k] for d in range(6))
        site_neighbors = []
        site_center = []

        for x in [-1, 0, 1]:
          for y in [-1, 0, 1]:
            for z in [-1, 0, 1]:
              if (x == 0 and y == 0) or (i + x >= N or i + x < 0) or (j + y >= N or j + y < 0) or (k + z >= N or k + z < 0):
                continue
              site_neighbors.append(J[0, i+x, j+y, k+z])
              site_center.append(J[3, i+x, j+y, k+z])

        site_spin = total_spin - sum(val for val in site_neighbors if val < 0)
        center_spin = sum(J[d, i, j, k] for d in range(6))

        priorities[i * N * N + j * N + k][0] = total_spin + h[i, j, k] + site_spin + center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.32487820000000034}
#standard deviation: 0.047499920892144644
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]

        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        energy_x = np.exp(-abs(total_spin_x))
        energy_y = np.exp(-abs(total_spin_y))
        energy_z = np.exp(-abs(total_spin_z))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (energy_x + energy_y + energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (energy_x + energy_y + energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - energy_z) * len([val for val in interacting_spins_z if val < 0])

  return priorities




#score: {'data3D.txt': -0.32487820000000034}
#standard deviation: 0.047499920892144644
#island_id: 0
#version_generated: 3
#generate time16:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        energy_x = np.exp(-abs(total_spin_x))
        energy_y = np.exp(-abs(total_spin_y))
        energy_z = np.exp(-abs(total_spin_z))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (energy_x + energy_y + energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val < 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] -= (2 - energy_x) * len([val for val in interacting_spins_x if val > 0]) + (2 - energy_y) * len([val for val in interacting_spins_y if val > 0]) + (2 - energy_z) * len([val for val in interacting_spins_z if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= (energy_x + energy_y + energy_z) * len([val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z if val > 0]) - (total_spin_x + total_spin_y + total_spin_z)
          priorities[i * N * N + j * N + k][1] = -(2 - energy_x) * len([val for val in interacting_spins_x if val < 0]) - (2 - energy_y) * len([val for val in interacting_spins_y if val < 0]) - (2 - energy_z) * len([val for val in interacting_spins_z if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.424035}
#standard deviation: 0.0401108984566539
#island_id: 1
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_sum /= 3
        plane_sum /= 3
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0]) + plane_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.44689340000000005}
#standard deviation: 0.04116139789219992
#island_id: 1
#version_generated: 3
#generate time16:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_sum_sign = np.sign(site_sum)
        plane_sum_sign = np.sign(plane_sum)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_sum_sign_p = np.sign(site_sum)
        plane_sum_sign_p = np.sign(plane_sum)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.178155}
#standard deviation: 0.04776089713353383
#island_id: 3
#version_generated: 3
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(site_neighbors_sum)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
        priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.20633100000000001}
#standard deviation: 0.046894489217817484
#island_id: 3
#version_generated: 3
#generate time16:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val > 0])
          
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(site_neighbors_sum)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
        priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.3805158}
#standard deviation: 0.04669115194937902
#island_id: 1
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(site_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(site_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(plane_sum)) * len([val for val in plane_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.424035}
#standard deviation: 0.0401108984566539
#island_id: 1
#version_generated: 3
#generate time16:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]

        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_sum /= 3
        plane_sum /= 3

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0]) + plane_sum
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.44611140000000016}
#standard deviation: 0.04438990729929496
#island_id: 3
#version_generated: 3
#generate time16:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        neighbor_sum = sum(val for val in site_neighbors)
        
        # Add more logic here to improve the priority calculation.
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.48095660000000007}
#standard deviation: 0.04186262003792883
#island_id: 0
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.377179}
#standard deviation: 0.04490929167778089
#island_id: 0
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val < 0 else -val for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 2
#generate time16:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.34280379999999966}
#standard deviation: 0.04512965439220645
#island_id: 0
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
        # Add the interaction with the next nearest neighbors
        for d in [3, 4, 5]:
          site_neighbors = [J[d, i, (j + 1) % N, k], J[d, (i + 1) % N, j, k], J[d, i, j, (k + 1) % N]]
          total_neighbor_spin = sum(val for val in site_neighbors)
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
            
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
            
  return priorities




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.0752642}
#standard deviation: 0.048078796972886084
#island_id: 2
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5159742}
#standard deviation: 0.045085709646849305
#island_id: 2
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.46191899999999997}
#standard deviation: 0.03994688422142583
#island_id: 2
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) / (3 if i == 0 else 4 if i == 1 else 5 if i == 2 else 6)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5546446}
#standard deviation: 0.04079610926105577
#island_id: 2
#version_generated: 2
#generate time16:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.25964500000000035}
#standard deviation: 0.04597901972639259
#island_id: 0
#version_generated: 3
#generate time16:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.39242420000000006}
#standard deviation: 0.04005525401692018
#island_id: 2
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) / (3 if i == 0 else 4 if i == 1 else 5 if i == 2 else 6)

  return(priorities)




#score: {'data3D.txt': -0.46191899999999997}
#standard deviation: 0.03994688422142583
#island_id: 2
#version_generated: 3
#generate time16:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) / (3 if i == 0 else 4 if i == 1 else 5 if i == 2 else 6)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46191899999999997}
#standard deviation: 0.03994688422142583
#island_id: 2
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) / (3 if i == 0 else 4 if i == 1 else 5 if i == 2 else 6)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4303522}
#standard deviation: 0.0399687607408586
#island_id: 2
#version_generated: 3
#generate time16:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) / (3 if i == 0 else 4 if i == 1 else 5 if i == 2 else 6)

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4371970000000001}
#standard deviation: 0.04238611224210118
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbor_sum = sum(site_neighbors)
        plane_neighbor_sum = sum(plane_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= abs(site_neighbor_sum)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in plane_neighbors if val < 0]) - len([val for val in plane_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= abs(plane_neighbor_sum)
        
  return(priorities)




#score: {'data3D.txt': -0.4150770000000001}
#standard deviation: 0.04332041217486279
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbor_weights = [1.0, 1.0, 1.5]
        plane_neighbor_weights = [1.0, 1.0, 1.5]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val * weight for val, weight in zip(site_neighbors, site_neighbor_weights) if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(val * weight for val, weight in zip(site_neighbors, site_neighbor_weights) if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val * weight for val, weight in zip(plane_neighbors, plane_neighbor_weights) if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(val * weight for val, weight in zip(plane_neighbors, plane_neighbor_weights) if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.46364020000000006}
#standard deviation: 0.042671730501117486
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbor_sum = sum(site_neighbors)
        plane_neighbor_sum = sum(plane_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - abs(site_neighbor_sum) / 3
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - abs(site_neighbor_sum) / 3
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in plane_neighbors if val < 0]) - abs(plane_neighbor_sum) / 3
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0]) - abs(plane_neighbor_sum) / 3
        
  return(priorities)




#score: {'data3D.txt': -0.017070999999999996}
#standard deviation: 0.046876757129733285
#island_id: 1
#version_generated: 3
#generate time16:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbor_sum = sum(site_neighbors)
        plane_neighbor_sum = sum(plane_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) / abs(site_neighbor_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) / abs(site_neighbor_sum)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in plane_neighbors if val < 0]) - len([val for val in plane_neighbors if val > 0])) / abs(plane_neighbor_sum) + total_spin
        priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) * (len([val for val in plane_neighbors if val < 0]) - len([val for val in plane_neighbors if val > 0])) / abs(plane_neighbor_sum)
        
  return(priorities)




#score: {'data3D.txt': -0.4303522}
#standard deviation: 0.0399687607408586
#island_id: 2
#version_generated: 3
#generate time16:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors) / (3 if i == 0 else 4 if i == 1 else 5 if i == 2 else 6)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors[site_neighbors.index(max(site_neighbors)) if h[site_nbr][j][k] > 0 else site_neighbors.index(min(site_neighbors))]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors[site_neighbors.index(max(site_neighbors)) if h[site_nbr][j][k] > 0 else site_neighbors.index(min(site_neighbors))]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors[site_neighbors.index(max(site_neighbors)) if h[site_nbr][j][k] > 0 else site_neighbors.index(min(site_neighbors))]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors[site_neighbors.index(max(site_neighbors)) if h[site_nbr][j][k] > 0 else site_neighbors.index(min(site_neighbors))]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time16:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors[site_neighbors.index(max(site_neighbors)) if h[site_nbr][j][k] > 0 else site_neighbors.index(min(site_neighbors))]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          site_neighbors[site_neighbors.index(max(site_neighbors)) if h[site_nbr][j][k] > 0 else site_neighbors.index(min(site_neighbors))]
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]
        
  return(priorities)




#score: {'data3D.txt': 0.4329270000000003}
#standard deviation: 0.04431805942276805
#island_id: 3
#version_generated: 3
#generate time16:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]
        
  # Calculate the priority based on the total number of -1 spins in the system
  total_minus_one_spin = np.sum(h > 0) // 2
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][1] += total_minus_one_spin / (N**3)
        else:
          priorities[i * N * N + j * N + k][0] += total_minus_one_spin / (N**3)

  return(priorities)




#score: {'data3D.txt': 0.017869}
#standard deviation: 0.049761402703300074
#island_id: 3
#version_generated: 3
#generate time16:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_opposite_nbr if val > 0]))
        priorities[i*N*N+j*N+k][1] -= 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
        # Add more conditions or rules here as needed
        
  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.024564200000000005}
#standard deviation: 0.049891780869798584
#island_id: 3
#version_generated: 3
#generate time16:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        neighbors_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in site_neighbors if val < 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-total_spin) * len([val for val in site_opposite_nbr if val < 0]) - np.exp(total_spin) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] -= 2 + 2 * total_spin - 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3903138}
#standard deviation: 0.042131662791302225
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [neighbor_spin] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in [neighbor_spin] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time16:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0752642}
#standard deviation: 0.048078796972886084
#island_id: 2
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.11362020000000003}
#standard deviation: 0.04931157137995097
#island_id: 2
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.11362020000000003}
#standard deviation: 0.04931157137995097
#island_id: 2
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0752642}
#standard deviation: 0.048078796972886084
#island_id: 2
#version_generated: 3
#generate time16:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.310963}
#standard deviation: 0.043525109431223716
#island_id: 1
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(site_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins) - (np.exp(-abs(site_sum)) - 1) * len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(site_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) + (np.exp(-abs(site_sum)) - 1) * len([val for val in site_neighbors if val < 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(plane_sum)) * len([val for val in plane_neighbors if val < 0]) - (np.exp(-abs(plane_sum)) - 1) * len([val for val in plane_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0]) - len([val for val in plane_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.25702980000000003}
#standard deviation: 0.04959250540111884
#island_id: 1
#version_generated: 3
#generate time16:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        plane_neighbors = [J[3, i, j, k], J[4, i, (j + 1) % N, k], J[5, (i + 1) % N, j, k]]
        
        site_sum = sum(site_neighbors)
        plane_sum = sum(plane_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(site_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins) - 2 * (site_sum > 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(site_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins) - 2 * (plane_sum > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(plane_sum)) * len([val for val in plane_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in plane_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.25558020000000004}
#standard deviation: 0.0531175169596622
#island_id: 0
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [3, 4, 5]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [3, 4, 5]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.48095660000000007}
#standard deviation: 0.04186262003792883
#island_id: 0
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.17865499999999992}
#standard deviation: 0.04649262366225423
#island_id: 0
#version_generated: 3
#generate time16:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * sum(1 for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.037500200000000004}
#standard deviation: 0.049608288823139224
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - 1)
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_spin + 1)
          priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.11362020000000003}
#standard deviation: 0.04931157137995097
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20321420000000018}
#standard deviation: 0.04793704119321509
#island_id: 2
#version_generated: 3
#generate time16:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for spin in site_neighbors if spin > 0)
        opposite_spin_count = len(site_neighbors) - same_spin_count
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
        priorities[i * N * N + j * N + k][1] -= 2 * (same_spin_count - opposite_spin_count)
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.0318266}
#standard deviation: 0.04581477286247308
#island_id: 0
#version_generated: 3
#generate time17:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i + (d % 2) - 1, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46302100000000007}
#standard deviation: 0.0424956101144577
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.41213419999999995}
#standard deviation: 0.04155604637546744
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1
        
  return(priorities)




#score: {'data3D.txt': -0.0032458}
#standard deviation: 0.047547944039253685
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time17:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': 0.1570662}
#standard deviation: 0.05358199975327536
#island_id: 3
#version_generated: 3
#generate time17:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        opposite_neighbor_sum = sum(val for val in [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * sum([J[d, i, j, k] for d in [0,1,2]]) + 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * sum([J[d, i, j, k] for d in [0,1,2]]) + 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4942222000000001}
#standard deviation: 0.04316765857861647
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.09367580000000032}
#standard deviation: 0.047843588226218994
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors + sum(val for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_site_neighbors + sum(val for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 2
#generate time17:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49269939999999995}
#standard deviation: 0.0410124303064327
#island_id: 2
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time17:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0387742}
#standard deviation: 0.046065460535633415
#island_id: 2
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr
        priorities[i * N * N + j * N + k][1] -= site_nbr
        
  return priorities




#score: {'data3D.txt': -0.0994754}
#standard deviation: 0.046804404438471385
#island_id: 2
#version_generated: 3
#generate time17:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0]) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1)]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1)]] if val < 0]) + total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1)]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += len([val for val in [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1)]] if val > 0]) + total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, i, j, k] for d in range(6) for i in range(N) for j in range(N) for k in range(N)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0105894}
#standard deviation: 0.046468564079816366
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors.sort()
        neighbor_spin = sum(val for val in site_neighbors[:2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time17:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': 0.0350262}
#standard deviation: 0.04916016266816049
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

        site_neighbors_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.06771300000000001}
#standard deviation: 0.04672129098173551
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] += 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))

  return(priorities)




#score: {'data3D.txt': -0.0526198}
#standard deviation: 0.050115097605013204
#island_id: 3
#version_generated: 3
#generate time17:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]

        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins if val < 0]) + np.exp(total_spin) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-total_spin) * len([val for val in interacting_spins if val > 0]) - np.exp(total_spin) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        neighbor_sum = sum(val for val in site_neighbors)

        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(total_spin)) * len([val for val in site_opposite_nbr if val > 0])
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin + 2 * (len([val for val in site_opposite_nbr if val < 0]) - len([val for val in site_neighbors if val > 0]))

        if opposite_neighbor_sum > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-opposite_neighbor_sum) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * opposite_neighbor_sum
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-opposite_neighbor_sum) * len([val for val in site_opposite_nbr if val < 0])
          priorities[i*N*N+j*N+k][1] += 2 + 2 * opposite_neighbor_sum

  return(priorities)




#score: {'data3D.txt': -0.49269939999999995}
#standard deviation: 0.0410124303064327
#island_id: 2
#version_generated: 3
#generate time17:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
        # Add a new term based on the number of nearest neighbors with opposite spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * abs(site_nbr - site_nopr)
        
  return(priorities)




#score: {'data3D.txt': -0.13419300000000015}
#standard deviation: 0.045098296098633264
#island_id: 0
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] += -2 + 2 * total_neighbor_spin
        
  return priorities




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 3
#generate time17:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4942222000000001}
#standard deviation: 0.04316765857861647
#island_id: 2
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4732294000000001}
#standard deviation: 0.03965118782129988
#island_id: 2
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([-val if val < 0 else val for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time17:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4965958}
#standard deviation: 0.03911442115588572
#island_id: 2
#version_generated: 3
#generate time17:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([-val if val < 0 else val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.021256199999999895}
#standard deviation: 0.04647877452730441
#island_id: 2
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([-val if val < 0 else val for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([-val if val < 0 else val for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.11429900000000001}
#standard deviation: 0.043662807960551504
#island_id: 1
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

  return(priorities)




#score: {'data3D.txt': -0.005696999999999999}
#standard deviation: 0.04616470850119169
#island_id: 1
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
        # Add a new term based on the interaction with the nearest neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.029354599999999998}
#standard deviation: 0.05048927548341331
#island_id: 1
#version_generated: 3
#generate time17:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19163500000000017}
#standard deviation: 0.04589121239409567
#island_id: 3
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19163500000000017}
#standard deviation: 0.04589121239409567
#island_id: 3
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.19163500000000017}
#standard deviation: 0.04589121239409567
#island_id: 3
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.19163500000000017}
#standard deviation: 0.04589121239409567
#island_id: 3
#version_generated: 3
#generate time17:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0387742}
#standard deviation: 0.046065460535633415
#island_id: 2
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr
        priorities[i * N * N + j * N + k][1] -= site_nbr

  return priorities




#score: {'data3D.txt': -0.0387742}
#standard deviation: 0.046065460535633415
#island_id: 2
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr
        priorities[i * N * N + j * N + k][1] -= site_nbr
        
  return(priorities)




#score: {'data3D.txt': -0.0387742}
#standard deviation: 0.046065460535633415
#island_id: 2
#version_generated: 3
#generate time17:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        site_nbr = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + site_nbr
        priorities[i * N * N + j * N + k][1] -= site_nbr
  
  return priorities




#score: {'data3D.txt': -0.26373620000000036}
#standard deviation: 0.04712135449623661
#island_id: 3
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0])
          
          priorities[i*N*N+j*N+k][0] += np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0])
          
          priorities[i*N*N+j*N+k][0] -= np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += -2 + 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
          
  return(priorities)




#score: {'data3D.txt': -0.23356980000000022}
#standard deviation: 0.04876695118581846
#island_id: 3
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_penalty = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          opposite_neighbor_bonus = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0])
          
          priorities[i*N*N+j*N+k][0] += neighbor_penalty
          priorities[i*N*N+j*N+k][1] -= neighbor_penalty
          
          priorities[i*N*N+j*N+k][0] += opposite_neighbor_bonus + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_bonus = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          opposite_neighbor_penalty = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
          
          priorities[i*N*N+j*N+k][0] -= neighbor_bonus
          priorities[i*N*N+j*N+k][1] += neighbor_bonus
          
          priorities[i*N*N+j*N+k][0] -= opposite_neighbor_penalty + total_spin
          priorities[i*N*N+j*N+k][1] += -2 + 2 * (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
          
  return(priorities)




#score: {'data3D.txt': 0.020674599999999772}
#standard deviation: 0.05125258154317694
#island_id: 3
#version_generated: 3
#generate time17:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_term = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          opposite_neighbor_term = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_term - opposite_neighbor_term
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_term = -np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          opposite_neighbor_term = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_term - opposite_neighbor_term
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0]) + (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.4266346}
#standard deviation: 0.03945700600451078
#island_id: 1
#version_generated: 3
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority to flip the site
        priority_up = np.exp(-abs(total_spin)) * len([val for val in J[0, i:i+2, j, k] if val < 0]) + total_spin
        
        priority_down = -np.exp(-abs(total_spin)) * len([val for val in J[0, i:i+2, j, k] if val > 0]) + total_spin
        
        priorities[i * N * N + j * N + k][0] += np.min((priority_up, priority_down))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41213419999999995}
#standard deviation: 0.04155604637546744
#island_id: 1
#version_generated: 3
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return(priorities)




#score: {'data3D.txt': -0.46800820000000004}
#standard deviation: 0.04229702084970052
#island_id: 1
#version_generated: 3
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1
        
        # Add a new term based on the total magnetism at each site
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.41213419999999995}
#standard deviation: 0.04155604637546744
#island_id: 1
#version_generated: 3
#generate time17:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return(priorities)




#score: {'data3D.txt': -0.15066380000000007}
#standard deviation: 0.047786186807068004
#island_id: 0
#version_generated: 3
#generate time17:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
        priorities[i * N * N + j * N + k][1] += -2 + 2 * total_neighbor_spin
        
        site_nbrs = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(site_nbrs))) * len([val for val in site_nbrs if val < 0]) + sum(site_nbrs)
        priorities[i * N * N + j * N + k][1] += -2 + 2 * sum(site_nbrs)
        
  return priorities




#score: {'data3D.txt': -0.1695986}
#standard deviation: 0.04665943632364197
#island_id: 0
#version_generated: 3
#generate time17:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
          priorities[i * N * N + j * N + k][1] += -2 + 2 * J[d, i, j, k]
        
  return priorities




#score: {'data3D.txt': 0.014835}
#standard deviation: 0.04826218079407519
#island_id: 1
#version_generated: 3
#generate time17:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if site_nbr > site_nopr:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
          priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        elif site_nbr < site_nopr:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
          priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
          priorities[i * N * N + j * N + k][1] = 0
        
        # Add a new term based on the interaction with the nearest neighbors
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_spin
          priorities[i * N * N + j * N + k][1] = 0
        
  return(priorities)




#score: {'data3D.txt': -0.3018606000000001}
#standard deviation: 0.0463134853756441
#island_id: 3
#version_generated: 3
#generate time17:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Add a new term based on the site's spin
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i, j, k] + sum(J[l, i, j, k] for l in [0,1,2])) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])

        # Calculate the priority based on the energy and spin value
        if total_spin > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-energy)
          priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]
        else:
          priorities[i*N*N+j*N+k][0] = 1 / (1 + np.exp(-energy))
          priorities[i*N*N+j*N+k][1] = -priorities[i*N*N+j*N+k][0]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy
        if J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = 1 / (1 + np.exp(-energy))
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
  return(priorities)




#score: {'data3D.txt': 0.1334330000000003}
#standard deviation: 0.047732756792374736
#island_id: 3
#version_generated: 3
#generate time17:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i-1)%N, j, k], J[0, i, (j-1)%N, k], J[0, i, j, (k-1)%N],
                   J[1, (i-1)%N, j, k], J[1, i, (j-1)%N, k], J[1, i, j, (k-1)%N],
                   J[2, (i-1)%N, j, k], J[2, i, (j-1)%N, k], J[2, i, j, (k-1)%N]]
        
        site_neighbors_sum = sum(val for val in interacting_spins)
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(site_neighbors_sum)) * len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins if val > 0]) + total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(abs(site_neighbors_sum)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * (len([val for val in interacting_spins if val < 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.09671220000000003}
#standard deviation: 0.04663368665632174
#island_id: 3
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = -total_spin + len([val for val in interacting_spins if val < 0])
          priorities[i*N*N+j*N+k][1] = 2 * total_spin
          
          neighbor_term = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0]) - np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][0] += neighbor_term
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = total_spin + len([val for val in interacting_spins if val > 0])
          priorities[i*N*N+j*N+k][1] = -2 * total_spin
          
          neighbor_term = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0]) - np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0])
          priorities[i*N*N+j*N+k][0] += neighbor_term
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0]) + (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.44603020000000004}
#standard deviation: 0.042689350521646505
#island_id: 3
#version_generated: 3
#generate time17:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.020674599999999772}
#standard deviation: 0.05125258154317694
#island_id: 3
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_term = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          opposite_neighbor_term = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_term - opposite_neighbor_term
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_term = -np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          opposite_neighbor_term = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_term - opposite_neighbor_term
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0]) + (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
  
  return priorities




#score: {'data3D.txt': 0.020674599999999772}
#standard deviation: 0.05125258154317694
#island_id: 3
#version_generated: 3
#generate time17:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        neighbor_sum = sum(val for val in site_neighbors)
        opposite_neighbor_sum = sum(val for val in site_opposite_nbr)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_term = np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val < 0])
          opposite_neighbor_term = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_term - opposite_neighbor_term
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + (len([val for val in site_opposite_nbr if val < 0]) - total_spin)
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
          
          neighbor_term = -np.exp(-abs(neighbor_sum)) * len([val for val in site_neighbors if val > 0])
          opposite_neighbor_term = np.exp(abs(opposite_neighbor_sum)) * len([val for val in site_opposite_nbr if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][0] += neighbor_term - opposite_neighbor_term
          priorities[i*N*N+j*N+k][1] += len([val for val in site_neighbors if val < 0]) + (len([val for val in site_opposite_nbr if val > 0]) - total_spin)
  
  return priorities




#score: {'data3D.txt': 0.1042502}
#standard deviation: 0.05067918783840167
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 * (neighbor_spin > 0)

        # Add a new term based on the number of nearest neighbors with same spin
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

  return priorities




#score: {'data3D.txt': -0.0005314000000000006}
#standard deviation: 0.04649912831484048
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Calculate the Manhattan distance to each neighbor with same spin
        manhattan_distance_same = sum(val for val in site_neighbors if val < 0)
        
        # Add a new term based on the Manhattan distance to each neighbor with same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * manhattan_distance_same
        priorities[i * N * N + j * N + k][1] -= 2 * manhattan_distance_same
        
        # Calculate the Manhattan distance to each neighbor with opposite spin
        manhattan_distance_opposite = sum(val for val in site_neighbors if val > 0)
        
        # Add a new term based on the Manhattan distance to each neighbor with opposite spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * manhattan_distance_opposite
        priorities[i * N * N + j * N + k][1] -= 2 * manhattan_distance_opposite
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the number of nearest neighbors with opposite spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * abs(site_nbr - site_nopr)

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time17:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]
        
  return(priorities)




#score: {'data3D.txt': 0.022431400000000004}
#standard deviation: 0.04805509436095199
#island_id: 3
#version_generated: 3
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        # Calculate the energy of the current state
        energy = -h[i, j, k] * (total_spin > 0) - sum(J[d, i, j, k] * ((total_spin // (2**d)) % 2) for d in [0,1,2])
        
        # Calculate the priority based on the energy and the site's spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-energy)
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]
        
  # Add a new term based on the site's spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0,1,2]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0,1,2]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.12099860000000001}
#standard deviation: 0.04460784547632849
#island_id: 3
#version_generated: 3
#generate time17:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0,1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0,1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 3
#version_generated: 3
#generate time17:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0,1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0,1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.09857020000000014}
#standard deviation: 0.04753845382382562
#island_id: 2
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors + sum(val for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (total_site_neighbors + sum(val for val in interacting_spins))
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Add interaction with neighboring sites
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * sum([-val if val < 0 else val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.20745620000000015}
#standard deviation: 0.04592945461857782
#island_id: 2
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        # Calculate the sum of all interactions
        total_interactions = sum(val for val in interacting_spins) + total_site_neighbors

        # Add a term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.2043358}
#standard deviation: 0.051938657648807215
#island_id: 2
#version_generated: 3
#generate time17:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] += -2 + 2 * total_spin

        # add more complex logic here based on your specific requirements
        # you can also include conditions and edge cases if needed
        
  return(priorities)




#score: {'data3D.txt': -0.49482500000000007}
#standard deviation: 0.044891668436359104
#island_id: 2
#version_generated: 3
#generate time17:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add interaction with neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add interaction with neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.06761779999999999}
#standard deviation: 0.05998851859447773
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.1570662}
#standard deviation: 0.05358199975327536
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        opposite_neighbor_sum = sum(val for val in [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * sum([J[d, i, j, k] for d in [0,1,2]]) + 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * sum([J[d, i, j, k] for d in [0,1,2]]) + 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.1570662}
#standard deviation: 0.05358199975327536
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        opposite_neighbor_sum = sum(val for val in [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * sum([J[d, i, j, k] for d in [0,1,2]]) + 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - np.exp(sum([J[d, i, j, k] for d in [0,1,2]])) * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * sum([J[d, i, j, k] for d in [0,1,2]]) + 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - 2 * len([val for val in site_neighbors + [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.041407400000000004}
#standard deviation: 0.05531258360662608
#island_id: 3
#version_generated: 3
#generate time17:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        opposite_neighbor_sum = sum(val for val in [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]])
        
        if h[i][j][k] > 0:
          site_neighbor_sum = sum(val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors)
          priorities[i*N*N+j*N+k][0] = np.exp(-site_neighbor_sum) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val < 0]) - np.exp(site_neighbor_sum) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * site_neighbor_sum + 2 * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val < 0]) - 2 * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val > 0])
        else:
          site_neighbor_sum = sum(val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors)
          priorities[i*N*N+j*N+k][0] = -np.exp(site_neighbor_sum) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val < 0]) - np.exp(site_neighbor_sum) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val > 0]) - opposite_neighbor_sum
          priorities[i*N*N+j*N+k][1] = 4 * site_neighbor_sum + 2 * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val < 0]) - 2 * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] + site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0032458}
#standard deviation: 0.047547944039253685
#island_id: 1
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return(priorities)




#score: {'data3D.txt': -0.0032458}
#standard deviation: 0.047547944039253685
#island_id: 1
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return(priorities)




#score: {'data3D.txt': -0.0032458}
#standard deviation: 0.047547944039253685
#island_id: 1
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return(priorities)




#score: {'data3D.txt': -0.0032458}
#standard deviation: 0.047547944039253685
#island_id: 1
#version_generated: 3
#generate time17:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return(priorities)




#score: {'data3D.txt': -0.0158622}
#standard deviation: 0.0477461522131365
#island_id: 1
#version_generated: 3
#generate time18:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                                           np.roll(interacting_spins[1], -1), 
                                           np.roll(interacting_spins[2], -1)])
        
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return priorities




#score: {'data3D.txt': 0.286661}
#standard deviation: 0.05274755424661886
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Calculate the priority to flip the site
        priority_up = np.exp(-abs(total_spin)) * (site_nbr - site_nopr) + total_spin
        priority_down = -np.exp(-abs(total_spin)) * abs(site_nbr - site_nopr) + total_spin
        
        priorities[i * N * N + j * N + k][0] += np.min((priority_up, priority_down))
        priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0003013999999999999}
#standard deviation: 0.06102572832863202
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        priority_up = np.exp(-abs(total_spin)) + total_spin
        priority_down = -np.exp(-abs(total_spin)) - total_spin
        
        priorities[i * N * N + j * N + k][0] += np.min((priority_up, priority_down))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0158622}
#standard deviation: 0.0477461522131365
#island_id: 1
#version_generated: 3
#generate time18:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                          np.roll(interacting_spins[1], -1), 
                          np.roll(interacting_spins[2], -1)])
        
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return priorities




#score: {'data3D.txt': -0.0070338}
#standard deviation: 0.04726070013827557
#island_id: 1
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+e)%N, (j+f)%N, (k+g)%N].flatten() for d,e,f,g in [(0,-1,0,0), (0,1,0,0), (0,0,-1,0), (0,0,1,0)]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                          np.roll(interacting_spins[1], -1), 
                          np.roll(interacting_spins[2], -1),
                          np.roll(interacting_spins[3], -1)])
        
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return priorities




#score: {'data3D.txt': -0.0158622}
#standard deviation: 0.0477461522131365
#island_id: 1
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                          np.roll(interacting_spins[1], -1), 
                          np.roll(interacting_spins[2], -1)])
        
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(interacting_spins))) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return priorities




#score: {'data3D.txt': -0.0158622}
#standard deviation: 0.0477461522131365
#island_id: 1
#version_generated: 3
#generate time18:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v2`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                          np.roll(interacting_spins[1], -1), 
                          np.roll(interacting_spins[2], -1)])
        
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        
        total_spin = np.sum(interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return priorities




#score: {'data3D.txt': 0.15447539999999998}
#standard deviation: 0.04899476579023519
#island_id: 3
#version_generated: 3
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_opposite_nbr = [J[0, i, (j-1)%N, k], J[1, (i-1)%N, j, k], J[2, i, j, (k-1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val < 0]) - 2 * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val < 0]) - 2 * len([val for val in interacting_spins + site_neighbors + site_opposite_nbr if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.06761779999999999}
#standard deviation: 0.05998851859447773
#island_id: 3
#version_generated: 3
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val < 0]) - 2 * len([val for val in interacting_spins[0, i, j, k:] + interacting_spins[1, i, j, k:] + interacting_spins[2, i, j, k:] if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.06761779999999999}
#standard deviation: 0.05998851859447773
#island_id: 3
#version_generated: 3
#generate time18:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] = np.exp(-total_spin) * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val < 0]) - 2 * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] = -np.exp(total_spin) * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val < 0]) - np.exp(total_spin) * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val > 0])
          priorities[i*N*N+j*N+k][1] = 4 * total_spin + 2 * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val < 0]) - 2 * len([val for val in interacting_spins[0][i, j, k:].flatten() + interacting_spins[1][i, j, k:].flatten() + interacting_spins[2][i, j, k:].flatten() if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.3320762000000002}
#standard deviation: 0.04592279514097547
#island_id: 2
#version_generated: 3
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - sum([-val if val < 0 else val for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - sum([-val if val < 0 else val for val in interacting_spins]))
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4965958}
#standard deviation: 0.03911442115588572
#island_id: 2
#version_generated: 3
#generate time18:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([-val if val < 0 else val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 3 * total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - 3 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0927274}
#standard deviation: 0.04535951288583245
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1997026000000003}
#standard deviation: 0.046611976070962714
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.1355118000000001}
#standard deviation: 0.04829481484341772
#island_id: 0
#version_generated: 3
#generate time18:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += spin_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] -= spin_energy
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
  
  return priorities




#score: {'data3D.txt': -0.5000334000000001}
#standard deviation: 0.0435225638541665
#island_id: 2
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3085701999999998}
#standard deviation: 0.045692827795617987
#island_id: 2
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_val
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_val
          
          if J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
            
          if J[2, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_val
            priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbors_val
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
            
          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': -0.4811862}
#standard deviation: 0.041049730931639494
#island_id: 2
#version_generated: 2
#generate time18:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= abs(sum(site_neighbors))
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 2
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.0012694}
#standard deviation: 0.04659856933039898
#island_id: 1
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(site_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - site_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.029354599999999998}
#standard deviation: 0.05048927548341331
#island_id: 1
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.05493340000000001}
#standard deviation: 0.04796665763256806
#island_id: 1
#version_generated: 3
#generate time18:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  site_interactions = np.zeros((N, N, N, 2))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_interactions[i, j, k, 0] += J[d, i, j, k]
          site_interactions[i, j, k, 1] -= J[d, i, j, k]
          
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) - total_spin
        priorities[i*N*N + j*N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -np.exp(-abs(total_spin)))
        priorities[i * N * N + j * N + k][1] -= (1 if neighbor_spin > 0 else 1)
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.32794900000000016}
#standard deviation: 0.045330008592542756
#island_id: 2
#version_generated: 3
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_val
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_val
          
          if J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
            
          if J[2, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_val
            priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbors_val
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
            
          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        for d in range(3):
          if J[d, i, j, k] != 0:
            if h[i][j][k] > 0 and J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif h[i][j][k] > 0 and J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif h[i][j][k] < 0 and J[d, i, j, k] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif h[i][j][k] < 0 and J[d, i, j, k] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
  return(priorities)




#score: {'data3D.txt': -0.5027354}
#standard deviation: 0.043245723335839814
#island_id: 3
#version_generated: 2
#generate time18:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin as the site
        neighbor_spin = J[0, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.08170659999999999}
#standard deviation: 0.054271366635086686
#island_id: 3
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Calculate the priority based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin and interacting spins
        priorities[i * N * N + j * N + k][0] += -total_spin
        priorities[i * N * N + j * N + k][1] += 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        if np.sum([val for val in interacting_spins if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= 1
          priorities[i * N * N + j * N + k][1] += 1
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.1179774}
#standard deviation: 0.04401422235187167
#island_id: 3
#version_generated: 2
#generate time18:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4160018}
#standard deviation: 0.04325139670299677
#island_id: 3
#version_generated: 3
#generate time18:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.4160018}
#standard deviation: 0.04325139670299677
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.4160018}
#standard deviation: 0.04325139670299677
#island_id: 3
#version_generated: 3
#generate time18:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][0] = -total_spin - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + site_neighbors.count(1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  return priorities




#score: {'data3D.txt': 0.0927274}
#standard deviation: 0.04535951288583245
#island_id: 0
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k]*interacting_spins[d] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins + site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0927274}
#standard deviation: 0.04535951288583245
#island_id: 0
#version_generated: 3
#generate time18:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1]] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in [J[d, i, j, k] for d in [0, 1]] if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.10803460000000006}
#standard deviation: 0.05048053924870456
#island_id: 2
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, i, j, k] for d in range(6) for i in range(N) for j in range(N) for k in range(N)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[sum([d == d_ for d_ in [0, 1, 2]]) + 3*(i + (j - 1) % N) + 2*(k - 1) % N] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3085701999999998}
#standard deviation: 0.045692827795617987
#island_id: 2
#version_generated: 3
#generate time18:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_val
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_val
          
          if J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
            
          if J[2, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_val
            priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbors_val
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
            
          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
  return priorities




#score: {'data3D.txt': -0.44138219999999995}
#standard deviation: 0.041501377846524565
#island_id: 3
#version_generated: 3
#generate time18:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum(1 for val in site_neighbors if val == 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum(1 for val in site_neighbors if val == 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.4266346}
#standard deviation: 0.03945700600451078
#island_id: 1
#version_generated: 3
#generate time18:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority to flip the site
        priority_up = np.exp(-abs(total_spin)) * len([val for val in J[0, i:i+2, j, k] if val < 0]) + total_spin
        priority_down = -np.exp(-abs(total_spin)) * len([val for val in J[0, i:i+2, j, k] if val > 0]) + total_spin
        
        priorities[i * N * N + j * N + k][0] += np.min((priority_up, priority_down))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time18:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return(priorities)




#score: {'data3D.txt': -0.40047699999999997}
#standard deviation: 0.04560419225246732
#island_id: 1
#version_generated: 3
#generate time18:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

  return priorities




#score: {'data3D.txt': 0.17230859999999998}
#standard deviation: 0.046935174933518675
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return priorities




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return priorities




#score: {'data3D.txt': 0.218727}
#standard deviation: 0.048018412208235293
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 * (neighbor_spin > 0)

  return priorities




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time18:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return priorities




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 2
#version_generated: 3
#generate time18:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val > 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.21976580000000004}
#standard deviation: 0.05412369379818788
#island_id: 0
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in [J[d, i, j, k] for d in [3, 4, 5]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in [J[d, i, j, k] for d in [3, 4, 5]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1355118000000001}
#standard deviation: 0.04829481484341772
#island_id: 0
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += spin_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] -= spin_energy
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])

  return priorities




#score: {'data3D.txt': -0.25558020000000004}
#standard deviation: 0.0531175169596622
#island_id: 0
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [3, 4, 5]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [3, 4, 5]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.09472580000000012}
#standard deviation: 0.047784118432382956
#island_id: 0
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_energy = np.sum([J[d, i, j, k] * h[i][j][k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] -= total_energy
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
  
  return priorities




#score: {'data3D.txt': -0.1522638000000003}
#standard deviation: 0.04583448624736619
#island_id: 0
#version_generated: 3
#generate time18:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -spin_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * spin_energy
        else:
          priorities[i * N * N + j * N + k][0] -= -spin_energy
          priorities[i * N * N + j * N + k][1] += 2 - 2 * spin_energy
  
  return priorities




#score: {'data3D.txt': -0.1355118000000001}
#standard deviation: 0.04829481484341772
#island_id: 0
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_energy = np.sum([J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6)])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_energy
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] -= total_energy
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.sum([J[d, i, j, k] for d in range(6)])
  
  return priorities




#score: {'data3D.txt': -0.3085701999999998}
#standard deviation: 0.045692827795617987
#island_id: 2
#version_generated: 3
#generate time18:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + site_neighbors_val
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_val

          if J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

          if J[2, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          site_neighbors_val = sum(val for val in site_neighbors)
          if site_nbr == i:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - site_neighbors_val
            priorities[i * N * N + j * N + k][1] += 2 - 2 * site_neighbors_val

          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          if J[2, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return priorities




#score: {'data3D.txt': -0.0470266000000003}
#standard deviation: 0.04958099930860612
#island_id: 2
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interactions = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum(site_interactions) / len([val for val in site_interactions if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in site_interactions)
        else:
          priorities[i * N * N + j * N + k][0] = np.sum(site_interactions) / len([val for val in site_interactions if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum(val for val in site_interactions)
  
  return(priorities)




#score: {'data3D.txt': -0.006005799999999999}
#standard deviation: 0.046296729110813
#island_id: 0
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] * h[i + (d % 2) - 1, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
          
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
          
          neighbor_spin = J[2, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.002285}
#standard deviation: 0.04705889602402504
#island_id: 0
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': 0.0583454}
#standard deviation: 0.048778380650037985
#island_id: 0
#version_generated: 3
#generate time18:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i + (d % 2) - 1, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 3 * total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 3 * total_spin
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val < 0]) - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': 0.15528500000000017}
#standard deviation: 0.04800505572332981
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interactions = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.mean([val for val in site_interactions if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([val for val in site_interactions if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] = np.mean([val for val in site_interactions if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * np.sum([val for val in site_interactions if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0882562}
#standard deviation: 0.04621938382929829
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interactions = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.sum([val for val in site_interactions if val < 0]) / len([val for val in site_interactions if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in site_interactions)
        else:
          priorities[i * N * N + j * N + k][0] = np.sum([val for val in site_interactions if val > 0]) / len([val for val in site_interactions if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum(val for val in site_interactions)
  
  return(priorities)




#score: {'data3D.txt': -0.0882562}
#standard deviation: 0.04621938382929829
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interactions = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.mean([val for val in site_interactions if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in site_interactions)
        else:
          priorities[i * N * N + j * N + k][0] = np.mean([val for val in site_interactions if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum(val for val in site_interactions)
  
  return(priorities)




#score: {'data3D.txt': -0.0882562}
#standard deviation: 0.04621938382929829
#island_id: 2
#version_generated: 3
#generate time18:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_interactions = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.mean([val for val in site_interactions if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(val for val in site_interactions)
        else:
          priorities[i * N * N + j * N + k][0] = np.mean([val for val in site_interactions if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 - 2 * sum(val for val in site_interactions)
  
  return(priorities)




#score: {'data3D.txt': -0.029354599999999998}
#standard deviation: 0.05048927548341331
#island_id: 1
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.029354599999999998}
#standard deviation: 0.05048927548341331
#island_id: 1
#version_generated: 3
#generate time18:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0023090000000000003}
#standard deviation: 0.047081126568934185
#island_id: 0
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.002285}
#standard deviation: 0.04705889602402504
#island_id: 0
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.032623400000000004}
#standard deviation: 0.04493298445952594
#island_id: 0
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbors_sum = np.sum(site_neighbors)
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= -site_neighbors_sum
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_sum
          priorities[i * N * N + j * N + k][1] += site_neighbors_sum
  
  return(priorities)




#score: {'data3D.txt': -0.002285}
#standard deviation: 0.04705889602402504
#island_id: 0
#version_generated: 3
#generate time18:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.029354599999999998}
#standard deviation: 0.05048927548341331
#island_id: 1
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1495538}
#standard deviation: 0.051545767484440466
#island_id: 1
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val > 0]) - total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i*N*N + j*N + k][1] -= sum(1 for val in site_neighbors if val > 0)

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i*N*N + j*N + k][1] -= 1 if neighbor_spin > 0 else 1

        # Add a new term based on the local energy
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 1

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i*N*N + j*N + k][1] -= 2 * site_neighbors[d]

  return priorities




#score: {'data3D.txt': -0.036434600000000004}
#standard deviation: 0.0487071202478652
#island_id: 1
#version_generated: 3
#generate time18:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  total_energy = np.zeros((N**3,))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_energy[i*N*N + j*N + k])) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
        total_energy[i*N*N + j*N + k] += J[0, i, j, k] * interacting_spins[0, i, j, k] + J[1, i, j, k] * interacting_spins[1, i, j, k] + J[2, i, j, k] * interacting_spins[2, i, j, k]

  return(priorities)




#score: {'data3D.txt': -0.4746218}
#standard deviation: 0.045902990368384494
#island_id: 1
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        # Calculate the priority to flip the site
        up_neighbors = J[0, max(0, i-1):min(i+3,N), j, k]
        down_neighbors = J[0, min(i+N,N):max(i+3,N), j, k]
        left_neighbors = J[1, i, max(0, j-1):min(j+3,N), k]
        right_neighbors = J[1, i, min(j+N,N):max(j+3,N), k]
        front_neighbors = J[2, i, j, max(0, k-1):min(k+3,N)]
        back_neighbors = J[2, i, j, min(k+N,N):max(k+3,N)]

        up_priority = len([val for val in up_neighbors if val < 0]) - len([val for val in up_neighbors if val > 0])
        down_priority = len([val for val in down_neighbors if val < 0]) - len([val for val in down_neighbors if val > 0])
        left_priority = len([val for val in left_neighbors if val < 0]) - len([val for val in left_neighbors if val > 0])
        right_priority = len([val for val in right_neighbors if val < 0]) - len([val for val in right_neighbors if val > 0])
        front_priority = len([val for val in front_neighbors if val < 0]) - len([val for val in front_neighbors if val > 0])
        back_priority = len([val for val in back_neighbors if val < 0]) - len([val for val in back_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (up_priority + down_priority + left_priority + right_priority + front_priority + back_priority) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4619554}
#standard deviation: 0.04301457114560135
#island_id: 1
#version_generated: 3
#generate time19:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = J[0, i:i+2, j, k]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.36663579999999996}
#standard deviation: 0.04215896818424284
#island_id: 0
#version_generated: 3
#generate time19:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4619554}
#standard deviation: 0.04301457114560135
#island_id: 1
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v2`."""
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = J[0, i:i+2, j, k]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4506918}
#standard deviation: 0.043342360950460464
#island_id: 1
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = J[0, i:i+2, j, k]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4506918}
#standard deviation: 0.043342360950460464
#island_id: 1
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = J[0, i:i+2, j, k]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.34776260000000003}
#standard deviation: 0.04167883973001168
#island_id: 1
#version_generated: 3
#generate time19:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.37618460000000004}
#standard deviation: 0.04112842864540293
#island_id: 1
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, (j+e)%N, (k+f)%N] 
                   for d in range(6) 
                   for e,f in itertools.product([-1,0,1], repeat=2)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.4282866000000001}
#standard deviation: 0.041589047361534986
#island_id: 1
#version_generated: 3
#generate time19:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 2
#generate time19:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.5270329999999999}
#standard deviation: 0.04089158826702626
#island_id: 3
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5149562}
#standard deviation: 0.039780057837564796
#island_id: 3
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([-neighbor_spin * np.exp(-abs(total_spin)) for neighbor_spin in site_neighbors]) + sum(neighbor_spin for neighbor_spin in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the site's own spin
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5207858}
#standard deviation: 0.04304195439754101
#island_id: 3
#version_generated: 2
#generate time19:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0158622}
#standard deviation: 0.0477461522131365
#island_id: 1
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i:i+1,j:j+1,k:k+1].flatten() for d in [0,1,2]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0],-1), 
                         np.roll(interacting_spins[1],-1), 
                         np.roll(interacting_spins[2],-1)])
        
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        
        total_spin = np.sum(interacting_spins)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
  return priorities




#score: {'data3D.txt': -0.1089458}
#standard deviation: 0.054755999692819045
#island_id: 1
#version_generated: 3
#generate time19:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        
        site_neighbors = np.array([np.roll(interacting_spins[0], -1), 
                      np.roll(interacting_spins[1], 1), 
                      np.roll(interacting_spins[2], -1)])
        total_neighbor_spin = np.sum(site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(np.sum(J[:, i, j, k])))*np.sum([val for val in interacting_spins if val < 0]) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2*np.sum(J[:, i, j, k])

  return priorities




#score: {'data3D.txt': -0.0158622}
#standard deviation: 0.0477461522131365
#island_id: 1
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2]]
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                         np.roll(interacting_spins[1], -1), 
                         np.roll(interacting_spins[2], -1)])
        total_spin = sum(J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2])
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
  return priorities




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time19:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i:i+1, j:j+1, k:k+1].flatten() for d in [0, 1, 2]]
        
        site_neighbors = np.concatenate([np.roll(interacting_spins[0], -1), 
                 np.roll(interacting_spins[1], -1), 
                 np.roll(interacting_spins[2], -1)])
        
        total_spin = np.sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
  return priorities




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return priorities




#score: {'data3D.txt': -0.0026958000000000004}
#standard deviation: 0.04693069083616818
#island_id: 0
#version_generated: 3
#generate time19:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
        return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.4165834}
#standard deviation: 0.0476733359902577
#island_id: 2
#version_generated: 3
#generate time19:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  return priorities




#score: {'data3D.txt': -0.0025289999999999996}
#standard deviation: 0.05671584151716343
#island_id: 3
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + \
             [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                               for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5149562}
#standard deviation: 0.039780057837564796
#island_id: 3
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.sum([-neighbor_spin * np.exp(-abs(total_spin)) for neighbor_spin in site_neighbors]) + sum(neighbor_spin for neighbor_spin in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the site's own spin
        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.499799}
#standard deviation: 0.04123010791884979
#island_id: 3
#version_generated: 3
#generate time19:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors.append(h[i, j, k])

        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors.append(h[i, (j + 1) % N, k])
        site_neighbors.append(h[(i + 1) % N, j, k])
        site_neighbors.append(h[i, j, (k + 1) % N])

        priorities[i * N * N + j * N + k][0] += np.sum([-neighbor_spin * np.exp(-abs(total_spin)) for neighbor_spin in site_neighbors]) + sum(neighbor_spin for neighbor_spin in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
  return priorities




#score: {'data3D.txt': -0.3380377999999997}
#standard deviation: 0.04511021138456346
#island_id: 0
#version_generated: 3
#generate time19:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
  return priorities




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return priorities




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1
        
  return priorities




#score: {'data3D.txt': -0.40379380000000004}
#standard deviation: 0.047690841065764406
#island_id: 1
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + site_nbr - site_nopr) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.21891660000000002}
#standard deviation: 0.05318589102797846
#island_id: 3
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_spin = sum([spin for spin in site_neighbors if spin < 0]) - sum([spin for spin in site_neighbors if spin > 0])

        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in interacting_spins]) + total_spin + np.exp(-abs(total_spin)) * site_neighbor_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time19:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_center_spin = sum(interacting_spin for interacting_spin in interacting_spins)
        
        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in interacting_spins]) + total_spin + site_center_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time19:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0318266}
#standard deviation: 0.04581477286247308
#island_id: 0
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i + (d % 2) - 1, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2001402}
#standard deviation: 0.047019968353455954
#island_id: 0
#version_generated: 3
#generate time19:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if (i + (1 - 1) % 2 == 0):
          neighbor_spin = J[1, i+1, j, k]
        else:
          neighbor_spin = J[0, i-1, j, k]

        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.5127094000000002}
#standard deviation: 0.042171118928005694
#island_id: 1
#version_generated: 3
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(1 for val in site_neighbors if val < 0)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin - len([val for val in interacting_spins if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0847498}
#standard deviation: 0.04734760986533534
#island_id: 1
#version_generated: 3
#generate time19:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = J[0, i:i+2, j, k]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= np.sum(J[0, i:i+2, j, k])

  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time19:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.0031102}
#standard deviation: 0.0468822616344391
#island_id: 0
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.002983}
#standard deviation: 0.046866857276757955
#island_id: 0
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.3064306000000004}
#standard deviation: 0.04783879412819684
#island_id: 0
#version_generated: 3
#generate time19:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1, 2]:
          if (i + (d % 2) == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[2-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.343353}
#standard deviation: 0.041248050511509024
#island_id: 0
#version_generated: 3
#generate time19:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(J[0, i, j, k]) - 1)
          priorities[i * N * N + j * N + k][1] -= np.count_nonzero(J[0, i, j, k])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(J[1, i, j, k]) - 1)
          priorities[i * N * N + j * N + k][1] -= np.count_nonzero(J[1, i, j, k])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.28815300000000016}
#standard deviation: 0.046026162027698964
#island_id: 0
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        interacting_spins = [J[d,i,j,k] for d in [3,4,5]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= len([val for val in interacting_spins + site_neighbors if val > 0])
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += len([val for val in interacting_spins + site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.1616602}
#standard deviation: 0.046838258037207155
#island_id: 0
#version_generated: 3
#generate time19:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k]*interacting_spins[d] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(val for val in interacting_spins + site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] += 2 - 2 * total_neighbor_spin
        
        site_nbr = (i + ((k-1)%2-1))%N
        for d in range(6):
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(J[d,i,j,k])) * len([val for val in [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]] if val < 0])
          priorities[i*N*N+j*N+k][1] += -2 + 2 * J[d,i,j,k]
        
  return(priorities)




#score: {'data3D.txt': -0.1695986}
#standard deviation: 0.04665943632364197
#island_id: 0
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0])
          priorities[i * N * N + j * N + k][1] += -2 + 2 * J[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': -0.18691740000000026}
#standard deviation: 0.04670948102088055
#island_id: 0
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-sum(interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - sum(site_neighbors)
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * sum(interacting_spins) - sum(site_neighbors)
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-sum(interacting_spins)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - sum(interacting_spins) - sum(site_neighbors)
          priorities[i*N*N+j*N+k][1] += 2 - 2 * sum(interacting_spins) - sum(site_neighbors)
  
  return priorities




#score: {'data3D.txt': 0.5053474}
#standard deviation: 0.046553016585823954
#island_id: 3
#version_generated: 3
#generate time19:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] - h[i, j, k] for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0025289999999999996}
#standard deviation: 0.05671584151716343
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
       [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                    for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0025289999999999996}
#standard deviation: 0.05671584151716343
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1689538}
#standard deviation: 0.05876809053865883
#island_id: 3
#version_generated: 3
#generate time19:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                    for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.3344486}
#standard deviation: 0.039722277855631594
#island_id: 2
#version_generated: 3
#generate time19:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i + (k - 1) % N) % N, ((j + 1) % N), ((i + 1) % N)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) + sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
  
  return(priorities)




#score: {'data3D.txt': -0.0023266}
#standard deviation: 0.047075887802993155
#island_id: 0
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': 0.12111180000000019}
#standard deviation: 0.04699264134691729
#island_id: 0
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum([val for val in interacting_spins if val < 0]) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in interacting_spins if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum([val for val in interacting_spins if val > 0]) - total_spin
        
        site_neighbors = [J[2, (i + d % 2 - 1) % N, j, k] for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 2 * total_spin
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0023118000000000006}
#standard deviation: 0.047072694640948695
#island_id: 0
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.015969}
#standard deviation: 0.046496693635139266
#island_id: 0
#version_generated: 3
#generate time19:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46302100000000007}
#standard deviation: 0.0424956101144577
#island_id: 1
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
            
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
            
  return priorities




#score: {'data3D.txt': -0.46234740000000013}
#standard deviation: 0.04249312689412254
#island_id: 1
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= h[i][j][k]

  return priorities




#score: {'data3D.txt': -0.0028082000000000003}
#standard deviation: 0.047014229896489845
#island_id: 1
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        return np.argsort(priorities, axis=0)




#score: {'data3D.txt': 0.4427194}
#standard deviation: 0.04392402740687607
#island_id: 1
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  site_interactions = np.zeros((N, N, N, 2))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          site_interactions[i, j, k, 0] += J[d, i, j, k]
          site_interactions[i, j, k, 1] -= J[d, i, j, k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0) - total_spin
        priorities[i*N*N + j*N + k][1] -= sum(1 for val in site_neighbors if val > 0)

        neighbor_spin = np.sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 if neighbor_spin < 0 else -np.exp(-abs(total_spin)))
        priorities[i * N * N + j * N + k][1] -= (1 if neighbor_spin > 0 else 1)

        site_interaction = sum(J[d, i, j, k] for d in [0, 1, 2])
        priorities[i*N*N + j*N + k][0] += site_interaction
        priorities[i*N*N + j*N + k][1] -= site_interaction

  return priorities




#score: {'data3D.txt': 0.0014257999999999999}
#standard deviation: 0.04126272136396241
#island_id: 1
#version_generated: 3
#generate time19:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] * site_neighbors[d] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) - total_spin
        priorities[i*N*N + j*N + k][1] -= np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.0163498}
#standard deviation: 0.04687658519943619
#island_id: 1
#version_generated: 3
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        site_neighbors = J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.06367980000000001}
#standard deviation: 0.0472144553284267
#island_id: 1
#version_generated: 3
#generate time19:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] * site_neighbors[d] for d in [0, 1, 2])
        
        interacting_spins = np.sum(J[:3, i:i+1, j:j+1, k], axis=(1, 2))
        magnetism = h[i, j, k]
        
        priorities[i*N*N + j*N + k][0] += -np.exp(-abs(total_spin)) * (interacting_spins > 0).sum() - magnetism
        priorities[i*N*N + j*N + k][1] -= -2 * np.exp(-abs(total_spin))
  
  return priorities




#score: {'data3D.txt': -0.3344486}
#standard deviation: 0.039722277855631594
#island_id: 2
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.1515942}
#standard deviation: 0.04066037390826602
#island_id: 2
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
        x_nbr = (i + ((k - 1) % 2 - 1)) % N
        y_nbr = ((j + 1) % N)
        z_nbr = ((i + 1) % N)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + sum([J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        priorities[i * N * N + j * N + k][1] -= 4 - 3 * sum([J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
  
  return priorities




#score: {'data3D.txt': -0.4187226000000001}
#standard deviation: 0.04939373775328205
#island_id: 2
#version_generated: 3
#generate time19:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2643218000000004}
#standard deviation: 0.04746529600413338
#island_id: 2
#version_generated: 3
#generate time19:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.14640340000000002}
#standard deviation: 0.05177608510152154
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
          for d in range(6)]) + np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k]
        if neighbor_spin < 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i*N*N + j*N + k][1] -= len([val for val in site_neighbors if val < 0])
        elif neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i*N*N + j*N + k][1] += len([val for val in site_neighbors if val > 0])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1689538}
#standard deviation: 0.05876809053865883
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                              for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2171942}
#standard deviation: 0.05867465897949473
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k]
                 for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k],
                  J[2, i, j, (k + 1) % N]]
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k]
                    for d in range(6)]) - site_neighbors.count(0)
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1689538}
#standard deviation: 0.05876809053865883
#island_id: 3
#version_generated: 3
#generate time19:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                    for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.40379380000000004}
#standard deviation: 0.047690841065764406
#island_id: 1
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + site_nbr - site_nopr) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.054547799999999994}
#standard deviation: 0.04600739978699079
#island_id: 1
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = sum(val for val in site_neighbors if val < 0)
        site_nopr = len([val for val in site_neighbors if val > 0])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + site_nbr - site_nopr) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbrs = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3530546}
#standard deviation: 0.04391443428805613
#island_id: 1
#version_generated: 3
#generate time19:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        neighbor_spin = sum(site_neighbors)
        spin_value = h[i][j][k] + site_nbr - site_nopr

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (spin_value + neighbor_spin) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1997026000000003}
#standard deviation: 0.046611976070962714
#island_id: 0
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.22242700000000024}
#standard deviation: 0.04578094135117801
#island_id: 0
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the same spin
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
  return priorities




#score: {'data3D.txt': -0.3233869999999998}
#standard deviation: 0.04646733595763801
#island_id: 0
#version_generated: 3
#generate time19:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5207858}
#standard deviation: 0.04304195439754101
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0023158000000000002}
#standard deviation: 0.048822330038211
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4995746}
#standard deviation: 0.04184454032296209
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors in the z-direction
        for d in [2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5207858}
#standard deviation: 0.04304195439754101
#island_id: 3
#version_generated: 3
#generate time19:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5111994}
#standard deviation: 0.04156689210946616
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the site's spin value
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.21240219999999999}
#standard deviation: 0.04587126807883122
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -1
  
  return(priorities)




#score: {'data3D.txt': -0.5207858}
#standard deviation: 0.04304195439754101
#island_id: 3
#version_generated: 3
#generate time19:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5207858}
#standard deviation: 0.04304195439754101
#island_id: 3
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0031366000000000002}
#standard deviation: 0.04783029270702825
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (sum(val > 0 for val in site_neighbors) - total_spin)
        priorities[i*N*N + j*N + k][1] -= 3 - 2 * sum(val > 0 for val in site_neighbors)

  return(priorities)




#score: {'data3D.txt': -0.0323198}
#standard deviation: 0.04901298856384908
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])

        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the interactions with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins[d, site_nbr, j, k])
            priorities[i*N*N + j*N + k][1] -= 2 * interacting_spins[d, site_nbr, j, k]

  return(priorities)




#score: {'data3D.txt': -0.029354599999999998}
#standard deviation: 0.05048927548341331
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[0:i+3, i, j, k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0261138}
#standard deviation: 0.04896306658656094
#island_id: 1
#version_generated: 3
#generate time19:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = [interacting_spins[d, (i + ((k - 1) % 2 - 1)) % N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] * s for d, s in zip([0, 1, 2], site_nbr))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_nbr if val < 0]) - total_spin)
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
    
  return(priorities)




#score: {'data3D.txt': -0.3344486}
#standard deviation: 0.039722277855631594
#island_id: 2
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.3344486}
#standard deviation: 0.039722277855631594
#island_id: 2
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
  return priorities




#score: {'data3D.txt': -0.1515942}
#standard deviation: 0.04066037390826602
#island_id: 2
#version_generated: 3
#generate time20:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
        x_nbr = (i + ((k - 1) % 2 - 1)) % N
        y_nbr = ((j + 1) % N)
        z_nbr = ((i + 1) % N)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + sum([J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        priorities[i * N * N + j * N + k][1] -= 4 - 3 * sum([J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        
  return priorities




#score: {'data3D.txt': -0.10231620000000001}
#standard deviation: 0.044356926601828495
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= h[i][j][k]
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]
  
  return(priorities)




#score: {'data3D.txt': -0.2477074}
#standard deviation: 0.047070455545278084
#island_id: 1
#version_generated: 3
#generate time20:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in site_neighbors if val > 0))
        priorities[i * N * N + j * N + k][1] -= 2 * (sum(1 for val in interacting_spins if val < 0) - sum(1 for val in site_neighbors if val > 0))
        
        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]
          
  return(priorities)




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)

        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]

        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1

  return priorities




#score: {'data3D.txt': -0.34337300000000004}
#standard deviation: 0.045592477789652974
#island_id: 1
#version_generated: 3
#generate time20:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])

        neighbor_spin = sum(J[0, i:i+2, j, k])
        spin_value = h[i][j][k] + site_nbr - site_nopr

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (spin_value + neighbor_spin) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1067934}
#standard deviation: 0.04250197826501727
#island_id: 1
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in interacting_spins if val < 0)
        site_nopr = len([val for val in interacting_spins if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr - site_nopr)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_nbr - site_nopr)
        
        # Add a new term based on the interaction with the site's neighbors
        for d in [0, 1, 2]:
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors[d]
            priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors[d]
        
        # Add a new term based on the total spin of the site's neighbors
        neighbor_spin = sum(J[0, i:i+2, j, k])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1 if neighbor_spin < 0 else -np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 1 if neighbor_spin > 0 else 1
  
  return priorities




#score: {'data3D.txt': -0.0646502}
#standard deviation: 0.05231789521721989
#island_id: 3
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in interacting_spins[:, i, j, k]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.0050318}
#standard deviation: 0.05394203545251142
#island_id: 3
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in [h[i, j, k]] + [interacting_spin[i, j, k] for interacting_spin in interacting_spins]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.28888060000000004}
#standard deviation: 0.04047098545427329
#island_id: 3
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          interacting_spins.append(neighbor_spin)
        
        priorities[i * N * N + j * N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) for interacting_spin in set(interacting_spins)]) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.091927}
#standard deviation: 0.05615737806379497
#island_id: 3
#version_generated: 3
#generate time20:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))

        if h[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0023158000000000002}
#standard deviation: 0.048822330038211
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0057774}
#standard deviation: 0.049088630142223366
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_spin = np.sign(sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_spin == -1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0274394}
#standard deviation: 0.04981209419046744
#island_id: 3
#version_generated: 3
#generate time20:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spins[0, i, j, k] + interacting_spins[1, i, j, k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0023518000000000002}
#standard deviation: 0.047068092342477615
#island_id: 0
#version_generated: 3
#generate time20:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % 2 - 1) % N, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] * h[i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2:, i, j, :] < 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2:, i, j, :] < 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum(J[2:, i, j, :] > 0) + total_spin)
          priorities[i * N * N + j * N + k][1] -= np.sum(J[2:, i, j, :] > 0) - total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [2, 3]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[3-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [4, 5]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d-2, i+d-2, j, k]
          else:
            neighbor_spin = J[7-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': 0.008793800000000001}
#standard deviation: 0.04602777858598001
#island_id: 3
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  site_neighbors = [[J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] 
           for i in range(N) for j in range(N) for k in range(N)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbor_sum = sum([J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]])
        priorities[i*N*N + j*N + k][0] = np.sum([-interacting_spin * np.exp(-abs(total_spin)) 
          for interacting_spin in interacting_spins])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.110301}
#standard deviation: 0.04742865040247298
#island_id: 3
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        priorities[i * N * N + j * N + k][0] += np.sum([-interacting_spin * (1 - 2*total_spin) for interacting_spin in interacting_spins[:, i, j, k]])
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0003665999999999999}
#standard deviation: 0.056362671019390125
#island_id: 3
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  
  site_neighbors = [0, 0, 0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbors[0] = J[1, i, (j + 1) % N, k]
        site_neighbors[1] = J[2, (i + 1) % N, j, k]
        site_neighbors[2] = J[4, i, j, (k + 1) % N]
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
          for d in range(6)]) - sum(site_neighbors)
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0024438000000000003}
#standard deviation: 0.06583570795214402
#island_id: 3
#version_generated: 3
#generate time20:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k]
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k]
            for d in range(6)]) - 2 * total_spin
        priorities[i*N*N + j*N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time20:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.5688826}
#standard deviation: 0.040026789244704604
#island_id: 1
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time20:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47320540000000005}
#standard deviation: 0.04196319829136002
#island_id: 0
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.46643940000000006}
#standard deviation: 0.045396821118223685
#island_id: 0
#version_generated: 2
#generate time20:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.41757780000000017}
#standard deviation: 0.050196063064347984
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43384540000000005}
#standard deviation: 0.049271339121643526
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, j, k], J[4, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10498859999999999}
#standard deviation: 0.04728563323082393
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the difference between the site's spin and its neighbors' spins
        neighbor_diff = sum((J[d, i, j, k] - J[d, (i+1)%N, j, k]) for d in range(6))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_diff
        priorities[i * N * N + j * N + k][1] -= 2 * neighbor_diff
  
  return(priorities)




#score: {'data3D.txt': -0.4187226000000001}
#standard deviation: 0.04939373775328205
#island_id: 2
#version_generated: 3
#generate time20:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1515942}
#standard deviation: 0.04066037390826602
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
        x_nbr = (i + ((k - 1) % 2 - 1)) % N
        y_nbr = ((j + 1) % N)
        z_nbr = ((i + 1) % N)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + sum([J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        priorities[i * N * N + j * N + k][1] -= 4 - 3 * sum([J[0, x_nbr, y_nbr, z_nbr], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]])
        
  return priorities




#score: {'data3D.txt': -0.43384540000000005}
#standard deviation: 0.049271339121643526
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, j, k], J[4, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43768500000000005}
#standard deviation: 0.04817253756031542
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4187066000000001}
#standard deviation: 0.0486727952396408
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43384540000000005}
#standard deviation: 0.049271339121643526
#island_id: 2
#version_generated: 3
#generate time20:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, j, k], J[4, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 1
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time20:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.41757780000000017}
#standard deviation: 0.050196063064347984
#island_id: 2
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18003939999999985}
#standard deviation: 0.049580820562390875
#island_id: 2
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -2 + total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.41757780000000017}
#standard deviation: 0.050196063064347984
#island_id: 2
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.41920900000000005}
#standard deviation: 0.05096465951029203
#island_id: 2
#version_generated: 3
#generate time20:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, (j+1)%N, k], J[4, (i+1)%N, j, k], J[5, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2425518}
#standard deviation: 0.04783947613383742
#island_id: 3
#version_generated: 3
#generate time20:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] += len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.008983799999999998}
#standard deviation: 0.04445034192849364
#island_id: 0
#version_generated: 3
#generate time20:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] -= -2 * total_site_nbr_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -total_spin
          priorities[i * N * N + j * N + k][1] = 2 * total_site_nbr_spin
        
  return(priorities)




#score: {'data3D.txt': -0.12483419999999999}
#standard deviation: 0.058303630679058055
#island_id: 3
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0) + np.roll(h, 1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1) + np.roll(h, 1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2) + np.roll(h, 1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin_x = sum(J[0, i, j, k] * interacting_spins_x[i, j, k] 
                  for d in range(3))
        total_spin_y = sum(J[1, i, j, k] * interacting_spins_y[i, j, k] 
                  for d in range(3))
        total_spin_z = sum(J[2, i, j, k] * interacting_spins_z[i, j, k] 
                  for d in range(3))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins_x[i, j, k] if d == 0 else
                                 -J[d, i, j, k]*interacting_spins_y[i, j, k] if d == 1 else
                                 -J[d, i, j, k]*interacting_spins_z[i, j, k] for d in range(3)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin_x + 2 * total_spin_y + 2 * total_spin_z
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin_x) - abs(total_spin_y) - abs(total_spin_z))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.044590199999999997}
#standard deviation: 0.05279196400930732
#island_id: 3
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins_x = np.roll(h, -1, axis=0)
  interacting_spins_y = np.roll(h, -1, axis=1)
  interacting_spins_z = np.roll(h, -1, axis=2)
  interacting_spins_xx = np.roll(interacting_spins_x, -1, axis=0)
  interacting_spins_yy = np.roll(interacting_spins_y, -1, axis=1)
  interacting_spins_zz = np.roll(interacting_spins_z, -1, axis=2)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (h[i, j, k] + 
                           interacting_spins_x[i, j, k] + 
                           interacting_spins_y[i, j, k] + 
                           interacting_spins_z[i, j, k])
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*(h[i, j, k] + 
                                          interacting_spins_x[i, j, k] + 
                                          interacting_spins_y[i, j, k] + 
                                          interacting_spins_z[i, j, k])
                                 for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0025289999999999996}
#standard deviation: 0.05671584151716343
#island_id: 3
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                  for d in range(6))

        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                   for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1689538}
#standard deviation: 0.05876809053865883
#island_id: 3
#version_generated: 3
#generate time20:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                               for d in range(6)])
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        if h[i, j, k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1994798}
#standard deviation: 0.04314011859000854
#island_id: 2
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time20:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time20:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return priorities




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.38512620000000003}
#standard deviation: 0.03985080317333642
#island_id: 2
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 1
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 1
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(site_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': 0.16590020000000016}
#standard deviation: 0.05174377411785885
#island_id: 1
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4340406000000001}
#standard deviation: 0.046174291457909786
#island_id: 1
#version_generated: 3
#generate time20:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Improved version: Calculate the priority based on the site magnetism and its neighbors' spins
        spin_magnetism = h[i][j][k]
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priority = spin_magnetism * np.sign(total_spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -priority
          priorities[i * N * N + j * N + k][1] -= priority
        else:
          priorities[i * N * N + j * N + k][0] -= priority
          priorities[i * N * N + j * N + k][1] = priority
        
  return(priorities)




#score: {'data3D.txt': 0.2400722}
#standard deviation: 0.04598661226009153
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]] + [J[3,i-1,j,k], J[4,i,j-1,k], J[5,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([spin for spin in interacting_spins if spin < 0]) - sum([J[d, i, j, k] for d in [3,4,5]])
          priorities[i * N * N + j * N + k][1] = 2 - sum([J[d, i, j, k] for d in range(6)])
        else:
          priorities[i * N * N + j * N + k][0] = 2 - sum([spin for spin in interacting_spins if spin > 0]) - sum([J[d, i, j, k] for d in [3,4,5]])
          priorities[i * N * N + j * N + k][1] = -sum([J[d, i, j, k] for d in range(6)])
  
  return(priorities)




#score: {'data3D.txt': -0.18003939999999985}
#standard deviation: 0.049580820562390875
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        site_neighbors = [J[3,i,j,k], J[4,i,j,k], J[5,i,j,k]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -2 + total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15111619999999992}
#standard deviation: 0.05085601613929272
#island_id: 2
#version_generated: 3
#generate time20:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[3, i, j, k], J[4, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -2 + total_spin
          priorities[i * N * N + j * N + k][1] = -total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time20:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time20:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.46643940000000006}
#standard deviation: 0.045396821118223685
#island_id: 0
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.46643940000000006}
#standard deviation: 0.045396821118223685
#island_id: 0
#version_generated: 3
#generate time20:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47320540000000005}
#standard deviation: 0.04196319829136002
#island_id: 0
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4048114}
#standard deviation: 0.04437126806887538
#island_id: 0
#version_generated: 3
#generate time20:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': 0.04965859999999995}
#standard deviation: 0.051745316754659064
#island_id: 2
#version_generated: 3
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  priorities = h.flatten() + np.sum(J*(interacting_spins-0.5), axis=0).flatten()
  return np.array([priorities, np.zeros(N**3)]).T




#score: {'data3D.txt': -0.36591900000000005}
#standard deviation: 0.044171920028452466
#island_id: 2
#version_generated: 3
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * (total_spin + site_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -3 + 2 * (total_spin + site_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.3344486}
#standard deviation: 0.039722277855631594
#island_id: 2
#version_generated: 3
#generate time20:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * sum(site_neighbors)
        
  return priorities




#score: {'data3D.txt': 0.1332802000000001}
#standard deviation: 0.05242675584050573
#island_id: 2
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        # Additional term to favor the majority
        if np.sum(h[i:(i+2),j:(j+2),k:(k+2)]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.2087534}
#standard deviation: 0.04396587254268929
#island_id: 2
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return priorities




#score: {'data3D.txt': -0.17817940000000027}
#standard deviation: 0.04416668717076254
#island_id: 2
#version_generated: 3
#generate time20:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * abs(total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.0057774}
#standard deviation: 0.049088630142223366
#island_id: 3
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i) 

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_spin = np.sign(sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_spin == -1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for d in [0, 1]:
    for i in range(N):
      for j in range(N):
        site_spin = sum(J[d, i, j, k] for k in range(N)) / N
        priorities[i * N + j][0] += np.exp(-abs(site_spin)) * (site_spin == -1)
        priorities[i * N + j][1] -= 2 - 2 * site_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0057774}
#standard deviation: 0.049088630142223366
#island_id: 3
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_spin = np.sign(sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_spin == -1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0019378000000000004}
#standard deviation: 0.04903754572936945
#island_id: 3
#version_generated: 3
#generate time20:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_spin = np.sign(sum(J[d, i, j, k] for d in [0, 1, 2]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_spin == -1) * (sum(1 if J[d, i, j, k] < 0 else -1 for d in [0, 1, 2]) <= 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.445647}
#standard deviation: 0.047246334789060616
#island_id: 0
#version_generated: 3
#generate time20:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in [J[2, i, j, k - 1]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in [J[2, i, j, k - 1]] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[d, i + d, j, k] or J[1 - d, i - d, j, k] for d in [0, 1]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[d, i + d, j, k] or J[1 - d, i - d, j, k] for d in [0, 1]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, :] if val < 0) - sum(1 for val in J[2, i, j, :] if val > 0))
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, :] if val < 0) - sum(1 for val in J[2, i, j, :] if val > 0))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, :] if val < 0) - sum(1 for val in J[2, i, j, :] if val > 0))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2, i, j, :] if val < 0) - sum(1 for val in J[2, i, j, :] if val > 0))
        
  return priorities




#score: {'data3D.txt': -0.0056762}
#standard deviation: 0.04705907684559909
#island_id: 0
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
      return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time20:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v0`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.21240219999999999}
#standard deviation: 0.04587126807883122
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.09559980000000003}
#standard deviation: 0.046067659371407194
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2 - 4 * total_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 6 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2 - 4 * total_spin
          priorities[i * N * N + j * N + k][1] = 3 - 6 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.21240219999999999}
#standard deviation: 0.04587126807883122
#island_id: 3
#version_generated: 3
#generate time20:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + sum(val for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site itself
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.0003665999999999999}
#standard deviation: 0.056362671019390125
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbors = [J[1, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k], 
                  J[4, i, j, (k + 1) % N]]
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
               for d in range(6)]) - sum(site_neighbors)
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0003665999999999999}
#standard deviation: 0.056362671019390125
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + \
            [np.roll(h, 1, axis=i) for i in range(3)]
  
  site_neighbors = [0, 0, 0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbors[0] = J[1, i, (j + 1) % N, k]
        site_neighbors[1] = J[2, (i + 1) % N, j, k]
        site_neighbors[2] = J[4, i, j, (k + 1) % N]
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
         for d in range(6)]) - sum(site_neighbors)
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14750179999999996}
#standard deviation: 0.05630277787782766
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] +\
            [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbors = [J[1, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k], J[4, i, j, (k + 1) % N]]
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
          for d in range(6)]) - sum(site_neighbors)
        priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin))
          priorities[i*N*N + j*N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0026030000000000003}
#standard deviation: 0.06301577097044835
#island_id: 3
#version_generated: 3
#generate time21:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)] + \
            [np.roll(h, 1, axis=i) for i in range(3)]
  
  site_neighbors = [0, 0, 0]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] 
                 for d in range(6))
        
        site_neighbors[0] = J[1, i, (j + 1) % N, k]
        site_neighbors[1] = J[2, (i + 1) % N, j, k]
        site_neighbors[2] = J[4, i, j, (k + 1) % N]
        
        priorities[i*N*N + j*N + k][0] = np.sum([-J[d, i, j, k]*interacting_spins[d][i, j, k] 
                               for d in range(6)]) - sum(site_neighbors)
        priorities[i*N*N + j*N + k][1] = 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3487558}
#standard deviation: 0.04953422500009463
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time21:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.392625}
#standard deviation: 0.041332986040207645
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.47320540000000005}
#standard deviation: 0.04196319829136002
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0021697999999999965}
#standard deviation: 0.04661247824306277
#island_id: 0
#version_generated: 3
#generate time21:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - 1
          priorities[i * N * N + j * N + k][1] -= 3 - total_site_nbr_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - 1
          priorities[i * N * N + j * N + k][1] = -3 + total_site_nbr_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.22538139999999998}
#standard deviation: 0.04314765919537235
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N], J[3, i - 1, j, k] if i > 0 else 0, 
                  J[4, i, (j + 1) % N, k - 1] if k > 0 else 0, 
                  J[5, (i + 1) % N, j, k - 1] if k > 0 and i < N - 1 else 0]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[5, (i + 1) % N, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1, 3]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return priorities




#score: {'data3D.txt': -0.22405019999999998}
#standard deviation: 0.04259873613101685
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.1994798}
#standard deviation: 0.04314011859000854
#island_id: 2
#version_generated: 3
#generate time21:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': 0.10271700000000021}
#standard deviation: 0.051394975153219016
#island_id: 1
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2]]))) * (len([val for val in interacting_spins if val < 0]) + len([val for val in interacting_spins if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum([J[d, i, j, k] for d in [0, 1, 2]]))) * (len([val for val in interacting_spins if val > 0]) + len([val for val in interacting_spins if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])

  return(priorities)




#score: {'data3D.txt': 0.08550620000000024}
#standard deviation: 0.04770694668033158
#island_id: 1
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (neighbor_spin > 0) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0053537999999998505}
#standard deviation: 0.0525831682723664
#island_id: 1
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.16590020000000016}
#standard deviation: 0.05174377411785885
#island_id: 1
#version_generated: 3
#generate time21:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add additional logic to improve the function
  
  return(priorities)




#score: {'data3D.txt': 0.1332802000000001}
#standard deviation: 0.05242675584050573
#island_id: 2
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        # Additional term to favor the majority
        if np.sum(h[i:(i+2),j:(j+2),k:(k+2)]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
   for j in range(N):
    for k in range(N):
     site_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) / 3
     priorities[i * N * N + j * N + k][0] += np.exp(-abs(site_spin)) * (site_spin == -1)
     priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for d in [0, 1]:
    for i in range(N):
      for j in range(N):
        site_spin = sum(J[d, i, j, k] for k in range(N)) / N
        priorities[i * N + j][0] += np.exp(-abs(site_spin)) * (site_spin == -1)
        priorities[i * N + j][1] -= 2 - 2 * site_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time21:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for d in [0, 1]:
   for i in range(N):
    for j in range(N):
     site_spin = sum(J[d, i, j, k] for k in range(N)) / N
     priorities[i * N + j][0] += np.exp(-abs(site_spin)) * (site_spin == -1)
     priorities[i * N + j][1] -= 2 - 2 * site_spin

  for d in [2]:
   for i in range(N):
    for k in range(N):
     site_spin = sum(J[d, i, j, k] for j in range(N)) / N
     priorities[i * N**2 + k][0] += np.exp(-abs(site_spin)) * (site_spin == -1)
     priorities[i * N**2 + k][1] -= 2 - 2 * site_spin

  return(priorities)




#score: {'data3D.txt': -0.10624339999999992}
#standard deviation: 0.04930371584819952
#island_id: 1
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (neighbor_spin > 0) - neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.09116140000000003}
#standard deviation: 0.046058382842214515
#island_id: 1
#version_generated: 3
#generate time21:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in J[2,:,j,k] if val < 0) + sum(1 for val in J[:,i,j,1-k] if val < 0) + sum(1 for val in [J[0,i,j,k], J[1,i-1%N,j,k]] if val < 0)) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in J[2,:,j,k] if val > 0) + sum(1 for val in J[:,i,j,1-k] if val > 0) + sum(1 for val in [J[0,i,j,k], J[1,i-1%N,j,k]] if val > 0)) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': 0.180939}
#standard deviation: 0.048192757951791884
#island_id: 1
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        for d in [0, 1]:
          for m in range(N):
            if i != m:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[d, i, j, k] - J[d, m, j, k])
              priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.093583}
#standard deviation: 0.04648215992184528
#island_id: 1
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.39824780000000004}
#standard deviation: 0.05109765547615664
#island_id: 0
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47320540000000005}
#standard deviation: 0.04196319829136002
#island_id: 0
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.018340599999999995}
#standard deviation: 0.045100028732141625
#island_id: 0
#version_generated: 3
#generate time21:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return priorities




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0034433999999999997}
#standard deviation: 0.04693572537460138
#island_id: 3
#version_generated: 2
#generate time21:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (total_spin + len([val for val in interacting_spins if val < 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_neighbor_spin + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (-total_neighbor_spin - total_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 3
#version_generated: 2
#generate time21:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3968954}
#standard deviation: 0.041554988856213164
#island_id: 2
#version_generated: 2
#generate time21:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0016682}
#standard deviation: 0.04689234424466322
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
        return(priorities)




#score: {'data3D.txt': -0.45799739999999994}
#standard deviation: 0.041636936885894954
#island_id: 2
#version_generated: 3
#generate time21:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 3
#version_generated: 3
#generate time21:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3680246}
#standard deviation: 0.04147006239252601
#island_id: 1
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + 1) % N, (j + 1) % N, (k + 1) % N]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i, j, (k+1)%N), ((i+1)%N, j, k), (i, (j+1)%N, k)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val[2] < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val[2] > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.490485}
#standard deviation: 0.039821866543395486
#island_id: 1
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if h[site_nbr][j][k] > 0]) + site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time21:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.45799739999999994}
#standard deviation: 0.041636936885894954
#island_id: 2
#version_generated: 3
#generate time21:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.463437}
#standard deviation: 0.04246454651824272
#island_id: 1
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in site_neighbors if val < 0) - sum(1 for val in site_neighbors if val > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum(1 for val in site_neighbors if val > 0) - sum(1 for val in site_neighbors if val < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0456626}
#standard deviation: 0.05319435948707344
#island_id: 1
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        # Add interactions with other spins
        for d in [3, 4, 5]:
          for l in [(i - 1) % N, i, (i + 1) % N]:
            for m in [(j - 1) % N, j, (j + 1) % N]:
              if k == 0:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, l, m, 0]
                priorities[i * N * N + j * N + k][1] -= J[d, l, m, 0]
              elif k == N - 1:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, l, m, N - 1]
                priorities[i * N * N + j * N + k][1] -= J[d, l, m, N - 1]
              else:
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, l, m, k]
                priorities[i * N * N + j * N + k][1] -= J[d, l, m, k]
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.093583}
#standard deviation: 0.04648215992184528
#island_id: 1
#version_generated: 3
#generate time21:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0016682}
#standard deviation: 0.04689234424466322
#island_id: 2
#version_generated: 3
#generate time21:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
        return(priorities)




#score: {'data3D.txt': 0.15205259999999998}
#standard deviation: 0.04820565022110997
#island_id: 2
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.26719259999999995}
#standard deviation: 0.04920578243702664
#island_id: 2
#version_generated: 3
#generate time21:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time21:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.222015}
#standard deviation: 0.0503552997707292
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val > 0]) + len([val for val in site_neighbors if val < 0])) - site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.3487558}
#standard deviation: 0.04953422500009463
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.030580600000000003}
#standard deviation: 0.04717172695206314
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][1] = -sum(1 for val in site_neighbors if val < 0) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19218940000000004}
#standard deviation: 0.04611202107520338
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(J[d, i, j, k] for d in [0, 1, 2])) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(J[d, i, j, k] for d in [0, 1, 2])) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] = sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.5103494}
#standard deviation: 0.04316351560797615
#island_id: 1
#version_generated: 3
#generate time21:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])) + site_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])) + site_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.445647}
#standard deviation: 0.047246334789060616
#island_id: 0
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in [J[2, i, j, k - 1]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in [J[2, i, j, k - 1]] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[d, i + d, j, k] or J[1 - d, i - d, j, k] for d in [0, 1]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[d, i + d, j, k] or J[1 - d, i - d, j, k] for d in [0, 1]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.445647}
#standard deviation: 0.047246334789060616
#island_id: 0
#version_generated: 3
#generate time21:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in [J[2, i, j, k - 1]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in [J[2, i, j, k - 1]] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[d, i + d, j, k] or J[1 - d, i - d, j, k] for d in [0, 1]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
        site_neighbors = [(i + (d - 1) % 2 == 0) and J[d, i + d, j, k] or J[1 - d, i - d, j, k] for d in [0, 1]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4100594000000001}
#standard deviation: 0.046815455051083296
#island_id: 0
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors[0] < 0) + (site_neighbors[-1] > 0)
        priorities[i * N * N + j * N + k][1] -= 2 * (site_neighbors[0] < 0) - 2 * (site_neighbors[-1] > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.392625}
#standard deviation: 0.041332986040207645
#island_id: 0
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        # Calculate the total spin
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        # Check if the site has a magnetism greater than 0
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Calculate the site neighbors' spins
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3794434}
#standard deviation: 0.04144871815195254
#island_id: 0
#version_generated: 3
#generate time21:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        if i > 0:
          site_neighbors.append(J[0, i-1, j, k])
        if j > 0:
          site_neighbors.append(J[1, i, j-1, k])
        if k > 0:
          site_neighbors.append(J[2, i, j, k-1])
        
        site_neighbors = [val for val in site_neighbors if val]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time21:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3968954}
#standard deviation: 0.041554988856213164
#island_id: 2
#version_generated: 3
#generate time21:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3968954}
#standard deviation: 0.041554988856213164
#island_id: 2
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1339794000000002}
#standard deviation: 0.0492938456162633
#island_id: 0
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.39824780000000004}
#standard deviation: 0.05109765547615664
#island_id: 0
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3531694}
#standard deviation: 0.04962399564363998
#island_id: 0
#version_generated: 3
#generate time21:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
  
  return(priorities)




#score: {'data3D.txt': -0.46349100000000004}
#standard deviation: 0.043622341970600345
#island_id: 0
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = site_neighbors_sum.sum()
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time21:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])

  return(priorities)




#score: {'data3D.txt': -0.46158659999999996}
#standard deviation: 0.039639082991915944
#island_id: 2
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time21:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.14979900000000004}
#standard deviation: 0.04607250675836948
#island_id: 3
#version_generated: 3
#generate time21:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if sum(site_neighbors) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2989166}
#standard deviation: 0.048595054526566796
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
        if abs(total_site_nbr_spin) >= 2:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4048114}
#standard deviation: 0.04437126806887538
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.4037874000000001}
#standard deviation: 0.03984585350121139
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + 3
          priorities[i * N * N + j * N + k][1] += 3

  return(priorities)




#score: {'data3D.txt': -0.4048114}
#standard deviation: 0.04437126806887538
#island_id: 0
#version_generated: 3
#generate time21:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if total_site_nbr_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif total_site_nbr_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.1339794000000002}
#standard deviation: 0.0492938456162633
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.06450020000000004}
#standard deviation: 0.056742613263401964
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < -0.5:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -3
        elif site_neighbors_sum > 0.5:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 3
        
  return(priorities)




#score: {'data3D.txt': 0.07789819999999986}
#standard deviation: 0.05191307500774734
#island_id: 0
#version_generated: 3
#generate time21:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + site_neighbors_sum)
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum)
  
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.0256674}
#standard deviation: 0.046749674407850154
#island_id: 2
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = J[2, i, j, (k - 1) % N]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_same = [spin for spin in site_neighbors if spin > 0]
        site_neighbors_opposite = [spin for spin in site_neighbors if spin < 0]
        
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_same) - len(site_neighbors_opposite))
          priorities[i * N * N + j * N + k][1] -= (len(site_neighbors_opposite) - len(site_neighbors_same))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors_opposite) - len(site_neighbors_same))
          priorities[i * N * N + j * N + k][1] = -(len(site_neighbors_opposite) - len(site_neighbors_same))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time21:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + 1) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0666818}
#standard deviation: 0.05165740594300105
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.28087700000000004}
#standard deviation: 0.050511072360424104
#island_id: 0
#version_generated: 3
#generate time21:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N], J[3, i, (j - 1) % N, k],
                  J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4807778}
#standard deviation: 0.03897984026596312
#island_id: 2
#version_generated: 3
#generate time22:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3307086}
#standard deviation: 0.05339546128689217
#island_id: 0
#version_generated: 3
#generate time22:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * len([val for val in site_neighbors if val < 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.450231}
#standard deviation: 0.044132435679441036
#island_id: 2
#version_generated: 3
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Additional priority term based on the spin at this site
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2169818}
#standard deviation: 0.042813740186533576
#island_id: 2
#version_generated: 3
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + (k - 1) % 2 - 1) % N if h[i][j][k] > 0 else (i + ((k + 1) % 2 - 1)) % N]
        for d in [3, 4, 5]:
          site_neighbors.append((i + (d % 2 - 1)) % N)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.46158659999999996}
#standard deviation: 0.039639082991915944
#island_id: 2
#version_generated: 3
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum(J[d, i, j, k] for d in [3, 4, 5])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time22:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time22:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.49866299999999997}
#standard deviation: 0.04316936773917357
#island_id: 0
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if site_neighbors[d] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif site_neighbors[d] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3049678}
#standard deviation: 0.04205169346364068
#island_id: 0
#version_generated: 3
#generate time22:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.07789819999999986}
#standard deviation: 0.05191307500774734
#island_id: 0
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + site_neighbors_sum)
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum)
  
  return(priorities)




#score: {'data3D.txt': 0.1337058}
#standard deviation: 0.04874219000373291
#island_id: 0
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + site_neighbors_sum)
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum)
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + J[0, i, j, k])
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + J[0, i, j, k])
        
        if J[1, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + J[1, i, j, k])
        elif J[1, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + J[1, i, j, k])
        
        if J[2, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + J[2, i, j, k])
        elif J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + J[2, i, j, k])
        
  return(priorities)




#score: {'data3D.txt': 0.16276619999999992}
#standard deviation: 0.05218462855630958
#island_id: 0
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + site_neighbors_sum)
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum)
        
        # Add the new term to prioritize the direction of the spins
        if total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + site_neighbors_sum)
        elif total_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum)
  
  return(priorities)




#score: {'data3D.txt': 0.07789819999999986}
#standard deviation: 0.05191307500774734
#island_id: 0
#version_generated: 3
#generate time22:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -2 * (len([val for val in interacting_spins if val < 0]) + site_neighbors_sum)
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 2 * (len([val for val in interacting_spins if val > 0]) + site_neighbors_sum)
  
  return(priorities)




#score: {'data3D.txt': -0.2818446}
#standard deviation: 0.043931054743085785
#island_id: 0
#version_generated: 3
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors_sum = J[0, i, (j + 1) % N, k] + J[1, (i + 1) % N, j, k] + J[2, i, j, (k + 1) % N]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum_avg = site_neighbors_sum.mean()
        
        if site_neighbors_sum_avg < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors_sum_avg > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3739126}
#standard deviation: 0.042985046716736273
#island_id: 0
#version_generated: 3
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = site_neighbors_sum.sum()
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(J[d, i, (j + 1) % N, k] for d in range(3)) + sum(J[d, (i + 1) % N, j, k] for d in range(3))
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46349100000000004}
#standard deviation: 0.043622341970600345
#island_id: 0
#version_generated: 3
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = site_neighbors_sum.sum()
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.41319500000000003}
#standard deviation: 0.04340560626232515
#island_id: 0
#version_generated: 3
#generate time22:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors_sum = 0
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors_sum += neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum /= 3
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3487558}
#standard deviation: 0.04953422500009463
#island_id: 1
#version_generated: 3
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3350098}
#standard deviation: 0.05037074015696018
#island_id: 1
#version_generated: 3
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the average spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        spin_diff = abs(total_spin - site_spin)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3487558}
#standard deviation: 0.04953422500009463
#island_id: 1
#version_generated: 3
#generate time22:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4862114}
#standard deviation: 0.045782638522042396
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4840702}
#standard deviation: 0.04620944656625959
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the average spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.492519}
#standard deviation: 0.04459349772108037
#island_id: 1
#version_generated: 3
#generate time22:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44186260000000005}
#standard deviation: 0.04058533677622991
#island_id: 3
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4881574000000001}
#standard deviation: 0.040019547039415626
#island_id: 3
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_nbr < 0) * 1
        priorities[i * N * N + j * N + k][1] -= (site_nbr < 0)
        
        for d in [0, 1]:
          if i == (d - 1) % 2:
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) * 1
          priorities[i * N * N + j * N + k][1] -= (neighbor_spin < 0)
        
        site_neighbors_sum = sum(val for val in site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2630094}
#standard deviation: 0.05060369741076239
#island_id: 3
#version_generated: 2
#generate time22:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - 3
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4840702}
#standard deviation: 0.04620944656625959
#island_id: 1
#version_generated: 3
#generate time22:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the average spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 2
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 2
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.2534254000000004}
#standard deviation: 0.04567536441934535
#island_id: 2
#version_generated: 3
#generate time22:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3278698}
#standard deviation: 0.053432081448882375
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_site_nbr_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * len([val for val in site_neighbors if val < 0])
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4]:
          if (i + (d - 2) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[5 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2200094}
#standard deviation: 0.05348309669082373
#island_id: 0
#version_generated: 3
#generate time22:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors_sum = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors_sum += np.sign(neighbor_spin)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * np.count_nonzero(site_neighbors_sum)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - site_neighbors_sum
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * np.count_nonzero(site_neighbors_sum)
  
  return priorities




#score: {'data3D.txt': -0.1339794000000002}
#standard deviation: 0.0492938456162633
#island_id: 0
#version_generated: 3
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': 0.13163500000000014}
#standard deviation: 0.04702324037111862
#island_id: 0
#version_generated: 3
#generate time22:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.46132940000000017}
#standard deviation: 0.04526863478878063
#island_id: 3
#version_generated: 3
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum < 0) * 1
          priorities[i * N * N + j * N + k][1] -= (site_neighbors_sum < 0)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_sum = sum(val for val in site_neighbors)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbors_sum > 0) * 1
          priorities[i * N * N + j * N + k][1] += (site_neighbors_sum > 0)
  
  return(priorities)




#score: {'data3D.txt': -0.4376974000000001}
#standard deviation: 0.0459333229065784
#island_id: 3
#version_generated: 3
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                         for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.44186260000000005}
#standard deviation: 0.04058533677622991
#island_id: 3
#version_generated: 3
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.44186260000000005}
#standard deviation: 0.04058533677622991
#island_id: 3
#version_generated: 3
#generate time22:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.1339794000000002}
#standard deviation: 0.0492938456162633
#island_id: 0
#version_generated: 3
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_nbr_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum = total_site_nbr_spin + total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.1339794000000002}
#standard deviation: 0.0492938456162633
#island_id: 0
#version_generated: 3
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.1339794000000002}
#standard deviation: 0.0492938456162633
#island_id: 0
#version_generated: 3
#generate time22:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.027601}
#standard deviation: 0.048045621226080526
#island_id: 3
#version_generated: 3
#generate time22:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        spin_value = 1 if h[i][j][k] > 0 else -1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val * spin_value < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([spin_value if val * spin_value < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.3432654}
#standard deviation: 0.04899468382222708
#island_id: 2
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        corner_neighbors = [J[3, (i + 2) % N, (j + 1) % N, (k + 1) % N], J[4, (i + 1) % N, j, k], J[5, i, (j - 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in corner_neighbors if val < 0]) - len([val for val in corner_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in corner_neighbors if val > 0]) - len([val for val in corner_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3166198}
#standard deviation: 0.04714903655388941
#island_id: 2
#version_generated: 3
#generate time22:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        priorities[i * N * N + j * N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0027433999999999996}
#standard deviation: 0.047121559783606486
#island_id: 0
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([val for val in J[1:, i, j, k] if val < 0]) - np.sum([val for val in J[1:, i, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * (np.sum([val for val in J[1:, i, j, k] if val < 0]) - np.sum([val for val in J[1:, i, j, k] if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.sum([val for val in J[1:, i, j, k] if val > 0]) - np.sum([val for val in J[1:, i, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] = 2 * (np.sum([val for val in J[1:, i, j, k] if val > 0]) - np.sum([val for val in J[1:, i, j, k] if val < 0]))
  
  return priorities




#score: {'data3D.txt': -0.392625}
#standard deviation: 0.041332986040207645
#island_id: 0
#version_generated: 3
#generate time22:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.26719259999999995}
#standard deviation: 0.04920578243702664
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.0016682}
#standard deviation: 0.04689234424466322
#island_id: 2
#version_generated: 3
#generate time22:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
        return(priorities)




#score: {'data3D.txt': -0.44186260000000005}
#standard deviation: 0.04058533677622991
#island_id: 3
#version_generated: 3
#generate time22:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.44186260000000005}
#standard deviation: 0.04058533677622991
#island_id: 3
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.06197779999999999}
#standard deviation: 0.050803553686331826
#island_id: 3
#version_generated: 3
#generate time22:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.39824780000000004}
#standard deviation: 0.05109765547615664
#island_id: 0
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3531694}
#standard deviation: 0.04962399564363998
#island_id: 0
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.409189}
#standard deviation: 0.046403087817514906
#island_id: 0
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.4456694}
#standard deviation: 0.04259562164870939
#island_id: 0
#version_generated: 3
#generate time22:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if (site_neighbors[0] < 0 and site_neighbors[-1] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif (site_neighbors[0] < 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif (site_neighbors[0] > 0 and site_neighbors[-1] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif (site_neighbors[0] > 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.4399702}
#standard deviation: 0.03965249288455897
#island_id: 2
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the difference in the number of neighboring spins
        site_neighbor_diff = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        # Calculate the difference in the magnetism at the current site
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the number of neighboring spins with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.44358860000000006}
#standard deviation: 0.04143436822301023
#island_id: 2
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.13823500000000002}
#standard deviation: 0.04640294575778568
#island_id: 2
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
        # Add new term based on the number of nearest neighbors with same spin in x direction
        site_x_same_spin = [J[2, i - 1, j, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_x_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_x_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43024219999999996}
#standard deviation: 0.04690970580977886
#island_id: 2
#version_generated: 3
#generate time22:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum(1 for val in interacting_spins if val > 0)
        opposite_spin = len(interacting_spins) - same_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin - same_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (same_spin - opposite_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.105325}
#standard deviation: 0.04837974467687898
#island_id: 2
#version_generated: 3
#generate time22:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_neighbors_same_spin = [J[2, i, (j - 1) % N, k], J[2, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4399702}
#standard deviation: 0.03965249288455897
#island_id: 2
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the difference in the number of neighboring spins
        site_neighbor_diff = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        # Calculate the difference in the magnetism at the current site
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the number of neighboring spins with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.4399702}
#standard deviation: 0.03965249288455897
#island_id: 2
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the difference in the number of neighboring spins
        site_neighbor_diff = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        # Calculate the difference in the magnetism at the current site
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the number of neighboring spins with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.4247714}
#standard deviation: 0.039584832727194895
#island_id: 2
#version_generated: 3
#generate time22:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_opposite_spin = [J[3, i, (j - 1) % N, k], J[4, i, j, (k - 1) % N], J[5, (i - 1) % N, j, k]]
        
        # Calculate the difference in the number of neighboring spins
        site_neighbor_diff = len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        # Calculate the difference in the magnetism at the current site
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Calculate the number of neighboring spins with opposite spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.28087700000000004}
#standard deviation: 0.050511072360424104
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N], J[3, i, (j - 1) % N, k],
                 J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': 0.104079}
#standard deviation: 0.054531326400519546
#island_id: 0
#version_generated: 3
#generate time22:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], 
                 J[2, i, j, (k + 1) % N], J[3, i, (j - 1) % N, k],
                 J[4, (i - 1) % N, j, k], J[5, i, j, (k - 1) % N]]
        total_site_nbr_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
        # New priority calculation based on the total spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin / abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) / abs(2 - 2 * total_spin)
  
  return priorities




#score: {'data3D.txt': -0.2630094}
#standard deviation: 0.05060369741076239
#island_id: 3
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - 3
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.14504660000000003}
#standard deviation: 0.05589411371906706
#island_id: 3
#version_generated: 3
#generate time22:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
        priorities[i * N * N + j * N + k][1] -= 2

  return(priorities)




#score: {'data3D.txt': 0.2862646}
#standard deviation: 0.04488356878457862
#island_id: 3
#version_generated: 3
#generate time22:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins])
          priorities[i * N * N + j * N + k][1] = -2

        priorities[i * N * N + j * N + k][0] += total_spin
        priorities[i * N * N + j * N + k][1] -= 4 if total_spin > 0 else 0

  return(priorities)




#score: {'data3D.txt': -0.030082600000000053}
#standard deviation: 0.05610399787216594
#island_id: 3
#version_generated: 3
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * (J[d, site_neighbors[d-3], j, k] < 0) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(J[d, i, j, k])) * (J[d, site_neighbors[d-3], j, k] > 0) + J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': 0.3172466}
#standard deviation: 0.05293615955507162
#island_id: 3
#version_generated: 3
#generate time22:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= 2
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for d in range(6)]
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        priorities[i * N * N + j * N + k][0] -= len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] += 2 - sum([1 if val < 0 else -1 for val in interacting_spins])
  
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3394118}
#standard deviation: 0.04407457930326732
#island_id: 2
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(val > 0 for val in interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val < 0 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= sum(val > 0 for val in site_neighbors)
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val > 0 for val in site_opposite_spin)
        priorities[i * N * N + j * N + k][1] -= sum(val < 0 for val in site_opposite_spin)
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(val < 0 for val in site_same_spin)
        priorities[i * N * N + j * N + k][1] -= sum(val > 0 for val in site_same_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time22:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0045434}
#standard deviation: 0.04611991193009805
#island_id: 2
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        
        site_neighbor_diff = len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        priorities[i * N * N + j * N + k][1] -= site_neighbor_diff
        
  return priorities




#score: {'data3D.txt': -0.3602878}
#standard deviation: 0.048406771542419555
#island_id: 2
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_spin = [J[3, i, (j + 1) % N, k - 1], J[4, (i + 1) % N, j, k - 1], J[5, i, j, (k + 1) % N - 1]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_opposite_spin if val < 0]) - len([val for val in site_opposite_spin if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_opposite_spin if val > 0]) - len([val for val in site_opposite_spin if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4072738}
#standard deviation: 0.0453016109378022
#island_id: 2
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.13567739999999998}
#standard deviation: 0.04758703572655057
#island_id: 2
#version_generated: 3
#generate time22:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.32428179999999995}
#standard deviation: 0.041777862903217056
#island_id: 3
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
        priorities[i * N * N + j * N + k][1] -= 2
        
        if i > 0:
          site_neighbors = [J[0, (i-1), j, k], J[1, i-1, j, k], J[2, i-1, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
          priorities[i * N * N + j * N + k][1] -= 2
        
        if i < N-1:
          site_neighbors = [J[0, (i+1), j, k], J[1, i+1, j, k], J[2, i+1, j, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
          priorities[i * N * N + j * N + k][1] -= 2
        
        if j > 0:
          site_neighbors = [J[0, i, (j-1) % N, k], J[1, i, j-1, k], J[2, i, j-1, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
          priorities[i * N * N + j * N + k][1] -= 2
        
        if j < N-1:
          site_neighbors = [J[0, i, (j+1) % N, k], J[1, i, j+1, k], J[2, i, j+1, k]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
          priorities[i * N * N + j * N + k][1] -= 2
        
        if k > 0:
          site_neighbors = [J[0, i, j, (k-1) % N], J[1, i, j, k-1], J[2, i, j, k-1]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
          priorities[i * N * N + j * N + k][1] -= 2
        
        if k < N-1:
          site_neighbors = [J[0, i, j, (k+1) % N], J[1, i, j, k+1], J[2, i, j, k+1]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) - 3
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.008148999999999691}
#standard deviation: 0.047570965924605746
#island_id: 3
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_neighbor_sum = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        site_neighbor_sum /= len(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbor_sum < 0) - 2
          priorities[i * N * N + j * N + k][1] -= site_neighbor_sum
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (site_neighbor_sum > 0) - 2
          priorities[i * N * N + j * N + k][1] += site_neighbor_sum
  
  return(priorities)




#score: {'data3D.txt': -0.4657826}
#standard deviation: 0.04318695054342226
#island_id: 3
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum = sum(val for val in site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2

        elif site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= -2

  return(priorities)




#score: {'data3D.txt': 0.0045434}
#standard deviation: 0.04611991193009805
#island_id: 2
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_magnetism_diff = h[i][j][k] * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_magnetism_diff
        
        site_neighbor_diff = len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val < 0]) - len([val for val in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if val > 0])
        priorities[i * N * N + j * N + k][1] -= site_neighbor_diff
        
  return(priorities)




#score: {'data3D.txt': -0.015505799999999998}
#standard deviation: 0.044772615362071486
#island_id: 2
#version_generated: 3
#generate time22:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        spin_sum = sum(interacting_spins)
        site_neighbors_sum = sum(site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(spin_sum)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.06450020000000004}
#standard deviation: 0.056742613263401964
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < -0.5:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -3
        elif site_neighbors_sum > 0.5:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 3
        
  return(priorities)




#score: {'data3D.txt': -0.06450020000000004}
#standard deviation: 0.056742613263401964
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < -0.5:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -3
        elif site_neighbors_sum > 0.5:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 3
        
  return(priorities)




#score: {'data3D.txt': -0.12221259999999999}
#standard deviation: 0.05602130060289568
#island_id: 0
#version_generated: 3
#generate time23:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        
        site_neighbors_sum += total_spin
        
        if site_neighbors_sum < -0.5:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = -3
        elif site_neighbors_sum > 0.5:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] = 3
        
        if abs(site_neighbors_sum) < 0.1:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] = -2
        elif site_neighbors_sum > 0.5 and total_spin < -0.5:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] = 4
        
  return(priorities)




#score: {'data3D.txt': -0.027601}
#standard deviation: 0.048045621226080526
#island_id: 3
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                 for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        spin_value = 1 if h[i][j][k] > 0 else -1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val * spin_value < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([spin_value if val * spin_value < 0 else -1 for val in interacting_spins])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.06965460000000004}
#standard deviation: 0.058285877696402595
#island_id: 3
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
                  for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        spin_value = 1 if h[i][j][k] > 0 else -1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([spin_value if val * spin_value < 0 else -1 for val in interacting_spins]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.12066900000000001}
#standard deviation: 0.04644821201079758
#island_id: 3
#version_generated: 3
#generate time23:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i
             for d in range(6)]
        interacting_spins = [J[d, site_neighbors[d-3], j, k] for d in range(6)]
        
        spin_value = 1 if h[i][j][k] > 0 else -1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val * spin_value < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in range(6):
          neighbor_spin = J[d, site_neighbors[d-3], j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_value
            priorities[i * N * N + j * N + k][1] -= spin_value
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -spin_value
            priorities[i * N * N + j * N + k][1] += spin_value
        
  return(priorities)




#score: {'data3D.txt': -0.44255940000000005}
#standard deviation: 0.04354115652621092
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if (site_neighbors[0] < 0 and site_neighbors[-1] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif (site_neighbors[0] < 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif (site_neighbors[0] > 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.40615260000000003}
#standard deviation: 0.042592281381020204
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if (site_neighbors[0] < 0 and site_neighbors[-1] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif (site_neighbors[0] < 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif (site_neighbors[0] > 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
        site_neighbors_sum = sum(site_neighbors)
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.3531694}
#standard deviation: 0.04962399564363998
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        
        if site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
  return(priorities)




#score: {'data3D.txt': -0.43725580000000003}
#standard deviation: 0.04140109812988057
#island_id: 0
#version_generated: 3
#generate time23:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        site_neighbors_sum = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        
        if (site_neighbors[0] < 0 and site_neighbors[-1] > 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        elif (site_neighbors[0] < 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif (site_neighbors[0] > 0 and site_neighbors[-1] < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        
        if (total_spin > 0 and site_neighbors_sum > 0) or (total_spin < 0 and site_neighbors_sum < 0):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.3602878}
#standard deviation: 0.048406771542419555
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_spin = [J[3, i, (j + 1) % N, k - 1], J[4, (i + 1) % N, j, k - 1], J[5, i, j, (k + 1) % N - 1]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_opposite_spin if val < 0]) - len([val for val in site_opposite_spin if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_opposite_spin if val > 0]) - len([val for val in site_opposite_spin if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3602878}
#standard deviation: 0.048406771542419555
#island_id: 2
#version_generated: 3
#generate time23:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_spin = [J[3, i, (j + 1) % N, k - 1], J[4, (i + 1) % N, j, k - 1], J[5, i, j, (k + 1) % N - 1]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_opposite_spin if val < 0]) - len([val for val in site_opposite_spin if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_opposite_spin if val > 0]) - len([val for val in site_opposite_spin if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.3602878}
#standard deviation: 0.048406771542419555
#island_id: 2
#version_generated: 3
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_spin = [J[3, i, (j + 1) % N, k - 1], J[4, (i + 1) % N, j, k - 1], J[5, i, j, (k + 1) % N - 1]]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_opposite_spin if val < 0]) - len([val for val in site_opposite_spin if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_opposite_spin if val > 0]) - len([val for val in site_opposite_spin if val < 0]))

  return(priorities)




#score: {'data3D.txt': -0.3602878}
#standard deviation: 0.048406771542419555
#island_id: 2
#version_generated: 3
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_opposite_spin = [J[3, i, (j + 1) % N, k - 1], J[4, (i + 1) % N, j, k - 1], J[5, i, j, (k + 1) % N - 1]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_opposite_spin if val < 0]) - len([val for val in site_opposite_spin if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_opposite_spin if val > 0]) - len([val for val in site_opposite_spin if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.31336539999999996}
#standard deviation: 0.046561702318965975
#island_id: 0
#version_generated: 3
#generate time23:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[0, i, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4126914}
#standard deviation: 0.04189598746944628
#island_id: 0
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in [J[1, i - 1, j, k]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in [J[1, i - 1, j, k]] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [(i == 0) and J[1, N - 1, j, k] or (i == N - 1) and J[0, 0, j, k] for _ in [0]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
        site_neighbors = [(i == 0) and J[1, N - 1, j, k] or (i == N - 1) and J[0, 0, j, k] for _ in [0]]
        if any(val < 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0])
        elif any(val > 0 for val in site_neighbors):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3586214}
#standard deviation: 0.04123520318902285
#island_id: 3
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.1285798}
#standard deviation: 0.04972716231557961
#island_id: 3
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors_sum = sum([J[0, (i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i, j, k] for d in [0, 1, 2]])
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum = sum([J[0, (i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i, j, k] for d in [0, 1, 2]])
        if site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2
        elif site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= -2

  return(priorities)




#score: {'data3D.txt': -0.4657826}
#standard deviation: 0.04318695054342226
#island_id: 3
#version_generated: 3
#generate time23:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([1 if val > 0 else -1 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors_sum = sum(val for val in site_neighbors)
        if site_neighbors_sum > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2

        elif site_neighbors_sum < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= -2

  return(priorities)




#score: {'data3D.txt': 0.26719259999999995}
#standard deviation: 0.04920578243702664
#island_id: 2
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))

  return(priorities)




#score: {'data3D.txt': 0.26719259999999995}
#standard deviation: 0.04920578243702664
#island_id: 2
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4530638}
#standard deviation: 0.043421111565228265
#island_id: 2
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.26719259999999995}
#standard deviation: 0.04920578243702664
#island_id: 2
#version_generated: 3
#generate time23:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -(len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.4840702}
#standard deviation: 0.04620944656625959
#island_id: 1
#version_generated: 3
#generate time23:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the average spin of the site's neighbors
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0636402}
#standard deviation: 0.043795168043518226
#island_id: 2
#version_generated: 3
#generate time23:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, i, j, k], J[0, (i+1)%N, j, k], J[0, i, (j+1)%N, k]]
        interacting_spins_y = [J[1, i, j, k], J[1, (i+1)%N, j, k], J[1, i, (j+1)%N, k]]
        interacting_spins_z = [J[2, i, j, k], J[2, (i+1)%N, j, k], J[2, i, (j+1)%N, k]]
        
        total_spin_x = sum([val for val in interacting_spins_x if val < 0])
        total_spin_y = sum([val for val in interacting_spins_y if val < 0])
        total_spin_z = sum([val for val in interacting_spins_z if val < 0])
        
        site_magnetism_diff_x = h[i][j][k] * (len([val for val in interacting_spins_x if val < 0]) - len([val for val in interacting_spins_x if val > 0]))
        site_magnetism_diff_y = h[i][j][k] * (len([val for val in interacting_spins_y if val < 0]) - len([val for val in interacting_spins_y if val > 0]))
        site_magnetism_diff_z = h[i][j][k] * (len([val for val in interacting_spins_z if val < 0]) - len([val for val in interacting_spins_z if val > 0]))
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_x)) * site_magnetism_diff_x
        priorities[i * N * N + j * N + k][1] -= total_spin_x
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_y)) * site_magnetism_diff_y
        priorities[i * N * N + j * N + k][1] -= total_spin_y
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin_z)) * site_magnetism_diff_z
        priorities[i * N * N + j * N + k][1] -= total_spin_z
        
  return(priorities)




#score: {'data3D.txt': -0.32610179999999994}
#standard deviation: 0.051292415002220364
#island_id: 2
#version_generated: 3
#generate time23:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)

        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))

  return(priorities)




#score: {'data3D.txt': -0.471613}
#standard deviation: 0.04741212788939134
#island_id: 1
#version_generated: 3
#generate time23:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.33236380000000004}
#standard deviation: 0.04095423310916712
#island_id: 3
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.0023390000000000004}
#standard deviation: 0.04706161322139309
#island_id: 3
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = [val for val in site_neighbors if val < 0] or [val for val in site_neighbors if val > 0]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.423499}
#standard deviation: 0.04015362896426673
#island_id: 3
#version_generated: 2
#generate time23:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.48173140000000003}
#standard deviation: 0.04628841036415055
#island_id: 1
#version_generated: 3
#generate time23:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_spin = sum(1 for val in site_neighbors if val > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - site_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        avg_neighbor_spin = np.mean(neighbor_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * avg_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        elif J[2, i, j, k - 1] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time23:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.13140179999999999}
#standard deviation: 0.04440999928799819
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
        # Add the interaction between spins
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 * J[d, i, j, k]
        
  return(priorities)




#score: {'data3D.txt': -0.3165582}
#standard deviation: 0.04066732610782273
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in site_neighbors])) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.33236380000000004}
#standard deviation: 0.04095423310916712
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.33236380000000004}
#standard deviation: 0.04095423310916712
#island_id: 3
#version_generated: 3
#generate time23:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.2278157999999999}
#standard deviation: 0.04631798387624402
#island_id: 0
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time23:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3165582}
#standard deviation: 0.04066732610782273
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in site_neighbors])) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3165582}
#standard deviation: 0.04066732610782273
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in site_neighbors])) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3165582}
#standard deviation: 0.04066732610782273
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in site_neighbors])) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - sum([1 if val > 0 else -1 for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.28370020000000024}
#standard deviation: 0.049546257981405606
#island_id: 3
#version_generated: 3
#generate time23:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)

          site_neighbors_sum = sum([val for val in site_neighbors])
          priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in site_neighbors])) * (site_neighbors_sum if site_neighbors_sum > 0 else -1)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - (site_neighbors_sum if site_neighbors_sum > 0 else -1)

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in interacting_spins])) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)

          site_neighbors_sum = sum([val for val in site_neighbors])
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum([abs(val) for val in site_neighbors])) * (site_neighbors_sum if site_neighbors_sum > 0 else -1)
          priorities[i * N * N + j * N + k][1] = len(site_neighbors) - (site_neighbors_sum if site_neighbors_sum > 0 else -1)

  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time23:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.2648206}
#standard deviation: 0.04481023650506657
#island_id: 0
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.1628286}
#standard deviation: 0.04166532877633393
#island_id: 3
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_neighbors_sum = sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0])
        interacting_spins_sum = sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in interacting_spins])) * (interacting_spins_sum if interacting_spins_sum > 0 else -1)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        
        site_neighbors_sum = sum([val for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-sum([abs(val) for val in site_neighbors])) * (site_neighbors_sum if site_neighbors_sum > 0 else -1)
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - (site_neighbors_sum if site_neighbors_sum > 0 else -1)
        
  return(priorities)




#score: {'data3D.txt': -0.002285}
#standard deviation: 0.04685634914288564
#island_id: 3
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors if val < 0]) - 2
          priorities[i * N * N + j * N + k][1] -= np.sum([val for val in site_neighbors]) - len(site_neighbors) * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] += np.sum([np.exp(-abs(val)) for val in site_neighbors if val > 0]) - 2
          priorities[i * N * N + j * N + k][1] -= np.sum([val for val in site_neighbors]) - len(site_neighbors) * h[i][j][k]
        
        return(priorities)




#score: {'data3D.txt': 0.30187859999999994}
#standard deviation: 0.044622730777486026
#island_id: 3
#version_generated: 3
#generate time23:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -sum([abs(val) for val in interacting_spins]) - sum([abs(val) for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2
        else:
          priorities[i * N * N + j * N + k][0] = sum([abs(val) for val in interacting_spins]) + sum([abs(val) for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': 0.1522122000000002}
#standard deviation: 0.0469669523299096
#island_id: 0
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - len([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + len([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.49074900000000005}
#standard deviation: 0.041539738070912297
#island_id: 0
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.43024219999999996}
#standard deviation: 0.04690970580977886
#island_id: 2
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum(1 for val in interacting_spins if val > 0)
        opposite_spin = len(interacting_spins) - same_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin - same_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (same_spin - opposite_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4380402}
#standard deviation: 0.038979940789590745
#island_id: 2
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin = sum(1 for val in interacting_spins if val > 0)
        opposite_spin = len(interacting_spins) - same_spin
        
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin - same_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (same_spin - opposite_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[0, i, j, (k - 1) % N], J[0, i, (j + 1) % N, k], J[0, (i + 1) % N, j, k]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.487491}
#standard deviation: 0.04337859286560596
#island_id: 2
#version_generated: 3
#generate time23:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.284755}
#standard deviation: 0.043774666817692626
#island_id: 0
#version_generated: 3
#generate time23:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.1522122000000002}
#standard deviation: 0.0469669523299096
#island_id: 0
#version_generated: 3
#generate time23:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - len([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + len([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.07398940000000005}
#standard deviation: 0.04639182177539486
#island_id: 0
#version_generated: 3
#generate time23:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -total_spin - sum([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = total_spin + sum([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.21028180000000002}
#standard deviation: 0.04576064235519429
#island_id: 2
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        same_spin_neighbors = [J[2, i, (j - 1) % N, k], J[2, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(site_nbrs)) * sum([1 for neighbor in site_nbrs if neighbor < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_nbrs)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-sum(site_nbrs)) * sum([1 for neighbor in site_nbrs if neighbor > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(site_nbrs)
        
        same_spin_neighbors_sum = sum(same_spin_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-same_spin_neighbors_sum) * (sum([1 for neighbor in same_spin_neighbors if neighbor < 0]) - len([neighbor for neighbor in same_spin_neighbors if neighbor > 0]))
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * same_spin_neighbors_sum)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-same_spin_neighbors_sum) * (sum([1 for neighbor in same_spin_neighbors if neighbor > 0]) - len([neighbor for neighbor in same_spin_neighbors if neighbor < 0]))
          priorities[i * N * N + j * N + k][1] = -(2 - 2 * same_spin_neighbors_sum)
        
  return(priorities)




#score: {'data3D.txt': -0.20355340000000002}
#standard deviation: 0.04464219202100183
#island_id: 2
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add new term based on the number of nearest neighbors with opposite spin
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3675998}
#standard deviation: 0.04176343041417934
#island_id: 2
#version_generated: 3
#generate time23:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        site_opposite_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_opposite_spin if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_opposite_spin if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.23981619999999998}
#standard deviation: 0.055739744685098805
#island_id: 2
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - (np.sum(J[:, i, j, k]) - h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) - (np.sum(J[:, i, j, k]) - h[i][j][k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
  
  return(priorities)




#score: {'data3D.txt': 0.1312442}
#standard deviation: 0.05772199794151273
#island_id: 2
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_magnetism = h[i][j][k]
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in interacting_spins]) - len([val for val in interacting_spins if val == 0]))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([1 if val < 0 else -1 for val in site_neighbors]) - len([val for val in site_neighbors if val == 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.0284338}
#standard deviation: 0.04374222419539272
#island_id: 2
#version_generated: 3
#generate time23:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(interacting_spins)
        
        site_magnetism = h[i][j][k]
        if site_magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= (len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0]))
        
        # Add new term based on the number of nearest neighbors with same spin
        site_same_spin = [J[2, i, j, (k - 1) % N], J[2, i, (j + 1) % N, k], J[2, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_same_spin if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_same_spin if val > 0])
        
        # Add new term based on the total spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        
  return(priorities)




