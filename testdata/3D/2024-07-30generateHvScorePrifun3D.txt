#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.5512286}
#standard deviation: 0.04480295104164457
#island_id: 2
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time00:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0296762}
#standard deviation: 0.045779744795706324
#island_id: 3
#version_generated: 3
#generate time00:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - (neighbor_spin > 0)
            priorities[i * N * N + j * N + k][1] -= 2 * (neighbor_spin < 0) - 2 * (neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - (neighbor_spin > 0)
            priorities[i * N * N + j * N + k][1] = 2 * (neighbor_spin < 0) - 2 * (neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': -0.0296762}
#standard deviation: 0.045779744795706324
#island_id: 3
#version_generated: 3
#generate time00:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - (neighbor_spin > 0)
            priorities[i * N * N + j * N + k][1] -= 2 * (neighbor_spin < 0) - 2 * (neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - (neighbor_spin > 0)
            priorities[i * N * N + j * N + k][1] = 2 * (neighbor_spin < 0) - 2 * (neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': -0.3581106}
#standard deviation: 0.04535639367983305
#island_id: 2
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3 - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 3 + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        if J[2, i, j, k - 1] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] += 4
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i * N * N + j * N + k][1] -= 4
  
  return(priorities)




#score: {'data3D.txt': 0.12999780000000014}
#standard deviation: 0.043180550658369336
#island_id: 2
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1], i, j, k] if val < 0]) - len([val for val in J[[0, 1], i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0, 1], i, j, k] if val < 0]) - len([val for val in J[[0, 1], i, j, k] if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [0, 1]:
          neighbor_spin = J[d, (i+d)%N, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if k > 0:
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.11903500000000031}
#standard deviation: 0.04799205199822154
#island_id: 2
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[range(3), i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[range(3), i, j, k] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0896598}
#standard deviation: 0.046355967727575276
#island_id: 2
#version_generated: 3
#generate time00:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] -= total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * total_neighbor_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1778122}
#standard deviation: 0.05289682685341344
#island_id: 2
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * total_neighbor_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.10947620000000018}
#standard deviation: 0.04627782183249338
#island_id: 2
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin
          priorities[i*N*N + j*N + k][1] += total_spin - 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] += total_spin - 2 * total_neighbor_spin
          priorities[i*N*N + j*N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1778122}
#standard deviation: 0.05289682685341344
#island_id: 2
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * total_neighbor_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.02328979999999998}
#standard deviation: 0.049896312248101066
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.04292420000000001}
#standard deviation: 0.04997975964688106
#island_id: 3
#version_generated: 3
#generate time00:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.0211246}
#standard deviation: 0.04459167674398441
#island_id: 3
#version_generated: 3
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
        # Add interaction with the neighbor sites along each axis
        for d in [0, 1, 2]:
          if d == 0:
            x, y, z = i, j, k
          elif d == 1:
            x, y, z = (i + 1) % N, j, k
          else:
            x, y, z = i, (j + 1) % N, k
          if d == 0:
            site_neighbors.append(J[3, x, y, z])
          elif d == 1:
            site_neighbors.append(J[4, x, y, z])
          else:
            site_neighbors.append(J[5, x, y, z])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2856422}
#standard deviation: 0.046581623191554844
#island_id: 2
#version_generated: 3
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        neighbor_spin = sum(val for val in site_neighbors if val > 0)

        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * neighbor_spin

        if J[2, i, j, k-1] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N + j*N + k][1] += 4
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 4
          priorities[i*N*N + j*N + k][1] -= 4

  return(priorities)




#score: {'data3D.txt': -0.1778122}
#standard deviation: 0.05289682685341344
#island_id: 2
#version_generated: 3
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * total_neighbor_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.1778122}
#standard deviation: 0.05289682685341344
#island_id: 2
#version_generated: 3
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(val for val in site_neighbors if val > 0)
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * total_neighbor_spin
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * total_neighbor_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.01645820000000031}
#standard deviation: 0.05073081521876029
#island_id: 2
#version_generated: 3
#generate time00:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += -total_spin - np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0]))
          priorities[i*N*N + j*N + k][1] += total_spin - 2 + 2 * sum(val > 0 for val in interacting_spins) + 2 * sum(val > 0 for val in site_neighbors)
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i*N*N + j*N + k][1] -= -2 + 2 * sum(val > 0 for val in interacting_spins) + 2 * sum(val > 0 for val in site_neighbors)
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.20398339999999995}
#standard deviation: 0.04469745053624424
#island_id: 0
#version_generated: 3
#generate time00:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3984962}
#standard deviation: 0.04390609599543098
#island_id: 1
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - len([val for val in interacting_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time00:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.04292420000000001}
#standard deviation: 0.04997975964688106
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': 0.02328979999999998}
#standard deviation: 0.049896312248101066
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.22348579999999998}
#standard deviation: 0.046113483043032005
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.02328979999999998}
#standard deviation: 0.049896312248101066
#island_id: 3
#version_generated: 3
#generate time00:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.04292420000000001}
#standard deviation: 0.04997975964688106
#island_id: 3
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.04292420000000001}
#standard deviation: 0.04997975964688106
#island_id: 3
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2295794}
#standard deviation: 0.045880706355068246
#island_id: 3
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.04292420000000001}
#standard deviation: 0.04997975964688106
#island_id: 3
#version_generated: 3
#generate time00:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (total_spin - sum([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.16598899999999997}
#standard deviation: 0.04577089030158797
#island_id: 3
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.2295794}
#standard deviation: 0.045880706355068246
#island_id: 3
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

  return priorities




#score: {'data3D.txt': -0.2295794}
#standard deviation: 0.045880706355068246
#island_id: 3
#version_generated: 3
#generate time00:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1393338}
#standard deviation: 0.04410283049374496
#island_id: 2
#version_generated: 3
#generate time00:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbor_spin) / len(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 * abs(site_neighbor_spin) / len(site_neighbors)
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(site_neighbor_spin) / len(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= 2 * abs(site_neighbor_spin) / len(site_neighbors)
          
  return(priorities)




#score: {'data3D.txt': -0.1728158}
#standard deviation: 0.04145822801760828
#island_id: 2
#version_generated: 3
#generate time00:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin_sum = sum(1 if val > 0 else -1 for val in site_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin_sum = sum(1 if val > 0 else -1 for val in site_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + neighbor_spin_sum
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time00:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 2
#version_generated: 3
#generate time00:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.4831134000000001}
#standard deviation: 0.04123801523400466
#island_id: 1
#version_generated: 3
#generate time00:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.48095299999999996}
#standard deviation: 0.040993288121349815
#island_id: 1
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
        neighbors_sum = sum(J[d, i, j, k] for d in range(6))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time00:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0020382000000000004}
#standard deviation: 0.046862709490169255
#island_id: 0
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.count_nonzero(J[2, i, :, k] < 0) - np.count_nonzero(J[2, i, :, k] > 0))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (np.count_nonzero(J[2, i, :, k] > 0) - np.count_nonzero(J[2, i, :, k] < 0))
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return priorities




#score: {'data3D.txt': -0.20673780000000003}
#standard deviation: 0.046295840970437076
#island_id: 3
#version_generated: 3
#generate time00:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22348579999999998}
#standard deviation: 0.046113483043032005
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.22348579999999998}
#standard deviation: 0.046113483043032005
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.22348579999999998}
#standard deviation: 0.046113483043032005
#island_id: 3
#version_generated: 3
#generate time00:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20398339999999995}
#standard deviation: 0.04469745053624424
#island_id: 0
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.002157}
#standard deviation: 0.046994739609875484
#island_id: 0
#version_generated: 3
#generate time00:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
        elif neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        return priorities




#score: {'data3D.txt': -0.3925374}
#standard deviation: 0.04157410878467511
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0365094}
#standard deviation: 0.04941657203449062
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add interaction with other neighboring sites
        for d in range(6):
          interacting_spins = [J[d, i, (j + 1) % N, k], J[d, (i + 1) % N, j, k], J[d, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
          
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.29796300000000003}
#standard deviation: 0.04521945102497376
#island_id: 1
#version_generated: 3
#generate time00:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0025782}
#standard deviation: 0.0469989332300213
#island_id: 0
#version_generated: 3
#generate time00:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        return priorities




#score: {'data3D.txt': -0.341695}
#standard deviation: 0.042963659702125005
#island_id: 0
#version_generated: 3
#generate time00:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[0][i][j][k], J[1][i][j][k]])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 2
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.14869020000000022}
#standard deviation: 0.04658246262232173
#island_id: 2
#version_generated: 3
#generate time00:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] < 0 for d in [0, 1, 2]]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, k] < 0 for d in [0, 1, 2]]) + total_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.1565278}
#standard deviation: 0.04542037017858838
#island_id: 0
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': 0.016623000000000002}
#standard deviation: 0.04706587374096013
#island_id: 0
#version_generated: 3
#generate time00:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + total_spin) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            elif neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + total_spin) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
  return priorities




#score: {'data3D.txt': -0.3925374}
#standard deviation: 0.04157410878467511
#island_id: 1
#version_generated: 3
#generate time00:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.3925374}
#standard deviation: 0.04157410878467511
#island_id: 1
#version_generated: 3
#generate time00:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1856522}
#standard deviation: 0.049734805068080847
#island_id: 1
#version_generated: 3
#generate time00:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in [total_spin]+site_neighbors if val > 0])
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.23982180000000008}
#standard deviation: 0.05053822993299232
#island_id: 1
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(6)] + \
                   [J[d, (i+1)%N, j, k] if i < N-1 else 0 for d in range(3)] + \
                   [J[d, i, j-1, k] if j > 0 else 0 for d in range(6)] + \
                   [J[d, i, (j+1)%N, k] if j < N-1 else 0 for d in range(3)] + \
                   [J[d, i, j, k-1] if k > 0 else 0 for d in range(6)] + \
                   [J[d, i, j, (k+1)%N] if k < N-1 else 0 for d in range(3)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.29796300000000003}
#standard deviation: 0.04521945102497376
#island_id: 1
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.29796300000000003}
#standard deviation: 0.04521945102497376
#island_id: 1
#version_generated: 3
#generate time00:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.39291260000000033}
#standard deviation: 0.04927542268961273
#island_id: 1
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i-1)%N, j, k] if i > 0 else 0 for d in range(6)] + \
                   [J[d, i, (j-1)%N, k] if j > 0 else 0 for d in range(6)] + \
                   [J[d, i, j, (k-1)%N] if k > 0 else 0 for d in range(6)]

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 2
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        
  return(priorities)




#score: {'data3D.txt': -0.0021030000000000003}
#standard deviation: 0.046980943274906685
#island_id: 2
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': -0.04672619999999985}
#standard deviation: 0.04855418203986142
#island_id: 2
#version_generated: 3
#generate time00:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.0296762}
#standard deviation: 0.045779744795706324
#island_id: 3
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - (neighbor_spin > 0)
            priorities[i * N * N + j * N + k][1] -= 2 * (neighbor_spin < 0) - 2 * (neighbor_spin > 0)
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0) - (neighbor_spin > 0)
            priorities[i * N * N + j * N + k][1] = 2 * (neighbor_spin < 0) - 2 * (neighbor_spin > 0)

  return(priorities)




#score: {'data3D.txt': -0.2775794}
#standard deviation: 0.04480158943207262
#island_id: 3
#version_generated: 3
#generate time00:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.46643940000000006}
#standard deviation: 0.045396821118223685
#island_id: 0
#version_generated: 2
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([1 if val < 0 else -1 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.35846659999999997}
#standard deviation: 0.04063465521497629
#island_id: 0
#version_generated: 2
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.36419460000000003}
#standard deviation: 0.04082322685481881
#island_id: 0
#version_generated: 2
#generate time00:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.22830060000000002}
#standard deviation: 0.0463578636224751
#island_id: 1
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0, i, j, k]
        site_down = J[2, i, j, k]
        site_left = J[1, i, (j+1)%N, k]
        site_right = J[1, (i+1)%N, j, k]
        site_front = J[0, i, (k+1)%N, k]
        site_back = J[0, i, j, (k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.0026298000000000007}
#standard deviation: 0.04748082341282636
#island_id: 1
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in [total_spin]+site_neighbors if val > 0])
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.3184810000000001}
#standard deviation: 0.048250416360897865
#island_id: 1
#version_generated: 3
#generate time00:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # added new logic here
        site_front_back = J[0, i, (k+1)%N, k]
        site_up_down = J[1, (i+1)%N, j, k]
        site_left_right = J[2, i, j, (k+1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_front_back * (2*total_spin - 1) + site_up_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left_right * (2*total_neighbor_spin - 1)

  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 2
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 2
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': 0.1986270000000003}
#standard deviation: 0.04638247374817343
#island_id: 2
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (1 + abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
  for d in [0, 1]:
    interacting_spins = np.zeros((N**3, 2))
    for i in range(N):
      for j in range(N):
        for k in range(N):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          interacting_spins[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * (1 - abs(neighbor_spin))
          interacting_spins[i * N * N + j * N + k][1] -= neighbor_spin
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += np.dot(interacting_spins[i * N * N + j * N + k], np.array([-1, 1]))
  return(priorities)




#score: {'data3D.txt': 0.2534262000000004}
#standard deviation: 0.044860416332887496
#island_id: 2
#version_generated: 3
#generate time01:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return(priorities)




#score: {'data3D.txt': -0.35846659999999997}
#standard deviation: 0.04063465521497629
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': 0.0024438000000000003}
#standard deviation: 0.06583570795214402
#island_id: 0
#version_generated: 3
#generate time01:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * interacting_spins[d][i, j, k]
  return(priorities)




#score: {'data3D.txt': -0.20673780000000003}
#standard deviation: 0.046295840970437076
#island_id: 3
#version_generated: 3
#generate time01:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20673780000000003}
#standard deviation: 0.046295840970437076
#island_id: 3
#version_generated: 3
#generate time01:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.09241540000000001}
#standard deviation: 0.04724218160542547
#island_id: 3
#version_generated: 3
#generate time01:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.20673780000000003}
#standard deviation: 0.046295840970437076
#island_id: 3
#version_generated: 3
#generate time01:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22348579999999998}
#standard deviation: 0.046113483043032005
#island_id: 3
#version_generated: 3
#generate time01:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22348579999999998}
#standard deviation: 0.046113483043032005
#island_id: 3
#version_generated: 3
#generate time01:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2916622}
#standard deviation: 0.0398846909372506
#island_id: 3
#version_generated: 3
#generate time01:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val for val in site_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, site_nbr, j, k]] if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4432202}
#standard deviation: 0.04570824380743588
#island_id: 1
#version_generated: 3
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        # Add the spin of the current site to its priority
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.2172654}
#standard deviation: 0.0545026722541198
#island_id: 1
#version_generated: 3
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4347622000000001}
#standard deviation: 0.046257539614207754
#island_id: 1
#version_generated: 3
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.30025060000000003}
#standard deviation: 0.05221850437957794
#island_id: 1
#version_generated: 3
#generate time01:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.35846659999999997}
#standard deviation: 0.04063465521497629
#island_id: 0
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.35846659999999997}
#standard deviation: 0.04063465521497629
#island_id: 0
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)

  return(priorities)




#score: {'data3D.txt': -0.35846659999999997}
#standard deviation: 0.04063465521497629
#island_id: 0
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.35846659999999997}
#standard deviation: 0.04063465521497629
#island_id: 0
#version_generated: 3
#generate time01:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4648442}
#standard deviation: 0.04437339300031045
#island_id: 1
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.025933400000000006}
#standard deviation: 0.05393495197402144
#island_id: 1
#version_generated: 3
#generate time01:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - 2 * sum([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.041605}
#standard deviation: 0.04575292881335576
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.13562900000000014}
#standard deviation: 0.04718474922048437
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.abs(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.abs(total_spin)

  return(priorities)




#score: {'data3D.txt': -0.0517526}
#standard deviation: 0.04520434175209279
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k]*(d%2==0)for d in[0,1,2]]
        total_spin=sum(interacting_spins)
        
        if h[i][j][k]>0:
          priorities[i*N*N+j*N+k][0]+=np.exp(-abs(total_spin))*np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1]-=total_spin
        else:
          priorities[i*N*N+j*N+k][0]+=np.exp(-abs(total_spin))*np.exp(abs(total_spin))
          priorities[i*N*N+j*N+k][1]+=total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.041605}
#standard deviation: 0.04575292881335576
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0422426}
#standard deviation: 0.04691739789502398
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.041605}
#standard deviation: 0.04575292881335576
#island_id: 2
#version_generated: 3
#generate time01:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0410282}
#standard deviation: 0.04743122731661073
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  total_spins = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0410282}
#standard deviation: 0.04743122731661073
#island_id: 2
#version_generated: 3
#generate time01:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
  return(priorities)




#score: {'data3D.txt': 0.14453780000000013}
#standard deviation: 0.045057572184484154
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for spin in site_neighbors:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += (1 - abs(total_spin)) / sum(abs(spin) for spin in interacting_spins)
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += (1 - abs(total_spin)) / sum(abs(spin) for spin in interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.09525139999999985}
#standard deviation: 0.0487407086329282
#island_id: 2
#version_generated: 3
#generate time01:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0025978}
#standard deviation: 0.04691705740090697
#island_id: 0
#version_generated: 3
#generate time01:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 2
#version_generated: 3
#generate time01:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4000886000000002}
#standard deviation: 0.048751257112406854
#island_id: 1
#version_generated: 3
#generate time01:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.27080220000000005}
#standard deviation: 0.04631316481476947
#island_id: 1
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Check the six nearest neighbors
        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[(d-1)%6, i, j, k], J[(d+1)%6, i, j, k]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= sum([val for val in [J[(d-1)%6, i, j, k], J[(d+1)%6, i, j, k]] if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[(d-1)%6, i, j, k], J[(d+1)%6, i, j, k]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3925374}
#standard deviation: 0.04157410878467511
#island_id: 1
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.0410282}
#standard deviation: 0.04743122731661073
#island_id: 2
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  total_spins = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0399974}
#standard deviation: 0.04737862591126932
#island_id: 2
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  # Calculate total spin at each site
  total_spins = np.sum(J, axis=0)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        
        # Add a new term based on the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0410282}
#standard deviation: 0.04743122731661073
#island_id: 2
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  total_spins = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 2
#version_generated: 3
#generate time01:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  # Calculate total spin at each site
  total_spins = np.sum(J, axis=0)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = J[[0, 1, 2], i, j, k]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
  
  return(priorities)




#score: {'data3D.txt': -0.4304962000000002}
#standard deviation: 0.04617920208881916
#island_id: 1
#version_generated: 3
#generate time01:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d < 3 else J[d-3, i, (j+1)%N, k] if d < 6 else J[d-6, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34986460000000014}
#standard deviation: 0.046805922988869694
#island_id: 1
#version_generated: 3
#generate time01:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.07184499999999999}
#standard deviation: 0.050338062884858814
#island_id: 1
#version_generated: 3
#generate time01:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(6)] +\
                   [J[d, (i+1)%N, j, k] if i < N-1 else 0 for d in range(3)] +\
                   [J[d, i, j-1, k] if j > 0 else 0 for d in range(6)] +\
                   [J[d, i, (j+1)%N, k] if j < N-1 else 0 for d in range(3)] +\
                   [J[d, i, j, k-1] if k > 0 else 0 for d in range(6)] +\
                   [J[d, i, j, (k+1)%N] if k < N-1 else 0 for d in range(3)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += total_spin
        priorities[i * N * N + j * N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0025298000000000005}
#standard deviation: 0.04766363553024465
#island_id: 2
#version_generated: 3
#generate time01:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= max(0, total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += min(0, total_spin)

  return(priorities)




#score: {'data3D.txt': 0.0001341999999999997}
#standard deviation: 0.04823159162167469
#island_id: 2
#version_generated: 3
#generate time01:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.sign(total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.sign(total_spin)
        
  return(priorities)




#score: {'data3D.txt': -0.25276380000000037}
#standard deviation: 0.045974604398080446
#island_id: 2
#version_generated: 3
#generate time01:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))

  return(priorities)




#score: {'data3D.txt': 0.023296599999999997}
#standard deviation: 0.04671531727859717
#island_id: 2
#version_generated: 3
#generate time01:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))

        if h[i][j][k] > 0:
          spin_priority = np.exp(-abs(total_spin)) * (1 - abs(total_spin))
        else:
          spin_priority = 1 - np.exp(-abs(total_spin)) * (1 - abs(total_spin))
        
        priorities[i * N * N + j * N + k][0] += spin_priority
        priorities[i * N * N + j * N + k][1] += 1 - spin_priority
  
  return(priorities)




#score: {'data3D.txt': -0.0624026}
#standard deviation: 0.04541961463112606
#island_id: 3
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.0624026}
#standard deviation: 0.04541961463112606
#island_id: 3
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.16598899999999997}
#standard deviation: 0.04577089030158797
#island_id: 3
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.16598899999999997}
#standard deviation: 0.04577089030158797
#island_id: 3
#version_generated: 3
#generate time01:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.36419460000000003}
#standard deviation: 0.04082322685481881
#island_id: 0
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.42941700000000005}
#standard deviation: 0.04309523861170744
#island_id: 0
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0,1,2], i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[[0,1,2], i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.31180220000000003}
#standard deviation: 0.045302936275257034
#island_id: 0
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1, 2]:
            if site_neighbors[d-1] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            else:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          for d in [0, 1, 2]:
            if site_neighbors[d-1] < 0:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
            else:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': -0.3328566}
#standard deviation: 0.03973398691850593
#island_id: 0
#version_generated: 3
#generate time01:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        interacting_spin_sum = sum([1 if val > 0 else -1 for val in interacting_spins])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) + neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * interacting_spin_sum
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * interacting_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.460891}
#standard deviation: 0.040366607969954574
#island_id: 0
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if sum(1 for val in site_neighbors if val < 0) > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          if sum(1 for val in site_neighbors if val < 0) > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.44494259999999997}
#standard deviation: 0.04158289390169953
#island_id: 0
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(1 if val > 0 else -1 for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + neighbor_spin) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.00025500000000000045}
#standard deviation: 0.04658974538458007
#island_id: 0
#version_generated: 3
#generate time01:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N)) 
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N**3):
    total_spin = sum(J[d, i//N%N, (i//100)%N, i%10] * interacting_spins[d, i//N%N, (i//100)%N, i%10] for d in [0, 1, 2])
    
    site_neighbors = [J[0, i//N%N, ((i+N-1)//100)%N, i%10], J[1, (i+N-1)//100%N, i//N%N, i%10], J[2, i//N%N, i//N%N, ((i+99)//1000)%10]]
    
    priorities[i][0] = total_spin
    priorities[i][1] = -total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0624026}
#standard deviation: 0.04541961463112606
#island_id: 3
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0624026}
#standard deviation: 0.04541961463112606
#island_id: 3
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0624026}
#standard deviation: 0.04541961463112606
#island_id: 3
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_site_neighbor_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1493106}
#standard deviation: 0.04598281991831297
#island_id: 3
#version_generated: 3
#generate time01:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        else:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0026298000000000007}
#standard deviation: 0.04748082341282636
#island_id: 1
#version_generated: 3
#generate time01:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in [total_spin]+site_neighbors if val > 0])
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.002129}
#standard deviation: 0.046426585045639526
#island_id: 1
#version_generated: 3
#generate time01:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.0026298000000000007}
#standard deviation: 0.04748082341282636
#island_id: 1
#version_generated: 3
#generate time01:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in [total_spin]+site_neighbors if val > 0])

        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]

        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)

  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.4000886000000002}
#standard deviation: 0.048751257112406854
#island_id: 1
#version_generated: 3
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4000886000000002}
#standard deviation: 0.048751257112406854
#island_id: 1
#version_generated: 3
#generate time01:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.1493106}
#standard deviation: 0.04598281991831297
#island_id: 3
#version_generated: 3
#generate time01:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        else:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3704946}
#standard deviation: 0.048129313841358684
#island_id: 3
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        for d in [0, 1, 2]:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
        
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          for d in [0, 1]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
        else:
          for d in [0, 1]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1493106}
#standard deviation: 0.04598281991831297
#island_id: 3
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        else:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.1384214}
#standard deviation: 0.04628598386164002
#island_id: 3
#version_generated: 3
#generate time01:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = np.array([J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]])
        total_site_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          for d in [0, 1]:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
        else:
          for d in [0, 1, 2]:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[site_nbr][j][k] > 0:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val < 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
          else:
            for d in [0, 1]:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, site_nbr, j, k])) * len([val for val in site_neighbors if val > 0]) - J[d, site_nbr, j, k]
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_site_neighbor_spin
  
  return priorities




#score: {'data3D.txt': -0.2335006}
#standard deviation: 0.039116813771573986
#island_id: 0
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
        # Add a new term based on the variance of neighbors
        neighbor_variance = np.var(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * neighbor_variance
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_variance
        
  return priorities




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.19538339999999998}
#standard deviation: 0.03990669623559435
#island_id: 0
#version_generated: 3
#generate time01:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.1443234}
#standard deviation: 0.0456467358355447
#island_id: 3
#version_generated: 2
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 3
#version_generated: 2
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 3
#version_generated: 2
#generate time01:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2517122}
#standard deviation: 0.04694471313321661
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0, i, j, k]
        site_down = J[2, i, j, k]
        site_left = J[1, i, (j+1)%N, k]
        site_right = J[1, (i+1)%N, j, k]
        site_front = J[0, i, (k+1)%N, k]
        site_back = J[0, i, j, (k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
        if i < N//2:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        elif i >= N//2:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22830060000000002}
#standard deviation: 0.0463578636224751
#island_id: 1
#version_generated: 3
#generate time01:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0, i, j, k]
        site_down = J[2, i, j, k]
        site_left = J[1, i, (j+1)%N, k]
        site_right = J[1, (i+1)%N, j, k]
        site_front = J[0, i, (k+1)%N, k]
        site_back = J[0, i, j, (k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 3
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 3
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 3
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.26891819999999994}
#standard deviation: 0.05058451372465688
#island_id: 3
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4000886000000002}
#standard deviation: 0.048751257112406854
#island_id: 1
#version_generated: 3
#generate time01:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3629934000000002}
#standard deviation: 0.04992982111363909
#island_id: 1
#version_generated: 3
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4000886000000002}
#standard deviation: 0.048751257112406854
#island_id: 1
#version_generated: 3
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43576380000000003}
#standard deviation: 0.04074919593758876
#island_id: 1
#version_generated: 3
#generate time01:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.25902499999999995}
#standard deviation: 0.04872056542159584
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.10710980000000012}
#standard deviation: 0.04718684036847562
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1256298}
#standard deviation: 0.052393615183149944
#island_id: 3
#version_generated: 3
#generate time01:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        
        # Additional improvements
        neighboring_spins = [J[3, i, j, k], J[4, (i + 1) % N, (j + 1) % N, k], J[5, i, (k + 1) % N, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in neighboring_spins if val < 0]) - len([val for val in neighboring_spins if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in neighboring_spins if val < 0]) - len([val for val in neighboring_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.0036549999999999894}
#standard deviation: 0.046586605532062536
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  # Define constants
  K = -np.log(2)  # constant for magnetic field

  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        # Calculate the priority for assigning spin to -1 and 1
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = K - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 - np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = K + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin

        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += (h[i][j][k] * total_spin + total_neighbor_spin) / np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k] * total_spin + total_neighbor_spin) / np.exp(-abs(total_spin))

        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += abs(avg_neighbor_spin - h[i][j][k]) / np.exp(-abs(total_spin))
        priorities[i * N * N + j * N + k][1] -= abs(avg_neighbor_spin - h[i][j][k]) / np.exp(-abs(total_spin))

  return priorities




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time01:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time02:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.2558618}
#standard deviation: 0.039178429534119916
#island_id: 0
#version_generated: 3
#generate time02:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor spin
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + total_neighbor_spin)

        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])

  return priorities




#score: {'data3D.txt': -0.22732060000000004}
#standard deviation: 0.05113480043610223
#island_id: 2
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] += min(total_spin, 0)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] += max(total_spin, 0)

  return(priorities)




#score: {'data3D.txt': 0.218467}
#standard deviation: 0.044700465668715356
#island_id: 2
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i+d % N if d == 0 else i-d % N if d == 1 else i, j, k] * h[(i+d) % N if d == 0 else (i-d) % N if d == 1 else i, (j+f) % N if f == 0 else (j-f) % N if f == 1 else j, k] for d in [0, 1, 2] for f in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= max(0, total_spin)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += min(0, total_spin)
  
  return(priorities)




#score: {'data3D.txt': -0.35793900000000006}
#standard deviation: 0.050236061141375334
#island_id: 3
#version_generated: 3
#generate time02:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.2927026}
#standard deviation: 0.04390183860887831
#island_id: 2
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022626}
#standard deviation: 0.04697962580991892
#island_id: 2
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i+d if d < 3 else i-d, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] -= 1
        
        return(priorities)




#score: {'data3D.txt': 0.2167018000000004}
#standard deviation: 0.04564796684147061
#island_id: 2
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1, 2] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1, 2] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for d in [0, 1, 2] if J[d, i+d if d == 0 else i-d, j, k] < 0) - sum(1 for d in [0, 1, 2] if J[d, i+d if d == 0 else i-d, j, k] > 0))
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.13630620000000007}
#standard deviation: 0.04501669158834311
#island_id: 2
#version_generated: 3
#generate time02:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          interacting_spins_pos = [(i+d) % N == i and (j+e) % N == j and (k+f) % N == k for d,e,f in itertools.product([-1, 0, 1], [-1, 0, 1], [-1, 0, 1]) if J[d][i][j][k] > 0]
          interacting_spins_neg = [(i+d) % N == i and (j+e) % N == j and (k+f) % N == k for d,e,f in itertools.product([-1, 0, 1], [-1, 0, 1], [-1, 0, 1]) if J[d][i][j][k] < 0]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(interacting_spins_pos) - len(interacting_spins_neg))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          interacting_spins_pos = [(i+d) % N == i and (j+e) % N == j and (k+f) % N == k for d,e,f in itertools.product([-1, 0, 1], [-1, 0, 1], [-1, 0, 1]) if J[d][i][j][k] > 0]
          interacting_spins_neg = [(i+d) % N == i and (j+e) % N == j and (k+f) % N == k for d,e,f in itertools.product([-1, 0, 1], [-1, 0, 1], [-1, 0, 1]) if J[d][i][j][k] < 0]
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(interacting_spins_pos) - len(interacting_spins_neg))
          priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': 0.09975780000000006}
#standard deviation: 0.04615998807582169
#island_id: 2
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] = priorities[i * N * N + j * N + k][0]
  return(priorities)




#score: {'data3D.txt': 0.33873099999999967}
#standard deviation: 0.04432097290222767
#island_id: 2
#version_generated: 3
#generate time02:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
  for d in [0, 1]:
    interacting_spins = np.zeros((N,N,N,2))
    for i in range(N):
      for j in range(N):
        for k in range(N):
          if h[i][j][k] > 0:
            interacting_spins[i,j,k,0] += J[d,i,j,k]
            interacting_spins[i,j,k,1] -= J[3-d,i,j,k]
          else:
            interacting_spins[i,j,k,0] -= J[d,i,j,k]
            interacting_spins[i,j,k,1] += J[3-d,i,j,k]
    for i in range(N):
      for j in range(N):
        for k in range(N):
          total_spin = sum(interacting_spins[i,j,k,:])
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          
  return(priorities)




#score: {'data3D.txt': 0.03610899999999968}
#standard deviation: 0.050348468089903196
#island_id: 3
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:2] + [J[2, i, j, k - 1]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:2] + [J[2, i, j, k - 1]] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.1304026}
#standard deviation: 0.04671340999370524
#island_id: 3
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_spin = J[2, i, j, k]
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.15177700000000022}
#standard deviation: 0.04666760065612974
#island_id: 3
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in J[0:3, i, j, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val for val in J[0:3, i, j, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 3
#version_generated: 3
#generate time02:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 3
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.0031249999999999997}
#standard deviation: 0.046920490353362675
#island_id: 3
#version_generated: 3
#generate time02:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if np.all([_ < 0 for _ in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors)
        elif np.all([_ > 0 for _ in site_neighbors]):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len(site_neighbors)
          priorities[i * N * N + j * N + k][1] += len(site_neighbors)
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        return priorities




#score: {'data3D.txt': -0.44226499999999996}
#standard deviation: 0.049231648103633514
#island_id: 3
#version_generated: 3
#generate time02:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (len([val for val in J[0, i, j, k:] if val < 0]) - len([val for val in J[0, i, j, k:] if val > 0])) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (len([val for val in J[0, i, j, k:] if val > 0]) - len([val for val in J[0, i, j, k:] if val < 0])) + sum(J[d, i, j, k] for d in [0, 1, 2])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return(priorities)




#score: {'data3D.txt': -0.3075786}
#standard deviation: 0.04332755776685319
#island_id: 0
#version_generated: 3
#generate time02:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 1.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 1.5 * total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.3075786}
#standard deviation: 0.04332755776685319
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 1.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 1.5 * total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.3792798}
#standard deviation: 0.03905132817152318
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.212943}
#standard deviation: 0.04486701762988043
#island_id: 0
#version_generated: 3
#generate time02:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.219031}
#standard deviation: 0.04302311424106814
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,site_nbr,k] if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        site_upper = (j + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,site_upper] if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        site_left = (i + ((j - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_left,j,k] if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46117020000000003}
#standard deviation: 0.041816835269541865
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4000886000000002}
#standard deviation: 0.048751257112406854
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.46117020000000003}
#standard deviation: 0.041816835269541865
#island_id: 1
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.1443234}
#standard deviation: 0.0456467358355447
#island_id: 3
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
  return(priorities)




#score: {'data3D.txt': -0.34133419999999964}
#standard deviation: 0.04454547553186518
#island_id: 3
#version_generated: 3
#generate time02:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val < 0]) - len([val for val in J[1:, i, j, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val > 0]) - len([val for val in J[1:, i, j, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] += 2
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3925374}
#standard deviation: 0.04157410878467511
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.4234398}
#standard deviation: 0.04211572884279696
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if h[site_nbr][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[d, site_nbr, j, k] for d in [0, 1, 2]] if val < 0])
            priorities[i * N * N + j * N + k][1] -= sum([val for val in [J[d, site_nbr, j, k] for d in [0, 1, 2]] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          if h[site_nbr][j][k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[d, site_nbr, j, k] for d in [0, 1, 2]] if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * sum([val for val in [J[d, site_nbr, j, k] for d in [0, 1, 2]] if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.3925374}
#standard deviation: 0.04157410878467511
#island_id: 1
#version_generated: 3
#generate time02:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.019661}
#standard deviation: 0.04822864459011885
#island_id: 1
#version_generated: 3
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.29796300000000003}
#standard deviation: 0.04521945102497376
#island_id: 1
#version_generated: 3
#generate time02:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.048084999999999996}
#standard deviation: 0.04676719635599295
#island_id: 3
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.30352100000000004}
#standard deviation: 0.04690770980340012
#island_id: 3
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.0593742}
#standard deviation: 0.04685726938651035
#island_id: 3
#version_generated: 3
#generate time02:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.11263299999999986}
#standard deviation: 0.05018675752626384
#island_id: 1
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val < 0]) - np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val > 0]) - np.sum(J[:, i, j, k])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.067691}
#standard deviation: 0.045479861026612646
#island_id: 1
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k] if i < N-1 else 0,
                   J[1, i, (j+1)%N, k] if j < N-1 else 0,
                   J[2, i, j, (k+1)%N] if k < N-1 else 0]
        total_spin = sum(J[d, i, j, k] for d in [3, 4, 5])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.0029286000000000004}
#standard deviation: 0.047178743328325314
#island_id: 1
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val > 0])
        
        # New logic to include all possible combinations of neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3996722}
#standard deviation: 0.04013501049158951
#island_id: 1
#version_generated: 3
#generate time02:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors + diagonals if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins + site_neighbors + diagonals if val > 0])

  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        spin_product = np.prod(np.sign([site_nbr] + site_neighbors))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  """Improved version of `priority_v1`."""
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.4643426}
#standard deviation: 0.03983030234934201
#island_id: 3
#version_generated: 3
#generate time02:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0012526000000000024}
#standard deviation: 0.04839427975742587
#island_id: 3
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbor = J[2, i, j, k]
        if site_neighbor < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0206482}
#standard deviation: 0.04716424532164169
#island_id: 3
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors.sort()
        site_neighbors = [neighbor for neighbor in site_neighbors if neighbor < 0]
        
        if len(site_neighbors) % 2 == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors) // 2)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) // 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((len(site_neighbors) - 1) // 2)
          priorities[i * N * N + j * N + k][1] -= (len(site_neighbors) - 1) // 2
        
  return(priorities)




#score: {'data3D.txt': 0.0171406}
#standard deviation: 0.04585401478213222
#island_id: 3
#version_generated: 3
#generate time02:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.212943}
#standard deviation: 0.04486701762988043
#island_id: 0
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.013115799999999997}
#standard deviation: 0.04653343131942883
#island_id: 0
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin with some weight
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          # Add a new term based on the local energy and neighbor spin with some weight
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.212943}
#standard deviation: 0.04486701762988043
#island_id: 0
#version_generated: 3
#generate time02:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.07184499999999999}
#standard deviation: 0.050338062884858814
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i-1)%N, j, k] if i > 0 else 0 for d in range(6)] +\
                   [J[d, (i+1)%N, j, k] if i < N-1 else 0 for d in range(3)] +\
                   [J[d, i, (j-1)%N, k] if j > 0 else 0 for d in range(6)] +\
                   [J[d, i, (j+1)%N, k] if j < N-1 else 0 for d in range(3)] +\
                   [J[d, i, j, (k-1)%N] if k > 0 else 0 for d in range(6)] +\
                   [J[d, i, j, (k+1)%N] if k < N-1 else 0 for d in range(3)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][0] += total_spin
        priorities[i * N * N + j * N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.26048180000000004}
#standard deviation: 0.045264649217242374
#island_id: 1
#version_generated: 3
#generate time02:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d-1)%N, j, k] if d % 2 == 0 else J[d, i, (j+d-1)%N, k] if d % 3 == 0 else J[d, i, j, (k+d-1)%N] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_left = [J[d, (i-1+d)%N, j, k] if i > 0 else 0 for d in range(3)]
        site_up = [J[d, i, (j-1+d)%N, k] if j > 0 else 0 for d in range(3)]
        site_front = [J[d, i, j, (k-1+d)%N] if k > 0 else 0 for d in range(3)]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins + site_left + site_up + site_front if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins + site_left + site_up + site_front if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.34986460000000014}
#standard deviation: 0.046805922988869694
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                 [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                 [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.3447650000000002}
#standard deviation: 0.05104022428438182
#island_id: 1
#version_generated: 3
#generate time02:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors.sort()
        spin_values = [J[d, i, j, k] for d in range(6)]
        spin_values.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        spin_values.sort()
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in spin_values if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in spin_values if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2911086000000004}
#standard deviation: 0.04597790519412557
#island_id: 1
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
        total_spin_neighbors = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin_neighbors
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin_neighbors
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin_neighbors
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin_neighbors
        
  return(priorities)




#score: {'data3D.txt': -0.2525862}
#standard deviation: 0.03992536248501696
#island_id: 0
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        
        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])
        
  return priorities




#score: {'data3D.txt': -0.2525862}
#standard deviation: 0.03992536248501696
#island_id: 0
#version_generated: 3
#generate time02:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)

        # Add a new term based on the difference between current spin and average of neighbors
        avg_neighbor_spin = sum(val for val in site_neighbors) / len(site_neighbors)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(avg_neighbor_spin - h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (avg_neighbor_spin - h[i][j][k])

  return priorities




#score: {'data3D.txt': -0.3792798}
#standard deviation: 0.03905132817152318
#island_id: 0
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        
  return priorities




#score: {'data3D.txt': -0.25276380000000037}
#standard deviation: 0.045974604398080446
#island_id: 2
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))

  return(priorities)




#score: {'data3D.txt': -0.13207660000000002}
#standard deviation: 0.0486317263978979
#island_id: 2
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  site_energy = np.zeros((N, N, N))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        site_energy[i, j, k] = h[i][j][k] + np.sum(interacting_spins[[0, 1, 2], i, j, k]) - total_spin

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if site_energy[i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy[i, j, k])
          priorities[i * N * N + j * N + k][1] -= np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-site_energy[i, j, k])
          priorities[i * N * N + j * N + k][1] += np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))

  return(priorities)




#score: {'data3D.txt': -0.25276380000000037}
#standard deviation: 0.045974604398080446
#island_id: 2
#version_generated: 3
#generate time02:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))

  return(priorities)




#score: {'data3D.txt': -0.25276380000000037}
#standard deviation: 0.045974604398080446
#island_id: 2
#version_generated: 3
#generate time02:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-np.abs(total_spin)) * (1 - np.abs(total_spin))
          priorities[i * N * N + j * N + k][1] += np.sum(np.where(interacting_spins[[0, 1, 2], i, j, k] > 0, 1, 0))

  return(priorities)




#score: {'data3D.txt': -0.3792798}
#standard deviation: 0.03905132817152318
#island_id: 0
#version_generated: 3
#generate time02:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the local energy and neighbor spin with some weight
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * (h[i][j][k] * total_spin + 0.5 * total_neighbor_spin)

  return priorities




#score: {'data3D.txt': -0.13777259999999997}
#standard deviation: 0.046554724027106004
#island_id: 2
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [3, 4]:
          if (i + (d - 2) % 2 == 0):
            neighbor_spin = J[d-2, i + d-2, j, k]
          else:
            neighbor_spin = J[5-d, i - d+1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2461102}
#standard deviation: 0.045203571274402644
#island_id: 2
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
        for d in [3, 4, 5]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
  return(priorities)




#score: {'data3D.txt': -0.2224558}
#standard deviation: 0.04416064363616092
#island_id: 2
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin)) * max(0, total_spin)
          priorities[i * N * N + j * N + k][1] -= min(max(total_spin, 0), 2) * (1 - abs(total_spin))
        
        for d in [0, 1, 2]:
          if i > 0 and j > 0 and k > 0:
            neighbor_spin = J[d, i-1, j-1, k-1]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
  return(priorities)




#score: {'data3D.txt': -0.1224918}
#standard deviation: 0.04861941847410354
#island_id: 2
#version_generated: 3
#generate time02:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = np.sum(J[[0, 1, 2], i, j, k], axis=0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(interacting_spins)) * (1 - abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= min(max(interacting_spins, 0), 2) * (1 - abs(interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(interacting_spins)) * (1 - abs(interacting_spins))
          priorities[i * N * N + j * N + k][1] -= min(max(interacting_spins, 0), 2) * (1 - abs(interacting_spins))
  
  return(priorities)




#score: {'data3D.txt': 0.2854862000000002}
#standard deviation: 0.044223361807533335
#island_id: 2
#version_generated: 3
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.12642219999999998}
#standard deviation: 0.04902263096937985
#island_id: 2
#version_generated: 3
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [3, 4, 5]:
          if (i + (d - 3) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - (d-3), i - (d-3), j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.2060730000000003}
#standard deviation: 0.04575855145216026
#island_id: 2
#version_generated: 3
#generate time02:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the magnetism at each site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * (1 - abs(h[i][j][k]))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': 0.0593742}
#standard deviation: 0.04685726938651035
#island_id: 3
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for spin in site_neighbors:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.048084999999999996}
#standard deviation: 0.04676719635599295
#island_id: 3
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.0012526000000000024}
#standard deviation: 0.04839427975742587
#island_id: 3
#version_generated: 3
#generate time02:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbor = J[2, i, j, k]
        if site_neighbor < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.34490020000000016}
#standard deviation: 0.045521077315459055
#island_id: 2
#version_generated: 3
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = []
        for d in [0, 1, 2]:
          if d % 2 == 0:
            neighbor_spin = J[d, i, j, k]
          else:
            if d == 1:
              neighbor_spin = J[2, i + 1, j, k] if i < N - 1 else J[0, i - 1, j, k]
            elif d == 2:
              neighbor_spin = J[1, i, j + 1, k] if j < N - 1 else J[3, i, j - 1, k]
          interacting_spins.append(neighbor_spin)
        
        total_spin = sum(interacting_spins)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (1 + abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.22884500000000013}
#standard deviation: 0.04547757265949888
#island_id: 2
#version_generated: 3
#generate time02:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] * (d % 2 == 0) for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * (1 + abs(total_spin))
          priorities[i * N * N + j * N + k][1] += total_spin
        
  for d in [3, 4, 5]:
    interacting_spins = np.zeros((N**3, 2))
    for i in range(N):
      for j in range(N):
        for k in range(N):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          interacting_spins[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * (1 - abs(neighbor_spin))
          interacting_spins[i * N * N + j * N + k][1] -= neighbor_spin
    for i in range(N):
      for j in range(N):
        for k in range(N):
          priorities[i * N * N + j * N + k][0] += np.dot(interacting_spins[i * N * N + j * N + k], np.array([-1, 1]))
  
  return(priorities)




#score: {'data3D.txt': -0.13910660000000014}
#standard deviation: 0.04494021847343424
#island_id: 1
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin)
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin)
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.025645799999999993}
#standard deviation: 0.055861087192785645
#island_id: 1
#version_generated: 3
#generate time02:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_x = [J[3, i, j, k], J[4, (i + 1) % N, j, k], J[5, i, (j + 1) % N, k]]
        total_neighbor_spin_x = sum(val for val in site_neighbors_x)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin_x) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr_x = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - abs(total_neighbor_spin_x) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin_x) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0012445999999999996}
#standard deviation: 0.04931477233892498
#island_id: 2
#version_generated: 3
#generate time02:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [h[(i+d) % N if d == 0 else (i-d) % N if d == 1 else i, (j+f) % N if f == 0 else (j-f) % N if f == 1 else j, k] for d in range(3) for f in [0, 1, 2]]
        interacting_spins.append(h[i,j,(k+2)%N])
        interacting_spins.append(h[i,(j+2)%N,k])
        interacting_spins.append(h[(i+2)%N,j,k])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(x) for x in interacting_spins)) * (1 - sum(abs(x) for x in interacting_spins))
          priorities[i * N * N + j * N + k][1] -= max(0, sum(x for x in interacting_spins))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-sum(abs(x) for x in interacting_spins)) * (1 - sum(abs(x) for x in interacting_spins))
          priorities[i * N * N + j * N + k][1] += min(0, sum(x for x in interacting_spins))
          
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        site_spin = J[2, i, j, k]
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the magnetic field
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k])
        priorities[i * N * N + j * N + k][1] -= 2 * (h[i][j][k])
        
        # Add a new term based on the interaction with neighboring sites
        for d in [0, 1]:
            for l in range(3):
                if l == 0:
                    site_nbr = (i + ((k - 1) % 2 - 1)) % N
                elif l == 1:
                    site_nbr = j
                else:
                    site_nbr = k
                priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, site_nbr, k]
                priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        return priorities




#score: {'data3D.txt': -0.14083779999999993}
#standard deviation: 0.047163051334280746
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_spin = J[2, i, j, k]
        if site_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.14880900000000016}
#standard deviation: 0.04727797498836007
#island_id: 3
#version_generated: 3
#generate time02:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(site_nbrs)
          priorities[i * N * N + j * N + k][1] -= np.sum([site_nbr > 0 for site_nbr in site_nbrs])
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum(site_nbrs)
          priorities[i * N * N + j * N + k][1] -= -np.sum([site_nbr < 0 for site_nbr in site_nbrs])
  
  return(priorities)




#score: {'data3D.txt': -0.3058602000000001}
#standard deviation: 0.04707090583322142
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val < 0]) - len([val for val in J[1:, i, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val > 0]) - len([val for val in J[1:, i, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0012526000000000024}
#standard deviation: 0.04839427975742587
#island_id: 3
#version_generated: 3
#generate time02:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          
        site_neighbor = J[2, i, j, k]
        if site_neighbor < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.0593742}
#standard deviation: 0.04685726938651035
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.04950499999999999}
#standard deviation: 0.04930698667531814
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
            priorities[i * N * N + j * N + k][1] -= 2
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2
        
        site_neighbor = J[2, i, j, k]
        if site_neighbor < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * -1
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.20860340000000002}
#standard deviation: 0.04757214172643482
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        interacting_spins.extend(site_neighbors)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2, 3])
        
        site_neighbor = J[2, i, j, k]
        if site_neighbor < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.07632820000000001}
#standard deviation: 0.04555283970028653
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = J[[0,1,2],i,(j+1)%N,k]+J[[0,1,2],i,j,(k+1)%N]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([-val for val in site_neighbors])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors])
          priorities[i*N*N+j*N+k][1] = len([val for val in site_neighbors if val < 0]) - 1
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': 0.03610899999999968}
#standard deviation: 0.050348468089903196
#island_id: 3
#version_generated: 3
#generate time02:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:2] + [J[2, i, j, k - 1]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:2] + [J[2, i, j, k - 1]] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] += 1
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.0435142}
#standard deviation: 0.04904366338641517
#island_id: 1
#version_generated: 3
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in [total_spin] + site_neighbors + interacting_spins + diagonals if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.29796300000000003}
#standard deviation: 0.04521945102497376
#island_id: 1
#version_generated: 3
#generate time02:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(3)] + [J[d, i, j-1, k] if j > 0 else 0 for d in range(3)] + [J[d, i, j, k-1] if k > 0 else 0 for d in range(3)]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.15979539999999992}
#standard deviation: 0.05074870026749455
#island_id: 1
#version_generated: 3
#generate time02:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3629934000000002}
#standard deviation: 0.04992982111363909
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (site_nbr + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4285574000000001}
#standard deviation: 0.048075435569945695
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,(j+1)%N,k] if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0044946000000000005}
#standard deviation: 0.04672831572868853
#island_id: 1
#version_generated: 3
#generate time02:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Additional improvement: consider the spins of the sites above and below the current site
        for d in range(6):
          if i > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d,i-1,j,k])) * len([val for val in interacting_spins[d,:,j,k] if val < 0])
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d,i-1,j,k]
          if i < N-1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d,i+1,j,k])) * len([val for val in interacting_spins[d,:,j,k] if val > 0])
            priorities[i * N * N + j * N + k][1] = -2 + 2 * J[d,i+1,j,k]
          
  return(priorities)




#score: {'data3D.txt': -0.39214980000000027}
#standard deviation: 0.048366283296941474
#island_id: 1
#version_generated: 3
#generate time02:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                 [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                 [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetization term
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] > 0) * len([val for val in interacting_spins + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k] > 0)
        
  return priorities




#score: {'data3D.txt': -0.0026298000000000007}
#standard deviation: 0.04748082341282636
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in [total_spin]+site_neighbors if val > 0])

        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]

        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)

  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.0026298000000000007}
#standard deviation: 0.04748082341282636
#island_id: 1
#version_generated: 3
#generate time03:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0,1,2]]
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k-1)%2-1))%N
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in [total_spin]+site_neighbors if val > 0])
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 2
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.16613499999999998}
#standard deviation: 0.043688617911304996
#island_id: 0
#version_generated: 2
#generate time03:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 0
#version_generated: 3
#generate time03:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4964102}
#standard deviation: 0.04169126354477638
#island_id: 2
#version_generated: 2
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 2
#version_generated: 2
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4808006}
#standard deviation: 0.04214355418851144
#island_id: 2
#version_generated: 2
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.32265220000000033}
#standard deviation: 0.045466772429544625
#island_id: 2
#version_generated: 2
#generate time03:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] -= h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.43576380000000003}
#standard deviation: 0.04074919593758876
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43576380000000003}
#standard deviation: 0.04074919593758876
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.43576380000000003}
#standard deviation: 0.04074919593758876
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.43576380000000003}
#standard deviation: 0.04074919593758876
#island_id: 1
#version_generated: 3
#generate time03:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.45718780000000003}
#standard deviation: 0.042994803071534124
#island_id: 3
#version_generated: 3
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        spin_product = np.prod(np.sign([site_nbr] + site_neighbors))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add another term based on the magnetization
        if sum(J[d, i, j, k] for d in [0, 1, 2]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:] if val < 0]) - len([val for val in J[0, i, j, k:] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:] if val > 0]) - len([val for val in J[0, i, j, k:] if val < 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
  
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time03:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        spin_product = np.prod(np.sign([site_nbr] + site_neighbors))
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * spin_product
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.18286420000000012}
#standard deviation: 0.04775610702685051
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2611318}
#standard deviation: 0.04019988592968891
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.2143102}
#standard deviation: 0.04865139891061715
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.25737620000000005}
#standard deviation: 0.0489263523426793
#island_id: 3
#version_generated: 3
#generate time03:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
          
        site_neighbors = [J[3, (i+1)%N, j, k], J[4, i, (j+1)%N, k], J[5, i, j, (k+1)%N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.4611218}
#standard deviation: 0.04010682242162797
#island_id: 0
#version_generated: 3
#generate time03:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum(val for val in interacting_spins)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.32265220000000033}
#standard deviation: 0.045466772429544625
#island_id: 2
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] -= h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
        
  return np.exp(priorities)




#score: {'data3D.txt': -0.26255580000000034}
#standard deviation: 0.04622549260267541
#island_id: 2
#version_generated: 3
#generate time03:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] += h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
          priorities[i * N * N + j * N + k][0] -= h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(3):
          if J[d, i, (j+1)%N, k] > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, (j+1)%N, k])) * len([val for val in [J[d, i, (j+1)%N, k]] if val < 0])
            priorities[i * N * N + j * N + k][1] += 2 - 2 * J[d, i, (j+1)%N, k]
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, (j+1)%N, k])) * len([val for val in [J[d, i, (j+1)%N, k]] if val > 0])
            priorities[i * N * N + j * N + k][1] += 2 + 2 * J[d, i, (j+1)%N, k]
        
  return priorities




#score: {'data3D.txt': -0.4624242}
#standard deviation: 0.042918889248907646
#island_id: 2
#version_generated: 3
#generate time03:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.3534830000000001}
#standard deviation: 0.049427607174533546
#island_id: 1
#version_generated: 3
#generate time03:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d < 3 else J[d-3, i, (j+1)%N, k] if d < 6 else J[d-6, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + abs(total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.27333140000000017}
#standard deviation: 0.04692232532643709
#island_id: 1
#version_generated: 3
#generate time03:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[3, (i + 1) % N, j, k], J[4, i, (j + 1) % N, k], J[5, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins + site_neighbors if val < 0]) - abs(total_neighbor_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins + site_neighbors if val > 0]) + abs(total_neighbor_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -sum([val for val in interacting_spins if val < 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3040666000000001}
#standard deviation: 0.05374961808645714
#island_id: 1
#version_generated: 3
#generate time03:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d < 3 else J[d-3, i, (j+1)%N, k] if d < 6 else J[d-6, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2441986}
#standard deviation: 0.05444234857204454
#island_id: 1
#version_generated: 3
#generate time03:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N, j, k] if d < 3 else J[d-3, i, (j+1)%N, k] if d < 6 else J[d-6, i, j, (k+1)%N] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= -np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val < 0 and J[d, i, j, k] > 0]) - J[d, i, j, k]
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(J[d, i, j, k])) * len([val for val in interacting_spins if val > 0 and J[d, i, j, k] < 0]) - J[d, i, j, k]

  return(priorities)




#score: {'data3D.txt': -0.07632820000000001}
#standard deviation: 0.04555283970028653
#island_id: 3
#version_generated: 3
#generate time03:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = J[[0,1,2],i,(j+1)%N,k]+J[[0,1,2],i,j,(k+1)%N]
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * sum([-val for val in site_neighbors])
          priorities[i*N*N+j*N+k][1] -= len([val for val in site_neighbors if val > 0]) + 1
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors])
          priorities[i*N*N+j*N+k][1] = len([val for val in site_neighbors if val < 0]) - 1
        
        priorities[i*N*N+j*N+k][0] += h[i][j][k]
        priorities[i*N*N+j*N+k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.3408634000000002}
#standard deviation: 0.05135579519820523
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i-1, j, k] if i > 0 else 0 for d in range(6)] +\
                  [J[d, (i+1)%N, j, k] if i < N-1 else 0 for d in range(3)] +\
                  [J[d, i, j-1, k] if j > 0 else 0 for d in range(6)] +\
                  [J[d, i, (j+1)%N, k] if j < N-1 else 0 for d in range(3)] +\
                  [J[d, i, j, k-1] if k > 0 else 0 for d in range(6)] +\
                  [J[d, i, j, (k+1)%N] if k < N-1 else 0 for d in range(3)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add more terms to the priority based on your specific problem requirements
  
  return(priorities)




#score: {'data3D.txt': -0.3656650000000002}
#standard deviation: 0.04565815825238684
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                   [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                   [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.24027940000000006}
#standard deviation: 0.04831050378168293
#island_id: 1
#version_generated: 3
#generate time03:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i-1)%N if d < 3 else (i+1)%N, j, k] if i > 0 or d > 2 else J[0, i, j, k] 
                   for d in range(6)] + \
                  [J[d, i, (j-1)%N if d < 3 else (j+1)%N, k] if j > 0 or d > 5 else J[0, i, j, k] 
                   for d in range(6)] + \
                  [J[d, i, j, (k-1)%N if d < 3 else (k+1)%N] if k > 0 or d > 5 else J[0, i, j, k] 
                   for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in interacting_spins if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.12212139999999991}
#standard deviation: 0.04865928834292586
#island_id: 1
#version_generated: 3
#generate time03:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.15314619999999993}
#standard deviation: 0.04854173570815119
#island_id: 1
#version_generated: 3
#generate time03:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors[0] += J[3, i, (j + 1) % N, k]
        site_neighbors[1] += J[4, (i + 1) % N, j, k]
        site_neighbors[2] += J[5, i, j, (k + 1) % N]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.12212139999999991}
#standard deviation: 0.04865928834292586
#island_id: 1
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.12212139999999991}
#standard deviation: 0.04865928834292586
#island_id: 1
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.12212139999999991}
#standard deviation: 0.04865928834292586
#island_id: 1
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.09464539999999988}
#standard deviation: 0.04883503884343701
#island_id: 1
#version_generated: 3
#generate time03:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - len([val for val in interacting_spins[:,i,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) - len([val for val in interacting_spins[:,i,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) - len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
        site_neighbors = [J[3, i, (j + 1) % N, k], J[4, (i + 1) % N, j, k], J[5, i, j, (k + 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.260679}
#standard deviation: 0.04474196999462585
#island_id: 3
#version_generated: 3
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        if sum([val for val in interacting_spins + site_neighbors if val > 0]) > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0])
        elif sum([val for val in interacting_spins + site_neighbors if val < 0]) < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.17266379999999998}
#standard deviation: 0.04080230152283079
#island_id: 3
#version_generated: 3
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time03:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.043678999999999996}
#standard deviation: 0.047724678301692094
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.023735799999999793}
#standard deviation: 0.04440971513486661
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if site_nbr > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[0, i, (j + 1) % N, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[0, i, (j + 1) % N, k]
            
          if site_neighbors[0] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[0, i, (j + 1) % N, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[0, i, (j + 1) % N, k]
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
          
          if site_nbr > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[0, i, (j + 1) % N, k]
            priorities[i * N * N + j * N + k][1] += 2 + 2 * J[0, i, (j + 1) % N, k]
            
          if site_neighbors[0] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[0, i, (j + 1) % N, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * J[0, i, (j + 1) % N, k]
        
  return(priorities)




#score: {'data3D.txt': 0.03740179999999999}
#standard deviation: 0.04906339446838142
#island_id: 3
#version_generated: 3
#generate time03:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] -= 4
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
            priorities[i * N * N + j * N + k][1] += 2
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.32012699999999994}
#standard deviation: 0.04554139030596234
#island_id: 2
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val > 0 for val in interacting_spins]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin if neighbor_spin < 0 else -neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 if neighbor_spin > 0 else 0
        
  return(priorities)




#score: {'data3D.txt': -0.4624242}
#standard deviation: 0.042918889248907646
#island_id: 2
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.2896526000000002}
#standard deviation: 0.04894439695450339
#island_id: 2
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin + sum([-2 if val > 0 else 2 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin + sum([-2 if val < 0 else 2 for val in site_neighbors])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.30780939999999996}
#standard deviation: 0.045673182849895626
#island_id: 2
#version_generated: 3
#generate time03:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
        neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.30780939999999996}
#standard deviation: 0.045673182849895626
#island_id: 2
#version_generated: 3
#generate time03:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
        neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.30780939999999996}
#standard deviation: 0.045673182849895626
#island_id: 2
#version_generated: 3
#generate time03:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])

        neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in neighbors])

  return priorities




#score: {'data3D.txt': -0.30780939999999996}
#standard deviation: 0.045673182849895626
#island_id: 2
#version_generated: 3
#generate time03:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
        neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.30780939999999996}
#standard deviation: 0.045673182849895626
#island_id: 2
#version_generated: 3
#generate time03:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val < 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val > 0 for val in interacting_spins]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in site_neighbors])
        
        neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in neighbors])
        priorities[i * N * N + j * N + k][1] -= sum([2 if val > 0 else 0 for val in neighbors])
        
  return(priorities)




#score: {'data3D.txt': 0.08290540000000002}
#standard deviation: 0.047088354938774404
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([spin * neighbor for spin, neighbor in zip(interacting_spins, site_neighbors)])
          priorities[i * N * N + j * N + k][1] -= len([neighbor for neighbor in site_neighbors if neighbor < 0])
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum([spin * neighbor for spin, neighbor in zip(interacting_spins, site_neighbors)])
          priorities[i * N * N + j * N + k][1] -= len([neighbor for neighbor in site_neighbors if neighbor > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  
  return priorities




#score: {'data3D.txt': -0.3648834000000004}
#standard deviation: 0.04459686137431646
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(site_nbrs) + np.sum([site_nbr > 0 for site_nbr in site_nbrs])
          priorities[i * N * N + j * N + k][1] -= 2 * np.sum([site_nbr > 0 for site_nbr in site_nbrs])
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum(site_nbrs) - np.sum([site_nbr < 0 for site_nbr in site_nbrs])
          priorities[i * N * N + j * N + k][1] -= -2 * np.sum([site_nbr < 0 for site_nbr in site_nbrs])
  
  return(priorities)




#score: {'data3D.txt': -0.0409114}
#standard deviation: 0.04504260594193013
#island_id: 3
#version_generated: 3
#generate time03:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbrs = [J[0,i,j,k], J[1,i,j,k], J[2,i,j,k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.sum(site_nbrs) - len([val for val in site_nbrs if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbrs if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += -np.sum(site_nbrs) - len([val for val in site_nbrs if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in site_nbrs if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4596958}
#standard deviation: 0.039532905564352336
#island_id: 0
#version_generated: 3
#generate time03:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': 0.043678999999999996}
#standard deviation: 0.047724678301692094
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return priorities




#score: {'data3D.txt': 0.243665}
#standard deviation: 0.050680560918363954
#island_id: 3
#version_generated: 3
#generate time03:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term to reduce the number of neighboring sites that have the same spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val == h[i][j][k]])
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.33996220000000005}
#standard deviation: 0.050321918595776935
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[2 - d, i, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin if neighbor_spin < 0 else -1)
          priorities[i * N * N + j * N + k][1] += (2 if neighbor_spin > 0 else -2)
  
  return priorities




#score: {'data3D.txt': -0.37461339999999993}
#standard deviation: 0.04508486952892289
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val > 0)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.31459339999999997}
#standard deviation: 0.04534250099454153
#island_id: 3
#version_generated: 3
#generate time03:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(1 for val in site_neighbors if val > 0)
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 1
#version_generated: 3
#generate time03:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3830734000000001}
#standard deviation: 0.05104447876548452
#island_id: 0
#version_generated: 2
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for d in range(3):
    interacting_spins[d] = np.roll(h, -1, axis=d)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 2
#generate time03:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.010445399999999999}
#standard deviation: 0.045333321727400476
#island_id: 3
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.append(np.roll(h, 1, axis=0))
  interacting_spins.append(np.roll(h, 1, axis=1))
  interacting_spins.append(np.roll(h, 1, axis=2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d][i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[5, i, j, k], J[4, i, j, k], J[3, i, j, k]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[5, i, j, k], J[4, i, j, k], J[3, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        for d in range(6):
          if interacting_spins[d][i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2754306000000002}
#standard deviation: 0.04579560921791519
#island_id: 3
#version_generated: 3
#generate time03:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in range(6):
          if h[i][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for neighbor in site_neighbors:
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        site_neighbor = J[2, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor
          priorities[i * N * N + j * N + k][1] -= site_neighbor
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor
          priorities[i * N * N + j * N + k][1] += site_neighbor
  
  return(priorities)




#score: {'data3D.txt': -0.36437020000000003}
#standard deviation: 0.0426653886887252
#island_id: 3
#version_generated: 3
#generate time03:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add another term that favors spins aligned with the local magnetism
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) * (total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) * (-total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.14416980000000001}
#standard deviation: 0.04657161633398609
#island_id: 0
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.004350199999999999}
#standard deviation: 0.04721808848269909
#island_id: 0
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4553094000000001}
#standard deviation: 0.04305410168195361
#island_id: 0
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_nbr_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_nbr_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time03:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3629934000000002}
#standard deviation: 0.04992982111363909
#island_id: 1
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (site_nbr + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3629934000000002}
#standard deviation: 0.04992982111363909
#island_id: 1
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (site_nbr + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3629934000000002}
#standard deviation: 0.04992982111363909
#island_id: 1
#version_generated: 3
#generate time03:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbors = [J[0, i, site_nbr, k], J[1, i, j, k], J[2, i, j, (site_nbr + 1) % N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,site_nbr,j,k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4553094000000001}
#standard deviation: 0.04305410168195361
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_nbr_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_nbr_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.3501358}
#standard deviation: 0.046544312631727626
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
        
  return priorities




#score: {'data3D.txt': -0.5094406000000001}
#standard deviation: 0.042321740886215924
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4553094000000001}
#standard deviation: 0.04305410168195361
#island_id: 0
#version_generated: 3
#generate time03:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_nbr_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_nbr_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.39214980000000027}
#standard deviation: 0.048366283296941474
#island_id: 1
#version_generated: 3
#generate time03:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,(i+1)%N if d<3 else (i-1)%N,j,k] if i>0 or d>2 else J[d,i,j,k] for d in range(6)] +\
                   [J[d,i,(j+1)%N if d<3 else (j-1)%N,k] if j>0 or d>2 else J[d,i,j,k] for d in range(6)] +\
                   [J[d,i,j,(k+1)%N if d<3 else (k-1)%N] if k>0 or d>2 else J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0,(i+1)%N if i<N-1 else 0,j,k], J[1,i,(j+1)%N if j<N-1 else 0,k], J[2,i,j,(k+1)%N if k<N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins+site_neighbors if val<0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins+site_neighbors if val>0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetization term
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k]>0) * len([val for val in interacting_spins+site_neighbors if val<0])
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k]>0)
        
  return(priorities)




#score: {'data3D.txt': -0.39214980000000027}
#standard deviation: 0.048366283296941474
#island_id: 1
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                   [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                   [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetization term
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] > 0) * len([val for val in interacting_spins + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k] > 0)
        
  return priorities




#score: {'data3D.txt': -0.39214980000000027}
#standard deviation: 0.048366283296941474
#island_id: 1
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[d, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetization term
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] > 0) * len([val for val in interacting_spins + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k] > 0)
        
  return priorities




#score: {'data3D.txt': -0.36646940000000006}
#standard deviation: 0.04840403561315937
#island_id: 1
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.37143420000000005}
#standard deviation: 0.048972045805336754
#island_id: 1
#version_generated: 3
#generate time04:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        # Add the spin of the current site to its priority
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the spin of the neighboring sites to its priority
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.25715580000000027}
#standard deviation: 0.04780277906523845
#island_id: 1
#version_generated: 3
#generate time04:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        # Add the spin of the current site to its priority
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add the energy of the current site to its priority
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0028694000000000002}
#standard deviation: 0.0469287061790542
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += neighbor_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return priorities




#score: {'data3D.txt': -0.4016782}
#standard deviation: 0.04465403637701748
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          total_spin += np.sign(neighbor_spin)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time04:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        for d in [0, 1, 2]:
          neighbor_spin = J[d, i, j, k]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0206482}
#standard deviation: 0.04716424532164169
#island_id: 3
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors.sort()
        site_neighbors = [neighbor for neighbor in site_neighbors if neighbor < 0]
        
        if len(site_neighbors) % 2 == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors) // 2)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) // 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((len(site_neighbors) - 1) // 2)
          priorities[i * N * N + j * N + k][1] -= (len(site_neighbors) - 1) // 2
        
        site_neighbors = [neighbor for neighbor in site_neighbors if neighbor > 0]
        
        if len(site_neighbors) % 2 == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors) // 2)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) // 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((len(site_neighbors) - 1) // 2)
          priorities[i * N * N + j * N + k][1] -= (len(site_neighbors) - 1) // 2
        
  return(priorities)




#score: {'data3D.txt': 0.0206482}
#standard deviation: 0.04716424532164169
#island_id: 3
#version_generated: 3
#generate time04:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        site_neighbors.sort()
        site_neighbors = [neighbor for neighbor in site_neighbors if neighbor < 0]
        
        if len(site_neighbors) % 2 == 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len(site_neighbors) // 2)
          priorities[i * N * N + j * N + k][1] -= len(site_neighbors) // 2
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * ((len(site_neighbors) - 1) // 2)
          priorities[i * N * N + j * N + k][1] -= (len(site_neighbors) - 1) // 2
        
  return(priorities)




#score: {'data3D.txt': -0.495081}
#standard deviation: 0.043493223828545986
#island_id: 2
#version_generated: 2
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(val < 0 for val in interacting_spins) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 2
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 2
#generate time04:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time04:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.021258199999999998}
#standard deviation: 0.046801852236423296
#island_id: 2
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6,N,N,N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        total_neighbor_spin = -2 * neighbor_spin

        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (1+total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] -= 2-2*total_spin-2*total_neighbor_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * (1+total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] = -2+2*total_spin+2*total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time04:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20775460000000032}
#standard deviation: 0.04507793494427179
#island_id: 3
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([1 if neighbor < 0 else -1 for neighbor in site_neighbors])
        priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][0]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.0032338}
#standard deviation: 0.046938570254748915
#island_id: 3
#version_generated: 3
#generate time04:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        interacting_spins.sort()
        
        for spin in interacting_spins:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= 1
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] += 1
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
        return priorities




#score: {'data3D.txt': -0.36171260000000016}
#standard deviation: 0.05033786250169945
#island_id: 1
#version_generated: 3
#generate time04:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[0, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[1, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[2, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_priority = np.exp(-abs(total_neighbor_spin)) * (len([val for val in site_neighbors if val < 0]) if h[i][j][k] > 0 else len([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][0] += site_priority
        priorities[i * N * N + j * N + k][1] -= site_priority
  
  return(priorities)




#score: {'data3D.txt': -0.08012100000000003}
#standard deviation: 0.06612855509535953
#island_id: 1
#version_generated: 3
#generate time04:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                   [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                   [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        spin_product = h[i][j][k]
        for d in range(6):
          spin_product *= J[d, i, j, k]

        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0015353999999997891}
#standard deviation: 0.053880079684796314
#island_id: 1
#version_generated: 3
#generate time04:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[0, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[1, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[2, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
   for j in range(N):
    for k in range(N):
     total_spin = sum(J[d, i, j, k]*interacting_spins[d,i,j,k] for d in [0,1,2])
     if h[i][j][k] > 0:
      priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
      priorities[i * N * N + j * N + k][1] -= np.exp(abs(total_spin))
     else:
      priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin))
      priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin))
  return(priorities)




#score: {'data3D.txt': -0.2159262000000004}
#standard deviation: 0.04798369174584215
#island_id: 3
#version_generated: 3
#generate time04:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in J[0:3, i, j, k] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (sum([val for val in J[0:3, i, j, k] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, (j+1)%N, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i+(d-1)%2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.22830060000000002}
#standard deviation: 0.0463578636224751
#island_id: 1
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]

        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

        site_up = J[0, i, j, k]
        site_down = J[2, i, j, k]
        site_left = J[1, i, (j+1)%N, k]
        site_right = J[1, (i+1)%N, j, k]
        site_front = J[0, i, (k+1)%N, k]
        site_back = J[0, i, j, (k-1)%N]

        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)

  return(priorities)




#score: {'data3D.txt': 0.0184958}
#standard deviation: 0.04517596952318788
#island_id: 1
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [
          J[0, (i+1)%N, j, k],
          J[1, i, (j+1)%N, k],
          J[2, i, j, (k+1)%N]
        ]

        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - 2 * abs(total_spin) + total_spin
          priorities[i*N*N+j*N+k][1] -= -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - 2 * abs(total_spin) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4047298000000002}
#standard deviation: 0.04543645399852414
#island_id: 1
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Calculate the energy of flipping this spin
        flipped_energy = sum(J[d, i, j, k] * (d == 3) for d in range(6)) if h[i][j][k] > 0 else sum(J[d, i, j, k] * (d != 3) for d in range(6))
        
        # Add the energy of flipping this spin to its priority
        priorities[i*N*N+j*N+k][0] += flipped_energy
        priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1133698}
#standard deviation: 0.04789143647835176
#island_id: 1
#version_generated: 3
#generate time04:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0, i, j, k]
        site_down = J[2, i, j, k]
        site_left = J[1, i, (j+1)%N, k]
        site_right = J[1, (i+1)%N, j, k]
        site_front = J[0, i, (k+1)%N, k]
        site_back = J[0, i, j, (k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
        site_up_left = J[0, i, (j+1)%N, k]
        site_up_right = J[0, (i+1)%N, j, k]
        site_down_left = J[2, i, (j+1)%N, k]
        site_down_right = J[2, (i+1)%N, j, k]
        
        priorities[i*N*N+j*N+k][0] += -site_up_left * (2*total_spin - 1) + site_up_right * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_down_left * (2*total_neighbor_spin - 1) - site_down_right * (2*total_neighbor_spin - 1)
        
  return(priorities)




#score: {'data3D.txt': -0.33832260000000003}
#standard deviation: 0.047701364857203
#island_id: 0
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          if site_neighbors_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          
          if site_nbr_neighbors_spin > 0:
            priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
          else:
            priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin)
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          if site_neighbors_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          
          if site_nbr_neighbors_spin < 0:
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
          else:
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3501358}
#standard deviation: 0.046544312631727626
#island_id: 0
#version_generated: 3
#generate time04:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
        
  return priorities




#score: {'data3D.txt': 0.18780060000000032}
#standard deviation: 0.046750625660412264
#island_id: 3
#version_generated: 3
#generate time04:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d,i,j,k] for d in [0,1,2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val < 0]) - len([val for val in J[1:, i, j, k] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= np.exp(abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val < 0]) - len([val for val in J[1:, i, j, k] if val > 0]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val > 0]) - len([val for val in J[1:, i, j, k] if val < 0]))
          priorities[i * N * N + j * N + k][1] += np.exp(abs(total_spin)) * (len([val for val in J[0, i, j, k:3] if val > 0]) - len([val for val in J[1:, i, j, k] if val < 0]))

  return priorities




#score: {'data3D.txt': -0.3501358}
#standard deviation: 0.046544312631727626
#island_id: 0
#version_generated: 3
#generate time04:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
        
  return priorities




#score: {'data3D.txt': -0.04191979999999999}
#standard deviation: 0.04875084171540015
#island_id: 0
#version_generated: 3
#generate time04:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        site_neighbors_sum = sum([val for val in site_neighbors])
        site_nbr_neighbors_sum = sum([val for val in site_nbr_neighbors])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_sum - 2 * site_nbr_neighbors_sum
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin + total_spin
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_sum - 2 * site_nbr_neighbors_sum - 4 * site_neighbors_spin - 4 * site_nbr_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_sum - 2 * site_nbr_neighbors_sum
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_sum - 2 * site_nbr_neighbors_sum - 4 * site_neighbors_spin - 4 * site_nbr_neighbors_spin
        
  return priorities




#score: {'data3D.txt': -0.37049220000000005}
#standard deviation: 0.04498995909266867
#island_id: 0
#version_generated: 3
#generate time04:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in site_nbr_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.2092946}
#standard deviation: 0.04952921532631019
#island_id: 0
#version_generated: 3
#generate time04:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        
        site_neighbors_spin = sum(val for val in site_neighbors)
        site_nbr_neighbors_spin = sum(val for val in site_nbr_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val < 0]) - len([val for val in site_nbr_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= (2 - 2 * total_spin) - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in site_neighbors if val > 0]) - len([val for val in site_nbr_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_neighbors_spin - 2 * site_nbr_neighbors_spin
        
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 3
#version_generated: 3
#generate time04:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the interaction with neighboring sites
        for d in [0, 1]:
          for l in range(3):
            if l == 0:
              site_nbr = (i + ((k - 1) % 2 - 1)) % N
            elif l == 1:
              site_nbr = j
            else:
              site_nbr = k
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, site_nbr, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return priorities




#score: {'data3D.txt': -0.0030638000000000006}
#standard deviation: 0.04694738639754081
#island_id: 3
#version_generated: 3
#generate time04:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for _ in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the interaction with neighboring sites
        for d in [0, 1]:
          for l in range(3):
            if l == 0:
              site_nbr = (i + ((k - 1) % 2 - 1)) % N
            elif l == 1:
              site_nbr = j
            else:
              site_nbr = k
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, site_nbr, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        return priorities




#score: {'data3D.txt': -0.31971420000000006}
#standard deviation: 0.04824758852378013
#island_id: 1
#version_generated: 3
#generate time04:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin] + site_neighbors if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        priorities[i*N*N+j*N+k][0] += -np.sum(J[3:, i, j, k] * interacting_spins[3:, i, j, k]) - np.sum(J[:3, i, (j+1)%N, k] * interacting_spins[:3, i, (j+1)%N, k])
        priorities[i*N*N+j*N+k][0] += -np.sum(J[:, i, j, (k+1)%N] * interacting_spins[:, i, j, (k+1)%N]) + np.sum(J[0, i, :k, k] * interacting_spins[0, i, :k, k])
  
  return priorities




#score: {'data3D.txt': -0.1133698}
#standard deviation: 0.04789143647835176
#island_id: 1
#version_generated: 3
#generate time04:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + abs(total_neighbor_spin) - total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0, i, j, k]
        site_down = J[2, i, j, k]
        site_left = J[1, i, (j+1)%N, k]
        site_right = J[1, (i+1)%N, j, k]
        site_front = J[0, i, (k+1)%N, k]
        site_back = J[0, i, j, (k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
        site_up_left = J[0, i, (j+1)%N, k]
        site_up_right = J[0, (i+1)%N, j, k]
        site_down_left = J[2, i, (j+1)%N, k]
        site_down_right = J[2, (i+1)%N, j, k]
        
        priorities[i*N*N+j*N+k][0] += -site_up_left * (2*total_spin - 1) + site_up_right * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_down_left * (2*total_neighbor_spin - 1) - site_down_right * (2*total_neighbor_spin - 1)

  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time04:22
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        total_neighbor_spin = -2 * neighbor_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  return(priorities)




#score: {'data3D.txt': -0.23021940000000002}
#standard deviation: 0.04569740981324871
#island_id: 1
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + abs(total_neighbor_spin) - total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        flipped_energy = sum(J[d, i, j, k] * (d == 3) for d in range(6)) if h[i][j][k] > 0 else sum(J[d, i, j, k] * (d != 3) for d in range(6))
        priorities[i * N * N + j * N + k][0] += flipped_energy
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.34234299999999995}
#standard deviation: 0.04383270275718805
#island_id: 1
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.22247820000000001}
#standard deviation: 0.04658003783553637
#island_id: 1
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) - abs(total_spin) - total_neighbor_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        # Calculate the energy of flipping this spin
        flipped_energy = sum(J[d, i, j, k] * (d == 3) for d in range(6)) if h[i][j][k] > 0 else sum(J[d, i, j, k] * (d != 3) for d in range(6))
        
        # Add the energy of flipping this spin to its priority
        priorities[i*N*N+j*N+k][0] += flipped_energy
        priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36251859999999997}
#standard deviation: 0.043697278336756865
#island_id: 1
#version_generated: 3
#generate time04:23
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        
        # Add the energy of flipping this spin to its priority
        priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] * (d == 3) for d in range(6))
        
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36663579999999996}
#standard deviation: 0.04215896818424284
#island_id: 0
#version_generated: 3
#generate time04:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*h[i][j][k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.44811660000000014}
#standard deviation: 0.047461461886882494
#island_id: 0
#version_generated: 3
#generate time04:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.21507099999999996}
#standard deviation: 0.048064016883735385
#island_id: 0
#version_generated: 3
#generate time04:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for d in range(3):
    interacting_spins[d] = np.roll(h, -1, axis=d)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] += 1
        else:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N + j*N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i*N*N + j*N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.33644380000000024}
#standard deviation: 0.052969701165477605
#island_id: 1
#version_generated: 3
#generate time04:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0015353999999997891}
#standard deviation: 0.053880079684796314
#island_id: 1
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[0, i, j, k] for d in range(6)] +\
                  [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[1, i, j, k] for d in range(6)] +\
                  [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[2, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
  
  return priorities




#score: {'data3D.txt': -0.2436301999999999}
#standard deviation: 0.05118573871656051
#island_id: 1
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[0, i, j, k] for d in range(6)] +\
                  [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[1, i, j, k] for d in range(6)] +\
                  [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[2, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[3, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[3, i, j, k] for d in range(3)] +\
                  [J[4, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[4, i, j, k] for d in range(3)] +\
                  [J[5, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[5, i, j, k] for d in range(3)]
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0015241999999997895}
#standard deviation: 0.0539100374175348
#island_id: 1
#version_generated: 3
#generate time04:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else J[0, i, j, k] for d in range(6)] +\
            [J[d, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else J[1, i, j, k] for d in range(6)] +\
            [J[d, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else J[2, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        spin_product = np.prod(np.sign(interacting_spins))
        priorities[i * N * N + j * N + k][0] += spin_product
        priorities[i * N * N + j * N + k][1] -= spin_product
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.15769420000000003}
#standard deviation: 0.04508080618578155
#island_id: 2
#version_generated: 3
#generate time04:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.07579300000000015}
#standard deviation: 0.0445424632345361
#island_id: 2
#version_generated: 3
#generate time04:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47937300000000005}
#standard deviation: 0.04114432878295623
#island_id: 1
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        spin_product = h[i][j][k]
        for d in range(6):
          spin_product *= J[d, i, j, k]

        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        for d in range(6):
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.08012100000000003}
#standard deviation: 0.06612855509535953
#island_id: 1
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        spin_product = h[i][j][k]
        for d in range(6):
          spin_product *= J[d, i, j, k]

        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.028636200000000007}
#standard deviation: 0.06671882140415851
#island_id: 1
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                  [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        site_neighbors = [J[d, i, j, k] for d in range(6)]
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        spin_product = h[i][j][k]
        for d in range(6):
          spin_product *= J[d, i, j, k]
        
        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.21497420000000012}
#standard deviation: 0.059872673018331164
#island_id: 1
#version_generated: 3
#generate time04:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N if d < 3 else (i-1)%N, j, k] if i > 0 or d > 2 else 0 for d in range(6)] +\
                   [J[1, i, (j+1)%N if d < 3 else (j-1)%N, k] if j > 0 or d > 2 else 0 for d in range(6)] +\
                   [J[2, i, j, (k+1)%N if d < 3 else (k-1)%N] if k > 0 or d > 2 else 0 for d in range(6)]
        site_neighbors = [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]]
        
        total_spin = sum(J[d, i, j, k] for d in range(3))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        total_neighbor_spin = sum(J[d, i, j, k] for d in range(3))
        
        spin_product = h[i][j][k]
        for d in range(6):
          spin_product *= J[d, i, j, k]

        if spin_product > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        if h[i][j][k] != 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.15769420000000003}
#standard deviation: 0.04508080618578155
#island_id: 2
#version_generated: 3
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        total_neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.248577}
#standard deviation: 0.04260289557060647
#island_id: 2
#version_generated: 3
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] = 2
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.15769420000000003}
#standard deviation: 0.04508080618578155
#island_id: 2
#version_generated: 3
#generate time04:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        total_neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] -= 2
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (J[1, i, j, k] + J[2, i, j, k])
          priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time04:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = 0
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in range(6):
          if h[i][j][k] > 0:
            total_spin += J[d, i, j, k]
          else:
            total_spin -= J[d, i, j, k]
        
        site_neighbor = J[2, i, j, k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - sum([val for val in interacting_spins[3:,i,j,k] if val < 0]) / len(interacting_spins[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] -= np.exp(-abs(total_spin)) * (2 - sum([val for val in interacting_spins[3:,i,j,k] if val > 0]) / len(interacting_spins[3:, i, j, k]))
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - sum([val for val in interacting_spins[3:,i,j,k] if val > 0]) / len(interacting_spins[3:, i, j, k]))
          priorities[i * N * N + j * N + k][1] += np.exp(-abs(total_spin)) * (2 - sum([val for val in interacting_spins[3:,i,j,k] if val < 0]) / len(interacting_spins[3:, i, j, k]))
  
  return priorities




#score: {'data3D.txt': -0.45349940000000016}
#standard deviation: 0.04819027868398356
#island_id: 0
#version_generated: 3
#generate time04:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=d) for d in range(3)]
  interacting_spins += [np.roll(h, 1, axis=d) for d in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d][i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr_neighbors = [J[0, i, (j+2)%N, k], J[1, (i+1)%N, (j+1)%N, k], J[2, (i+1)%N, j, (k+2)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 2*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        diagonals = [J[3, i-1, j-1, k], J[4, (i+1) % N, (j+1) % N, k], J[5, i, j, (k+1) % N]]
        priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors + diagonals if val < 0])
        priorities[i*N*N+j*N+k][1] -= sum([val for val in interacting_spins + site_neighbors + diagonals if val > 0])
  
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.002129}
#standard deviation: 0.046426585045639526
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.002129}
#standard deviation: 0.046426585045639526
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0,1,2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin]+site_neighbors if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        priorities[i*N*N+j*N+k][0] += -site_up * (2*total_spin - 1) + site_down * (2*total_spin - 1)
        priorities[i*N*N+j*N+k][0] -= -site_left * (2*total_neighbor_spin - 1) - site_right * (2*total_neighbor_spin - 1)
        priorities[i*N*N+j*N+k][0] += -site_front * (2*total_spin - 1) + site_back * (2*total_spin - 1)
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.0021486000000000005}
#standard deviation: 0.04722765416617684
#island_id: 1
#version_generated: 3
#generate time04:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_spin = 2*h[i][j][k] - 1
        
        site_up = J[0,i,j,k]
        site_down = J[2,i,j,k]
        site_left = J[1,i,(j+1)%N,k]
        site_right = J[1,(i+1)%N,j,k]
        site_front = J[0,i,(k+1)%N,k]
        site_back = J[0,i,j,(k-1)%N]
        
        total_spin = site_spin + sum([site_up, site_down, site_left, site_right, site_front, site_back])
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in [total_spin]+[site_up, site_down, site_left, site_right, site_front, site_back] if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [total_spin]+[site_up, site_down, site_left, site_right, site_front, site_back] if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
  return np.sort(priorities, axis=0)[::-1]




#score: {'data3D.txt': -0.2387282}
#standard deviation: 0.05533364911841619
#island_id: 2
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * interacting_spins[d][i, j, k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': 0.0522385999999999}
#standard deviation: 0.05064605483194126
#island_id: 2
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (1 + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * (1 + total_neighbor_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(J[d, i, j, k] for d in [0, 1, 2]) + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1, 2]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.05651939999999998}
#standard deviation: 0.04652722841132921
#island_id: 2
#version_generated: 3
#generate time04:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(6):
          if (d < 3 and i == N-1) or (d >= 3 and i == 0):
            site_neighbors.append(J[d, i, j, k])
          elif (d % 2 == 0 and j == N-1) or (d % 2 == 1 and j == 0):
            site_neighbors.append(J[(d+1)%6, i, j, k])
          else:
            site_neighbors.append(J[d, i, (j+1)%N if d < 3 else j-1, k])
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k-1)%2-1))%N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.39214980000000027}
#standard deviation: 0.048366283296941474
#island_id: 1
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,(i+1)%N if d<3 else (i-1)%N,j,k] if i>0 or d>2 else J[d,i,j,k] for d in range(6)] +\
                  [J[d,i,(j+1)%N if d<3 else (j-1)%N,k] if j>0 or d>2 else J[d,i,j,k] for d in range(6)] +\
                  [J[d,i,j,(k+1)%N if d<3 else (k-1)%N] if k>0 or d>2 else J[d,i,j,k] for d in range(6)]
        
        total_spin = sum(J[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0,(i+1)%N if i<N-1 else 0,j,k], J[1,i,(j+1)%N if j<N-1 else 0,k], J[2,i,j,(k+1)%N if k<N-1 else 0]]
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins+site_neighbors if val<0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins+site_neighbors if val>0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the magnetization term
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k]>0) * len([val for val in interacting_spins+site_neighbors if val<0])
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k]>0)
        
  return(priorities)




#score: {'data3D.txt': -0.4177942000000002}
#standard deviation: 0.047408279512760214
#island_id: 1
#version_generated: 3
#generate time04:42
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + 1) % N if d < 3 else (i - 1) % N, j, k] if i > 0 or d > 2 else J[d, i, j, k] for d in range(6)]
        total_spin = sum(J[d, i, j, k] for d in range(6))

        site_neighbors = [J[0, (i + 1) % N if i < N - 1 else 0, j, k], J[1, i, (j + 1) % N if j < N - 1 else 0, k], J[2, i, j, (k + 1) % N if k < N - 1 else 0]]
        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins + site_neighbors if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add the magnetization term
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] > 0) * len([val for val in interacting_spins + site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= (h[i][j][k] > 0)

  return priorities




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.15123419999999999}
#standard deviation: 0.0505150154940093
#island_id: 2
#version_generated: 3
#generate time04:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_neighbors[0] += J[3, i, (j + 1) % N, k]
        site_neighbors[1] += J[4, (i + 1) % N, j, k]
        site_neighbors[2] += J[5, i, j, (k + 1) % N]
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * total_neighbor_spin
        priorities[i * N * N + j * N + k][1] += 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3405218000000001}
#standard deviation: 0.04714687354173128
#island_id: 0
#version_generated: 3
#generate time04:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]

    for i in range(3):
      for j in range(N):
        for k in range(N):
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i+1 if i==2 else i, j, k]] if val < 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
      for l in range(N):
        for m in range(N):
          total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
          if h[i][j][k] > 0:
            priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i+1 if i==2 else i, l, m]] if val < 0]) + total_spin) 
            priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
          else:
            priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i+1 if i==2 else i, l, m]] if val > 0]) + total_spin) 
            priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
          priorities[i*N*N + j*N + k][0] += h[i][j][k]
          priorities[i*N*N + j*N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.4850998}
#standard deviation: 0.045314679298876205
#island_id: 0
#version_generated: 3
#generate time04:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        for d in range(6):
          priorities[i*N*N + j*N + k][0] += -J[d, i, j, k]*interacting_spins[d, i, j, k]
          priorities[i*N*N + j*N + k][1] -= J[d, i, j, k]*interacting_spins[d, i, j, k]
  
  return(priorities)




#score: {'data3D.txt': 0.0008197999999999309}
#standard deviation: 0.05540449700123629
#island_id: 0
#version_generated: 3
#generate time04:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2*interacting_spins[d, i, j, k] - 1) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin) 
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.09748220000000003}
#standard deviation: 0.046234371663947164
#island_id: 1
#version_generated: 3
#generate time04:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, i, (j + 1) % N, k], 
                  J[1, (i + 1) % N, j, k], 
                  J[2, i, j, (k + 1) % N]]
        
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]) - np.exp(-abs(total_neighbor_spin)) * abs(total_neighbor_spin) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_neighbor_spin)) * len([val for val in [J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val > 0]) - np.exp(-abs(total_neighbor_spin)) * abs(total_neighbor_spin) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.37438099999999996}
#standard deviation: 0.044761075042943285
#island_id: 1
#version_generated: 3
#generate time04:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        
        # Add the energy of flipping this spin to its priority
        priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] * (d == 3) for d in range(6))
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
        
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.18330419999999994}
#standard deviation: 0.04712780222289176
#island_id: 1
#version_generated: 3
#generate time04:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + 1) % N, j, k] if d == 0 else J[d, i, (j + 1) % N, k] if d == 1 else J[d, i, j, (k + 1) % N] for d in range(3)]
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        site_neighbors = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - np.exp(-abs(total_spin)) * abs(total_neighbor_spin) - total_spin
        
        # Add the energy of flipping this spin to its priority
        priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in range(6))
        
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3070345999999999}
#standard deviation: 0.045606714887612754
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*h[i][j][k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[3:, i, j, k] if val < 0]) - total_spin
          priorities[i*N*N + j*N + k][1] -= 2 + 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[3:, i, j, k] if val > 0]) - total_spin
          priorities[i*N*N + j*N + k][1] = 2 - 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.21827060000000034}
#standard deviation: 0.04643167900948661
#island_id: 0
#version_generated: 3
#generate time04:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))
  for d in range(3):
    interacting_spins[d] = np.roll(h, -1, axis=d)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] += 2 - 2*total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 2
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1-d, i+d, j, k])
          else:
            site_neighbors.append(J[d, i-d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
  return(priorities)




#score: {'data3D.txt': -0.20715139999999999}
#standard deviation: 0.043200664787014564
#island_id: 2
#version_generated: 3
#generate time04:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 2
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 2
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.1803014}
#standard deviation: 0.04506609011263347
#island_id: 1
#version_generated: 2
#generate time04:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val > 0 else -val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.20715139999999999}
#standard deviation: 0.043200664787014564
#island_id: 2
#version_generated: 3
#generate time04:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.09738859999999999}
#standard deviation: 0.043233835708158024
#island_id: 2
#version_generated: 3
#generate time04:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        site_neighbors.extend([J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.20715139999999999}
#standard deviation: 0.043200664787014564
#island_id: 2
#version_generated: 3
#generate time04:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.29562700000000003}
#standard deviation: 0.04049809317733367
#island_id: 2
#version_generated: 3
#generate time04:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        spin_energy = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        anti_spin_energy = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] = spin_energy
        priorities[i * N * N + j * N + k][1] = anti_spin_energy
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': 0.0035489999999999996}
#standard deviation: 0.046203403327027756
#island_id: 2
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (2 * interacting_spins[d][i,j,k] - 1) for d in range(6))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.074725}
#standard deviation: 0.05128576815257816
#island_id: 2
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0035489999999999996}
#standard deviation: 0.046203403327027756
#island_id: 2
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k] * (2 * interacting_spins[d][i,j,k] - 1) for d in range(6))
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0043289999999999995}
#standard deviation: 0.04698339492842125
#island_id: 2
#version_generated: 3
#generate time05:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * interacting_spins[d][i, j, k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i*N*N+k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i*N*N+k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+k][1] -= 1
        else:
          priorities[i*N*N+k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i*N*N+k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2792382000000001}
#standard deviation: 0.0471541126600851
#island_id: 3
#version_generated: 2
#generate time05:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': 0.0065834000000000005}
#standard deviation: 0.047047595522406886
#island_id: 3
#version_generated: 2
#generate time05:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in interacting_spins if val < 0]) + site_neighbors_spin
        priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.22624860000000002}
#standard deviation: 0.05209260291097
#island_id: 3
#version_generated: 2
#generate time05:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_neighbor_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin - site_neighbors.count(min(site_neighbors))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.49545540000000005}
#standard deviation: 0.04219110250799332
#island_id: 3
#version_generated: 2
#generate time05:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 if val < 0 else -1 for val in site_neighbors)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.2792382000000001}
#standard deviation: 0.0471541126600851
#island_id: 3
#version_generated: 3
#generate time05:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.07016700000000009}
#standard deviation: 0.05087635748557477
#island_id: 2
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.10987259999999995}
#standard deviation: 0.050522795342696554
#island_id: 2
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        for d in range(3):
          site_nbr = [(i+1)%N if d==0 else (j+1)%N if d==1 else (k+1)%N if d==2 else i,j,k][d]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, site_nbr, i % N, k]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * J[d, site_nbr, i % N, k]
  
  return(priorities)




#score: {'data3D.txt': -0.1886626000000003}
#standard deviation: 0.04719480947350038
#island_id: 0
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] += -2 + 2 * total_spin
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        else:
          priorities[i * N * N + j * N + k][1] -= -2 + 2 * total_spin
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
  return(priorities)




#score: {'data3D.txt': -0.14416980000000001}
#standard deviation: 0.04657161633398609
#island_id: 0
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10591020000000001}
#standard deviation: 0.04207965275474597
#island_id: 0
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the contribution from the diagonal neighbors
        if i < N-1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[3, i+1, j, k])) * (h[i+1][j][k] > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[3, i+1, j, k]
        if j < N-1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[4, i, j+1, k])) * (h[i][j+1][k] > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[4, i, j+1, k]
        if k < N-1:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[5, i, j, k+1])) * (h[i][j][k+1] > 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[5, i, j, k+1]
        
  return(priorities)




#score: {'data3D.txt': -0.14416980000000001}
#standard deviation: 0.04657161633398609
#island_id: 0
#version_generated: 3
#generate time05:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time05:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.014048200000000123}
#standard deviation: 0.04976910725299381
#island_id: 2
#version_generated: 3
#generate time05:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.43219779999999997}
#standard deviation: 0.04827261454655217
#island_id: 2
#version_generated: 3
#generate time05:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = total_spin + np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) + np.sum([h[i, j, k] for h_val in [val for val in site_neighbors if val > 0]])
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin - 2 * np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) - 2 * np.sum([h[i, j, k] for h_val in [val for val in site_neighbors if val > 0]])
        
  return(priorities)




#score: {'data3D.txt': -0.07016700000000009}
#standard deviation: 0.05087635748557477
#island_id: 2
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.18849100000000002}
#standard deviation: 0.04870580416131121
#island_id: 2
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        site_neighbor_spin = [J[(d+3)%6, i, j, k] if d==0 else J[d%6, i, (j + 1) % N, k] if d==1 else J[d%6, (i + 1) % N, j, k] for d in range(3)]
        neighbor_spin += sum(val for val in site_neighbor_spin if val < 0)

        total_neighbor_spin = -2 * neighbor_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.07016700000000009}
#standard deviation: 0.05087635748557477
#island_id: 2
#version_generated: 3
#generate time05:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4432406000000002}
#standard deviation: 0.05039589101940753
#island_id: 0
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr_neighbors = [J[0, i, (j+2)%N, k], J[1, (i+1)%N, (j+1)%N, k], J[2, (i+1)%N, j, (k+2)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 2*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.4432406000000002}
#standard deviation: 0.05039589101940753
#island_id: 0
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=d) for d in range(3)]
  interacting_spins += [np.roll(h, 1, axis=d) for d in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[d][i, j, k] for d in range(6))
        
        site_neighbors = [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]]
        site_nbr_neighbors = [J[0, i, (j+2)%N, k], J[1, (i+1)%N, (j+1)%N, k], J[2, (i+1)%N, j, (k+2)%N]]
        
        if h[i][j][k] > 0:
          priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
          priorities[i*N*N + j*N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i*N*N + j*N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_spin
          priorities[i*N*N + j*N + k][1] = -2 + 2*total_spin
        
        priorities[i*N*N + j*N + k][0] += h[i][j][k]
        priorities[i*N*N + j*N + k][1] -= 2*h[i][j][k]
        
  return priorities




#score: {'data3D.txt': -0.023556999999999998}
#standard deviation: 0.05505276478979053
#island_id: 0
#version_generated: 3
#generate time05:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*interacting_spins[d,i,j,k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[:,i,j,k] if val < 0]) - total_spin
        priorities[i*N*N + j*N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.06129300000000014}
#standard deviation: 0.046601846647960216
#island_id: 2
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1-d, i+d, j, k])
          else:
            site_neighbors.append(J[d, i-d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.06129300000000014}
#standard deviation: 0.046601846647960216
#island_id: 2
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1-d, i+d, j, k])
          else:
            site_neighbors.append(J[d, i-d, j, k])
        
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.06129300000000014}
#standard deviation: 0.046601846647960216
#island_id: 2
#version_generated: 3
#generate time05:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1-d, i+d, j, k])
          else:
            site_neighbors.append(J[d, i-d, j, k])

        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        magnetism = h[i][j][k]

        if magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if magnetism > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.074725}
#standard deviation: 0.05128576815257816
#island_id: 2
#version_generated: 3
#generate time05:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.06293380000000004}
#standard deviation: 0.050466953717853834
#island_id: 2
#version_generated: 3
#generate time05:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        for d in range(3):
          if i == 0:
            neighbor_spin = J[d, N-1, j, k]
          elif i == N-1:
            neighbor_spin = J[1-d, 0, j, k]
          else:
            neighbor_spin = J[1-d, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.074725}
#standard deviation: 0.05128576815257816
#island_id: 2
#version_generated: 3
#generate time05:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.074725}
#standard deviation: 0.05128576815257816
#island_id: 2
#version_generated: 3
#generate time05:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.27246980000000015}
#standard deviation: 0.047500223662210246
#island_id: 3
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the global energy
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2792382000000001}
#standard deviation: 0.0471541126600851
#island_id: 3
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return priorities




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': 0.0065834000000000005}
#standard deviation: 0.047047595522406886
#island_id: 3
#version_generated: 3
#generate time05:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors_spin = sum(val for val in site_neighbors)

        priorities[i * N * N + j * N + k][0] += -total_spin + len([val for val in interacting_spins if val < 0]) + site_neighbors_spin
        priorities[i * N * N + j * N + k][1] -= 2 + 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += -h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.4553094000000001}
#standard deviation: 0.04305410168195361
#island_id: 0
#version_generated: 3
#generate time05:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0])
        
        site_nbr_neighbors = [J[0, i, (j + 2) % N, k], J[1, (i + 1) % N, (j + 1) % N, k], J[2, (i + 1) % N, j, (k + 2) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_nbr_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_nbr_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:26
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)

        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1

          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1

          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2

        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.16747379999999998}
#standard deviation: 0.05384592717708555
#island_id: 3
#version_generated: 3
#generate time05:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] -= h[i][j][k]
        priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] -= 2
          priorities[i * N * N + j * N + k][1] += 2
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += 2
          priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': 0.2974898}
#standard deviation: 0.04589801363850074
#island_id: 2
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        site_spin = sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        
        priorities[i * N * N + j * N + k][0] = total_spin + np.exp(-abs(total_spin)) * (1 - np.sign(total_spin))
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin - 2 * site_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4247194000000001}
#standard deviation: 0.046083682401040826
#island_id: 2
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        interacting_spins = [J[l, i, j, k] for l in range(6)]
        priorities[i * N * N + j * N + k][0] = total_spin + np.sum([val for val in interacting_spins if val < 0]) - h[i][j][k]
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin - 2 * np.sum([val for val in interacting_spins if val < 0]) - 2 * h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.13603659999999998}
#standard deviation: 0.04456823869573488
#island_id: 2
#version_generated: 3
#generate time05:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        spin_values = [J[l, i, j, k] for l in range(6)]
        neighbor_spin_sum = sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (neighbor_spin_sum - 1) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.055711399999999994}
#standard deviation: 0.0573540250552653
#island_id: 2
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        neighbor_spin_sum = np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0])
        h_val = h[i][j][k]
        
        priorities[i * N * N + j * N + k][0] = total_spin - abs(h_val) + neighbor_spin_sum
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.28158659999999996}
#standard deviation: 0.05451561189641
#island_id: 2
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = total_spin + np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) + np.sum([h[i, j, k] for h_val in [val for val in site_neighbors if val > 0]])
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin - 2 * np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) - 2 * np.sum([h[i, j, k] for h_val in [val for val in site_neighbors if val > 0]])
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] > 0])
          priorities[i * N * N + j * N + k][1] -= np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] > 0])
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0])
          priorities[i * N * N + j * N + k][1] += np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.440481}
#standard deviation: 0.0480364573943583
#island_id: 2
#version_generated: 3
#generate time05:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        edge_neighbors = []
        for d in range(6):
          if (i + (d // 3) % 2 == 0 and j == N-1 or i == N-1):
            edge_neighbors.append(J[d, i, (j+1)%N, k])
          elif (i + (d // 3) % 2 == 0 and k == N-1 or j == N-1):
            edge_neighbors.append(J[d, i, j, (k+1)%N])
          elif (i == N-1 and k == N-1):
            edge_neighbors.append(J[4, i, j, k])
        
        priorities[i * N * N + j * N + k][0] = total_spin + np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) + np.sum([h[i, j, k] for h_val in [val for val in site_neighbors + edge_neighbors if val > 0]])
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin - 2 * np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) - 2 * np.sum([h[i, j, k] for h_val in [val for val in site_neighbors + edge_neighbors if val > 0]])
        
  return(priorities)




#score: {'data3D.txt': -0.43219779999999997}
#standard deviation: 0.04827261454655217
#island_id: 2
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        site_neighbors.sort()
        
        priorities[i * N * N + j * N + k][0] = total_spin + np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) + np.sum([h[i, j, k] for h_val in [val for val in site_neighbors if val > 0]])
        priorities[i * N * N + j * N + k][1] = -2 - 2 * total_spin - 2 * np.sum([J[l, i, j, k] for l in range(6) if J[l, i, j, k] < 0]) - 2 * np.sum([h[i, j, k] for h_val in [val for val in site_neighbors if val > 0]])
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 1
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 1
#version_generated: 3
#generate time05:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1803014}
#standard deviation: 0.04506609011263347
#island_id: 1
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val > 0 else -val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.1803014}
#standard deviation: 0.04506609011263347
#island_id: 1
#version_generated: 3
#generate time05:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val > 0 else -val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.1803014}
#standard deviation: 0.04506609011263347
#island_id: 1
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val > 0 else -val for val in site_neighbors])

  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time05:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)

        total_neighbor_spin = sum(site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1

          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1

          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2

        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] -= 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          # Add a new term based on the local energy
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * h[i][j][k]
          priorities[i * N * N + j * N + k][1] += 1
          
          # Add a new term based on the total spin of the site's neighbors
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the site's own spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.24034860000000038}
#standard deviation: 0.04465519676409454
#island_id: 3
#version_generated: 3
#generate time05:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          site_neighbors.append(neighbor_spin)
        
        total_neighbor_spin = sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        if total_neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] -= 2
        elif total_neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
          priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 3
#version_generated: 3
#generate time05:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.026642999999999993}
#standard deviation: 0.05635775963432187
#island_id: 2
#version_generated: 3
#generate time05:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        for d in range(3):
          if i == 0:
            neighbor_spin = J[d, N-1, j, k]
          elif i == N-1:
            neighbor_spin = J[1-d, 0, j, k]
          else:
            neighbor_spin = J[1-d, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.17144180000000012}
#standard deviation: 0.047222300375564095
#island_id: 0
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * sum(interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2*h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.26559900000000025}
#standard deviation: 0.04703737704209279
#island_id: 0
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6) for i in range(N) for j in range(N) for k in range(N)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k]*interacting_spins[(i+d)%N*N*N + j*N + k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[(i+1)%N*N*N + j*N + k:(i+2)%N*N*N + j*N + k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins[(i+1)%N*N*N + j*N + k:(i+2)%N*N*N + j*N + k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2*h[i][j][k]

  return(priorities)




#score: {'data3D.txt': -0.0030834000000000005}
#standard deviation: 0.04675945214007538
#island_id: 0
#version_generated: 3
#generate time05:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in range(6)]
        total_spin = sum(J[d, (i+d)%N, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the contribution from the diagonal neighbors
        for d in range(6):
          if i < N-1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, (i+d)%N, j, k])) * (h[(i+d)%N][j][k] > 0)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, (i+d)%N, j, k]
          if j < N-1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, (j+d)%N, k])) * (h[i][(j+d)%N][k] > 0)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i, (j+d)%N, k]
          if k < N-1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[d, i, j, (k+d)%N])) * (h[i][j][(k+d)%N] > 0)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i, j, (k+d)%N]
        
  return priorities




#score: {'data3D.txt': -0.07016700000000009}
#standard deviation: 0.05087635748557477
#island_id: 2
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2387282}
#standard deviation: 0.05533364911841619
#island_id: 2
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d,i,j,k]*(2*interacting_spins[d][i,j,k]-1) for d in range(6))
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        total_neighbor_spin = -2*neighbor_spin

        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*(1+total_neighbor_spin)+total_spin
          priorities[i*N*N+j*N+k][1] -= 2-2*total_spin-2*total_neighbor_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin))*(1+total_neighbor_spin)+total_spin
          priorities[i*N*N+j*N+k][1] = -2+2*total_spin+2*total_neighbor_spin

        site_nbr = (i+((k-1)%2-1))%N
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*1
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin))*1
          priorities[i*N*N+j*N+k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.07016700000000009}
#standard deviation: 0.05087635748557477
#island_id: 2
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i, j, k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.074725}
#standard deviation: 0.05128576815257816
#island_id: 2
#version_generated: 3
#generate time05:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)

        total_neighbor_spin = -2 * neighbor_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.29562700000000003}
#standard deviation: 0.04049809317733367
#island_id: 2
#version_generated: 3
#generate time05:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        spin_energy = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        anti_spin_energy = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] = spin_energy
        priorities[i * N * N + j * N + k][1] = anti_spin_energy
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
  
  return priorities




#score: {'data3D.txt': -0.49866299999999997}
#standard deviation: 0.04316936773917357
#island_id: 1
#version_generated: 3
#generate time05:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        for d in [0, 1]:
          if site_nbr == i:
            neighbor_spin = site_neighbors[d]
          else:
            neighbor_spin = site_neighbors[1 - d]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.13603659999999998}
#standard deviation: 0.04456823869573488
#island_id: 2
#version_generated: 3
#generate time05:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        spin_values = [J[l, i, j, k] for l in range(6)]
        neighbor_spin_sum = sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (neighbor_spin_sum - 1) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.2582542}
#standard deviation: 0.04541917461117056
#island_id: 2
#version_generated: 3
#generate time05:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = []
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if (i + 1) % N != 0:
          site_neighbors.append(J[0, i+1, j, k])
        else:
          site_neighbors.append(0)
        if (j + 1) % N != 0:
          site_neighbors.append(J[1, i, j+1, k])
        else:
          site_neighbors.append(0)
        if (k + 1) % N != 0:
          site_neighbors.append(J[2, i, j, k+1])
        else:
          site_neighbors.append(0)
        
        spin_values = [J[l, i, j, k] for l in range(6)]
        neighbor_spin_sum = sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (neighbor_spin_sum - 1) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13603659999999998}
#standard deviation: 0.04456823869573488
#island_id: 2
#version_generated: 3
#generate time05:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        spin_values = [J[l, i, j, k] for l in range(6)]
        neighbor_spin_sum = sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (neighbor_spin_sum - 1) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.474419}
#standard deviation: 0.041874951928330614
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.3164509999999999}
#standard deviation: 0.04538277116924438
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) - sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) - sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]))
          priorities[i * N * N + j * N + k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.2099978}
#standard deviation: 0.045299542990630715
#island_id: 1
#version_generated: 3
#generate time05:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, j, (k - 1) % N], J[1, i, (j - 1) % N, k], J[2, (i - 1) % N, j, k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.0018566000000000004}
#standard deviation: 0.047007890789100504
#island_id: 0
#version_generated: 2
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i, j, k if d == (i + 1) % N else k-1])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.1750798000000002}
#standard deviation: 0.04429834931416745
#island_id: 0
#version_generated: 2
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          if total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          if total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          if total_neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          elif total_neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
  
  return(priorities)




#score: {'data3D.txt': -0.22291539999999999}
#standard deviation: 0.04503605758545036
#island_id: 0
#version_generated: 2
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[2, i, j, k-1] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors_spin - total_spin)
          priorities[i * N * N + j * N + k][1] -= total_site_neighbors_spin - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.27213619999999994}
#standard deviation: 0.04676514395957739
#island_id: 0
#version_generated: 2
#generate time05:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])

        neighbor_spin = J[2, i, j, k - 1]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1

  return(priorities)




#score: {'data3D.txt': -0.32027059999999974}
#standard deviation: 0.0450178828427104
#island_id: 3
#version_generated: 2
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': 0.4429350000000001}
#standard deviation: 0.043616647911090094
#island_id: 3
#version_generated: 2
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 3
        priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.3377218}
#standard deviation: 0.04770995540513531
#island_id: 3
#version_generated: 2
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.001288999999999997}
#standard deviation: 0.05273403947167332
#island_id: 3
#version_generated: 2
#generate time05:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)

  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.1803014}
#standard deviation: 0.04506609011263347
#island_id: 1
#version_generated: 3
#generate time05:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val > 0 else -val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5080262000000001}
#standard deviation: 0.04300012736678811
#island_id: 1
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1803014}
#standard deviation: 0.04506609011263347
#island_id: 1
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val if val < 0 else -val for val in site_neighbors]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val if val > 0 else -val for val in site_neighbors])
        
  return(priorities)




#score: {'data3D.txt': -0.5085262000000002}
#standard deviation: 0.04238415781350386
#island_id: 1
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % N) % N, (j + d // 3) % N, (k + d % 3) % N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = [0, 1, 2]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[interacting_spins, i, j, k] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in J[interacting_spins, i, j, k] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
  
  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time05:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time05:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.4879326000000001}
#standard deviation: 0.042077327591471404
#island_id: 1
#version_generated: 3
#generate time05:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.0025886000000000004}
#standard deviation: 0.04701342861396093
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        return(priorities)




#score: {'data3D.txt': -0.3149361999999998}
#standard deviation: 0.045994757631277916
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i, j, k if d == (i + 1) % N else k-1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k-1]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (neighbor_spin < 0)
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(abs(total_spin)) * sum(1 for val in interacting_spins if val > 0) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k-1]
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (neighbor_spin > 0)
          priorities[i * N * N + j * N + k][1] += (neighbor_spin > 0)
          
  return(priorities)




#score: {'data3D.txt': 0.0536726}
#standard deviation: 0.04870542607595174
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i if d == (i + 1) % N else i-1, j, k if d == (j + 1) % N else k-1])
        
        site_neighbors.sort()
        for spin in interacting_spins:
          if spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) + len([val for val in site_neighbors if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0018566000000000004}
#standard deviation: 0.047007890789100504
#island_id: 0
#version_generated: 3
#generate time05:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i, j, k if d == (i + 1) % N else k-1])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 0
#version_generated: 3
#generate time06:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.46795700000000007}
#standard deviation: 0.04228414585870218
#island_id: 1
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % N) % N, (j + d // 3) % N, (k + d % 3) % N] 
                    for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.46795700000000007}
#standard deviation: 0.04228414585870218
#island_id: 1
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i + d % N) % N, (j + d // 3) % N, (k + d % 3) % N] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= sum(1 for val in site_neighbors if val > 0)
        
  return(priorities)




#score: {'data3D.txt': -0.4558138}
#standard deviation: 0.04675906425026061
#island_id: 1
#version_generated: 3
#generate time06:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[site_nbr, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.29562700000000003}
#standard deviation: 0.04049809317733367
#island_id: 2
#version_generated: 3
#generate time06:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        spin_energy = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        anti_spin_energy = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] = spin_energy
        priorities[i * N * N + j * N + k][1] = anti_spin_energy
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.29562700000000003}
#standard deviation: 0.04049809317733367
#island_id: 2
#version_generated: 3
#generate time06:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        spin_energy = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        anti_spin_energy = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] = spin_energy
        priorities[i * N * N + j * N + k][1] = anti_spin_energy
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
        
  return priorities




#score: {'data3D.txt': -0.29562700000000003}
#standard deviation: 0.04049809317733367
#island_id: 2
#version_generated: 3
#generate time06:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[1 - d, i + d, j, k])
          else:
            site_neighbors.append(J[d, i - d, j, k])
        
        spin_energy = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        anti_spin_energy = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] = spin_energy
        priorities[i * N * N + j * N + k][1] = anti_spin_energy
        
        for d in range(6):
          if d < 3:
            site_neighbors[d] += -J[d, i, j, k]
          else:
            if (i + ((d - 3) % 2 - 1)) % N == i:
              site_neighbors[d-3] -= J[(d+1)%6, i, j, k]
            elif (j + ((d - 3) % 2 - 1)) % N == j:
              site_neighbors[d-3] -= J[0 if d==4 else 1 if d==5 else 2, i, j, k]
            elif (k + ((d - 3) % 2 - 1)) % N == k:
              site_neighbors[d-3] -= J[0 if d==6 else 2, i, j, k]
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + sum(val for val in site_neighbors if val < 0))
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * sum(val for val in site_neighbors if val < 0)
  
  return priorities




#score: {'data3D.txt': -0.140667}
#standard deviation: 0.0421628864168477
#island_id: 3
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors with sign changed
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': 0.13181779999999993}
#standard deviation: 0.050144864175307134
#island_id: 3
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the total spin of the site's neighbors
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.4000394}
#standard deviation: 0.039117953009328084
#island_id: 3
#version_generated: 3
#generate time06:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        if (i + (2 - 1) % 2 == 0):
          neighbor_spin = J[2, i + 2, j, k]
        else:
          neighbor_spin = J[0, i - 2, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.31187739999999997}
#standard deviation: 0.04639366647765618
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+d)%N, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15853180000000025}
#standard deviation: 0.05277241579423857
#island_id: 1
#version_generated: 3
#generate time06:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val < 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(interacting_spins)
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(sum(interacting_spins))) * len([val for val in interacting_spins if val > 0]) + sum(interacting_spins)
          priorities[i * N * N + j * N + k][1] += 2
        site_nbr_x = (i + ((j - 1) % 2 - 1)) % N
        site_nbr_y = (k + ((N-1) % 2 - 1)) % (N-1)
        if h[i][site_nbr_x][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, site_nbr_x, k])) * len([val for val in [J[0, i, site_nbr_x, k], J[1, i, j, k], J[2, i, j, site_nbr_y]] if val < 0]) + sum([J[0, i, site_nbr_x, k], J[1, i, j, k], J[2, i, j, site_nbr_y]])
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(J[0, i, site_nbr_x, k])) * len([val for val in [J[0, i, site_nbr_x, k], J[1, i, j, k], J[2, i, j, site_nbr_y]] if val > 0]) + sum([J[0, i, site_nbr_x, k], J[1, i, j, k], J[2, i, j, site_nbr_y]])
          priorities[i * N * N + j * N + k][1] += 2
  return(priorities)




#score: {'data3D.txt': -0.3164509999999999}
#standard deviation: 0.04538277116924438
#island_id: 1
#version_generated: 3
#generate time06:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) - sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val < 0]) - sum([val for val in [J[0, i, (j+1)%N, k], J[1, (i+1)%N, j, k], J[2, i, j, (k+1)%N]] if val > 0]))
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.122115}
#standard deviation: 0.04563091775320764
#island_id: 1
#version_generated: 3
#generate time06:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - neighbor_spin
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 1
#version_generated: 3
#generate time06:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[[0, 1, 2], i, j, k] if val > 0])
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val > 0])
          priorities[i * N * N + j * N + k][1] -= len([val for val in J[[0, 1, 2], i, j, k] if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.39548900000000003}
#standard deviation: 0.04412163504449943
#island_id: 1
#version_generated: 3
#generate time06:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] -= 3
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 3
          priorities[i * N * N + j * N + k][1] += 3
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.4802738000000001}
#standard deviation: 0.04240556606814724
#island_id: 1
#version_generated: 3
#generate time06:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])

        priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.140667}
#standard deviation: 0.0421628864168477
#island_id: 3
#version_generated: 3
#generate time06:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors with sign changed
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, (i + d % N) % N, (j + d // 3) % N, (k + d % 3) % N] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1188454000000003}
#standard deviation: 0.049420497557592445
#island_id: 1
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0,i,j,k], J[0,(i+1)%N,j,k], J[0,i,(j+1)%N,k]]
        interacting_spins_y = [J[3,i,j,k], J[3,(i+1)%N,j,k], J[3,i,(j+1)%N,k]]
        interacting_spins_z = [J[4,i,j,k], J[4,(i+1)%N,j,k], J[4,i,(j+1)%N,k]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-np.sum(np.abs([J[d,i,j,k] for d in [0,3,4]]))) * len([val for val in interacting_spins_x if val < 0]) + np.sum([J[d,i,j,k] for d in [0,3,4]])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * np.sum([J[d,i,j,k] for d in [0,3,4]])
        else:
          priorities[i * N * N + j * N + k][0] = -np.exp(-np.sum(np.abs([J[d,i,j,k] for d in [0,3,4]]))) * len([val for val in interacting_spins_x if val > 0]) + np.sum([J[d,i,j,k] for d in [0,3,4]])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * np.sum([J[d,i,j,k] for d in [0,3,4]])
  
  return priorities




#score: {'data3D.txt': -0.2064282}
#standard deviation: 0.05256714073221027
#island_id: 1
#version_generated: 3
#generate time06:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(interacting_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.16127179999999997}
#standard deviation: 0.04602531917064781
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) + 1) 
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[1, i, j, k-1] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors_spin - total_spin)
          priorities[i * N * N + j * N + k][1] -= total_site_neighbors_spin - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': -0.4369706}
#standard deviation: 0.04446137532330731
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if J[0, i, j, k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif J[0, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0026206000000000003}
#standard deviation: 0.046924062224406794
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(sum(J[d, i, j, k] for d in [0, 1]))) * 1
              priorities[i * N * N + j * N + k][1] += 1

        return priorities




#score: {'data3D.txt': -0.430693}
#standard deviation: 0.04159151296839297
#island_id: 0
#version_generated: 3
#generate time06:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin = sum(J[d, i, j, k] for d in [0, 1])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        else:
          total_spin = sum(J[d, i, j, k] for d in [0, 1])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0340854}
#standard deviation: 0.04721111931356849
#island_id: 1
#version_generated: 3
#generate time06:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0])
        
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) - neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - len([val for val in interacting_spins if val < 0])) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.19344460000000036}
#standard deviation: 0.0492213852998877
#island_id: 1
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i + d % N) % N, (j + d // 3) % N, (k + d % 3) % N] for d in [0, 1, 2]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_sum = sum(site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum < 0)
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * site_neighbors_sum
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (site_neighbors_sum > 0)
          priorities[i * N * N + j * N + k][1] = 3 - 2 * site_neighbors_sum
        
  return priorities




#score: {'data3D.txt': -0.469971}
#standard deviation: 0.039219071878360406
#island_id: 1
#version_generated: 3
#generate time06:28
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]
        interacting_spins = [J[d, (i + d % N) % N, (j + d // 3) % N, (k + d % 3) % N] for d in [0, 1, 2]]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - sum([J[d, i, j, k] for d in [0, 1, 2]])
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.22291539999999999}
#standard deviation: 0.04503605758545036
#island_id: 0
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[2, i, j, k-1] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors_spin - total_spin)
          priorities[i * N * N + j * N + k][1] -= total_site_neighbors_spin - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.0024654000000000004}
#standard deviation: 0.04702535149087139
#island_id: 0
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        return(priorities)




#score: {'data3D.txt': -0.2035594}
#standard deviation: 0.0443340617543667
#island_id: 0
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          for d in range(3):
            if site_neighbors[d] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif site_neighbors[d] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.22291539999999999}
#standard deviation: 0.04503605758545036
#island_id: 0
#version_generated: 3
#generate time06:29
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_nbr = (i + ((k - 1) % 2 - 1)) % N
          if J[2, i, j, k-1] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_site_neighbors_spin - total_spin)
          priorities[i * N * N + j * N + k][1] -= total_site_neighbors_spin - total_spin
        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
  
  return(priorities)




#score: {'data3D.txt': 0.3377218}
#standard deviation: 0.04770995540513531
#island_id: 3
#version_generated: 3
#generate time06:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': 0.3377218}
#standard deviation: 0.04770995540513531
#island_id: 3
#version_generated: 3
#generate time06:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': 0.3377218}
#standard deviation: 0.04770995540513531
#island_id: 3
#version_generated: 3
#generate time06:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': 0.3377218}
#standard deviation: 0.04770995540513531
#island_id: 3
#version_generated: 3
#generate time06:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val < 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, :] if val > 0]) - np.exp(-abs(total_spin)) * len([val for val in J[1, i, :, k] if val > 0])
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.24820260000000002}
#standard deviation: 0.0468874400371784
#island_id: 2
#version_generated: 3
#generate time06:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0] * 6
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if (i + 1) % N != 0:
          interacting_spins[0] = J[0, i+1, j, k]
        if (j + 1) % N != 0:
          interacting_spins[1] = J[1, i, j+1, k]
        if (k + 1) % N != 0:
          interacting_spins[2] = J[2, i, j, k+1]
        if (i > 0):
          interacting_spins[3] = J[3, i-1, j, k]
        if (j > 0):
          interacting_spins[4] = J[4, i, j-1, k]
        if (k > 0):
          interacting_spins[5] = J[5, i, j, k-1]
        
        spin_values = [J[l, i, j, k] for l in range(6)]
        neighbor_spin_sum = sum([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (neighbor_spin_sum - 1) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.36637699999999995}
#standard deviation: 0.043946837781574224
#island_id: 2
#version_generated: 3
#generate time06:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = []
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if (i + 1) % N != 0:
          site_neighbors.append(J[0, i+1, j, k])
        else:
          site_neighbors.append(0)
        if (j + 1) % N != 0:
          site_neighbors.append(J[1, i, j+1, k])
        else:
          site_neighbors.append(0)
        if (k + 1) % N != 0:
          site_neighbors.append(J[2, i, j, k+1])
        else:
          site_neighbors.append(0)
        
        spin_values = [J[l, i, j, k] for l in range(6)]
        neighbor_spin_sum = sum([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][0] = -neighbor_spin_sum
        priorities[i * N * N + j * N + k][1] = -2 - 2 * neighbor_spin_sum
        
  return(priorities)




#score: {'data3D.txt': -0.09095900000000005}
#standard deviation: 0.05789463359414239
#island_id: 1
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([-val for val in interacting_spins if val < 0]) + np.exp(-abs(total_spin)) * sum([-val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(interacting_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.2558634}
#standard deviation: 0.051611527592583424
#island_id: 1
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(interacting_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d in range(3):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': 0.21131340000000035}
#standard deviation: 0.047155104712427474
#island_id: 1
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + sum([val for val in interacting_spins if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + sum([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(interacting_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.21983260000000002}
#standard deviation: 0.051312686318687316
#island_id: 1
#version_generated: 3
#generate time06:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[0, (i + 1) % N, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]]
        site_neighbors = [J[0, i, (j - 1) % N, k], J[1, (i - 1) % N, j, k], J[2, i, j, (k - 1) % N]]

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val < 0]) + sum([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum([val for val in interacting_spins if val > 0]) + sum([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(interacting_spins):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

        for d, spin in enumerate(site_neighbors):
          if spin < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * J[d, i, j, k]
            priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin

  return priorities




#score: {'data3D.txt': 0.33172300000000027}
#standard deviation: 0.04886928392149817
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 3
          priorities[i * N * N + j * N + k][1] += 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - 3
          priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': 0.4429350000000001}
#standard deviation: 0.043616647911090094
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - 3
        priorities[i * N * N + j * N + k][1] += 2

  return(priorities)




#score: {'data3D.txt': -0.37259700000000034}
#standard deviation: 0.04913918060977411
#island_id: 3
#version_generated: 3
#generate time06:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 3
#version_generated: 3
#generate time06:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.07460499999999999}
#standard deviation: 0.058412474138663226
#island_id: 2
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(J[d, i, j, k])
            priorities[i * N * N + j * N + k][1] += abs(J[d, i, j, k])
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(J[d, i, j, k])
            priorities[i * N * N + j * N + k][1] -= abs(J[d, i, j, k])
        
  return(priorities)




#score: {'data3D.txt': 0.016501800000000007}
#standard deviation: 0.05520917601957124
#island_id: 2
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (1 + total_neighbor_spin) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin + 2 * total_neighbor_spin
        
        for d in range(3):
          if i == 0:
            neighbor_spin = J[d, N-1, j, k]
          elif i == N-1:
            neighbor_spin = J[1-d, 0, j, k]
          else:
            neighbor_spin = J[1-d, i-1, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        for d in range(6):
          if J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 4
          elif J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 4
  
  return(priorities)




#score: {'data3D.txt': -0.0690602}
#standard deviation: 0.05175293862149279
#island_id: 2
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins += [np.roll(h, 1, axis=i) for i in range(3)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in range(6))
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        neighbor_spin = sum(val for val in site_neighbors if val < 0)
        
        total_neighbor_spin = -2 * neighbor_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin + total_neighbor_spin) + h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': 0.20148419999999992}
#standard deviation: 0.04477443009531222
#island_id: 2
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * (2 * h[i][j][k] - 1) for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1747994}
#standard deviation: 0.044086652397749594
#island_id: 2
#version_generated: 3
#generate time06:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(J[d, i + d, j, k])
          else:
            site_neighbors.append(J[1 - d, i - d, j, k])
        
        total_neighbor_spin = -sum(val for val in site_neighbors if val < 0)
        
        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in site_neighbors if val > 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (h[i][j][k] + total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 1
  
  return(priorities)




#score: {'data3D.txt': -0.2035594}
#standard deviation: 0.0443340617543667
#island_id: 0
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          for d in range(3):
            if site_neighbors[d] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif site_neighbors[d] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.186825}
#standard deviation: 0.04488912891781261
#island_id: 0
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          for d in range(3):
            if site_neighbors[d] < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif site_neighbors[d] > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return priorities




#score: {'data3D.txt': -0.1587229999999999}
#standard deviation: 0.04686823008179422
#island_id: 0
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.20924739999999997}
#standard deviation: 0.04510391328077865
#island_id: 0
#version_generated: 3
#generate time06:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[range(3), i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 1
#version_generated: 3
#generate time06:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= len(site_neighbors) - 2 * total_spin

  return priorities




#score: {'data3D.txt': -0.44953540000000003}
#standard deviation: 0.04037602787347958
#island_id: 1
#version_generated: 3
#generate time06:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0]) + len([val for val in site_neighbors if val > 0])
        
  return priorities




#score: {'data3D.txt': -0.393863}
#standard deviation: 0.03955630406142616
#island_id: 1
#version_generated: 3
#generate time06:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([J[l, i, j, k] < 0 for l in [0, 1, 2]]) - 1)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([J[l, i, j, k] > 0 for l in [0, 1, 2]]) - 1)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val < 0 for val in site_neighbors])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val < 0])
        
  return priorities




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
    
  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 1
#version_generated: 3
#generate time06:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3273054}
#standard deviation: 0.04639353113139805
#island_id: 1
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2275893999999999}
#standard deviation: 0.045613676980046244
#island_id: 0
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i, j, k if d == (i + 1) % N else k-1])
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.08134620000000001}
#standard deviation: 0.0461673896333765
#island_id: 0
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        interacting_spins = J[[0, 1, 2], i, j, k]
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * sum(1 for val in interacting_spins if val < 0) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
  return(priorities)




#score: {'data3D.txt': -0.09311419999999998}
#standard deviation: 0.04653163352344295
#island_id: 0
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.roll(h, -1, axis=i) for i in range(3)]
  interacting_spins.extend([np.roll(h, 1, axis=i) for i in range(3)])

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * h[i][j][k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(J[d, i, j, k] for d in [0, 1, 2]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.2362554}
#standard deviation: 0.044676273914013916
#island_id: 0
#version_generated: 3
#generate time06:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[range(3), i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spin = J[2, i, j, k if d == (i + 1) % N else k-1]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (interacting_spin < 0)
          priorities[i * N * N + j * N + k][1] -= (interacting_spin < 0)
        
  return(priorities)




#score: {'data3D.txt': -0.2836858000000001}
#standard deviation: 0.046516202320911776
#island_id: 3
#version_generated: 3
#generate time06:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2682734000000004}
#standard deviation: 0.049270863727359185
#island_id: 3
#version_generated: 3
#generate time06:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
  return(priorities)




#score: {'data3D.txt': -0.31471540000000015}
#standard deviation: 0.05307953431257663
#island_id: 3
#version_generated: 3
#generate time06:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
        
        # Add a new term based on the total spin of all neighboring sites
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] -= 4
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
            priorities[i * N * N + j * N + k][1] += 4
        
  return(priorities)




#score: {'data3D.txt': -0.2836858000000001}
#standard deviation: 0.046516202320911776
#island_id: 3
#version_generated: 3
#generate time06:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.2682734000000004}
#standard deviation: 0.049270863727359185
#island_id: 3
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
            priorities[i * N * N + j * N + k][1] += 2
  
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbor_spin = sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          site_neighbor_spin = sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.32027059999999974}
#standard deviation: 0.0450178828427104
#island_id: 2
#version_generated: 2
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.47791300000000003}
#standard deviation: 0.042556983809945936
#island_id: 2
#version_generated: 2
#generate time06:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = sum(1 for neighbor in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if neighbor > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
        priorities[i * N * N + j * N + k][1] += same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 2
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 2
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 2
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.049851799999999995}
#standard deviation: 0.045043007856492
#island_id: 1
#version_generated: 2
#generate time06:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_site_neighbors_spin = sum(val for val in site_neighbors)
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val < 0]) + total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          site_neighbors_spin = sum(val for val in site_neighbors)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_site_neighbors_spin)) * len([val for val in site_neighbors if val > 0]) + total_site_neighbors_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_site_neighbors_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4311762000000001}
#standard deviation: 0.04747377416595399
#island_id: 1
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the diagonally neighboring sites
        site_neighbors_diagonal = [J[0, (i+1)%N, (j+1)%N, k], J[1, i, (k+1)%N, j]]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.13212140000000003}
#standard deviation: 0.048779134289570994
#island_id: 1
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += sum(J[d, i, j, k] for d in [3,4,5])
          priorities[i * N * N + j * N + k][1] -= sum(J[d, i, j, k] for d in [3,4,5])
        else:
          priorities[i * N * N + j * N + k][0] -= sum(J[d, i, j, k] for d in [3,4,5])
          priorities[i * N * N + j * N + k][1] = -sum(J[d, i, j, k] for d in [3,4,5])
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time06:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.45514779999999994}
#standard deviation: 0.042476694258852116
#island_id: 0
#version_generated: 3
#generate time06:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3273054}
#standard deviation: 0.04639353113139805
#island_id: 0
#version_generated: 3
#generate time06:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.32027059999999974}
#standard deviation: 0.0450178828427104
#island_id: 2
#version_generated: 3
#generate time06:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.14855380000000037}
#standard deviation: 0.04886466029309935
#island_id: 2
#version_generated: 3
#generate time06:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.3096838}
#standard deviation: 0.042220284906191716
#island_id: 0
#version_generated: 3
#generate time07:00
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = [[0, 0] for _ in range(N**3)]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin = sum(J[d, i, j, k] for d in [0, 1])

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]

            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

        else:
          total_spin = sum(J[d, i, j, k] for d in [0, 1])

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1

          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]

            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1

  return [list(x) for x in priorities]




#score: {'data3D.txt': -0.32027059999999974}
#standard deviation: 0.0450178828427104
#island_id: 2
#version_generated: 3
#generate time07:01
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.40909660000000003}
#standard deviation: 0.04736980798398912
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] < 0]) - 1)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] > 0]) - 1)
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.003191}
#standard deviation: 0.04695227235182553
#island_id: 2
#version_generated: 3
#generate time07:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        same_spin_count = sum(1 for neighbor in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if neighbor > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
        priorities[i * N * N + j * N + k][1] += same_spin_count
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbor_spin = sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          site_neighbor_spin = sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': 0.035184599999999996}
#standard deviation: 0.042701213599147275
#island_id: 3
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.zeros(N) for _ in range(6)]
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          interacting_spins[d][i] += J[d, i, j, k]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i, j, k] if h[i][j][k] > 0 else -J[d, i, j, k] for d in [0, 1, 2]])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[d] if h[i][j][k] > 0 and val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time07:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          site_neighbor_spin = sum(val for val in site_neighbors if val < 0)
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * total_spin

          site_neighbor_spin = sum(val for val in site_neighbors if val > 0)
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 + 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4572206}
#standard deviation: 0.04537298596786418
#island_id: 1
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d==0 else i-1, j, k] for d in [0, 1]]
        interacting_spins.extend([J[2, i, (j+1)%N if d==1 else j-1, k] for d in [0]])
        interacting_spins = sum(val for val in interacting_spins)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4757094}
#standard deviation: 0.04010622684372092
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
  return(priorities)




#score: {'data3D.txt': -0.028819400000000005}
#standard deviation: 0.05029819940753347
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.45489260000000004}
#standard deviation: 0.0429618754855977
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 2
#version_generated: 3
#generate time07:18
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  # D X N^D matrix of neighboring spins along each axis
  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins_site = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_site) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_site) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in range(6):
          priorities[i * N * N + j * N + k][0] += -J[d, i, j, k] * interacting_spins[d, i, j, k]
          priorities[i * N * N + j * N + k][1] -= J[d, i, j, k] * interacting_spins[d, i, j, k]
          
  return(priorities)




#score: {'data3D.txt': -0.009843}
#standard deviation: 0.05303938113326738
#island_id: 0
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        total_neighbor_spin = sum(val for val in site_neighbors if val != 0)
        spin_diff = abs(total_spin) - abs(total_neighbor_spin)

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) - spin_diff
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time07:19
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4000394}
#standard deviation: 0.039117953009328084
#island_id: 3
#version_generated: 3
#generate time07:20
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

        # Add a new term based on the total spin of the site's neighbors
        if (i + (2 - 1) % 2 == 0):
          neighbor_spin = J[2, i + 2, j, k]
        else:
          neighbor_spin = J[0, i - 2, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

  return(priorities)




#score: {'data3D.txt': -0.35922220000000005}
#standard deviation: 0.05007412532596051
#island_id: 3
#version_generated: 3
#generate time07:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.389911}
#standard deviation: 0.04173645168195303
#island_id: 3
#version_generated: 3
#generate time07:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        if (i + (2 - 1) % 2 == 0):
          neighbor_spin = J[2, i + 2, j, k]
        else:
          neighbor_spin = J[0, i - 2, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.4000394}
#standard deviation: 0.039117953009328084
#island_id: 3
#version_generated: 3
#generate time07:21
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        if (i + (2 - 1) % 2 == 0):
          neighbor_spin = J[2, i + 2, j, k]
        else:
          neighbor_spin = J[0, i - 2, j, k]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.430693}
#standard deviation: 0.04159151296839297
#island_id: 0
#version_generated: 3
#generate time07:24
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          total_spin = sum(J[d, i, j, k] for d in [0, 1])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
        else:
          total_spin = sum(J[d, i, j, k] for d in [0, 1])
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          if J[0, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif J[0, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.20102259999999988}
#standard deviation: 0.04547446414461638
#island_id: 0
#version_generated: 3
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]

        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i if d == (i + 1) % N else i-1, j if d == (j + 1) % N else j-1, k])

        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        if i > 0 and j > 0 and k > 0:
          interacting_spins.append(J[2, i-1, j-1, k-1])

  return(priorities)




#score: {'data3D.txt': -0.010506599999999887}
#standard deviation: 0.04106185330011299
#island_id: 0
#version_generated: 3
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i, j, k if d == (i + 1) % N else k-1])
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        if i < N//2:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif i >= N//2:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.1995209999999999}
#standard deviation: 0.04593450423156868
#island_id: 0
#version_generated: 3
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.2275893999999999}
#standard deviation: 0.045613676980046244
#island_id: 0
#version_generated: 3
#generate time07:25
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        site_neighbors = [(i + ((j - 1) % 2 - 1)) % N, (i + 1) % N, (j + 1) % N]
        for d in site_neighbors:
          interacting_spins.append(J[2, i, j, k if d == (i + 1) % N else k-1])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.38229380000000013}
#standard deviation: 0.049341698811046227
#island_id: 1
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N])]
        interacting_spins = sum(val for val in site_neighbors[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the diagonally neighboring sites
        site_neighbors_diagonal = [(J[0, (i+1)%N, (j+1)%N, k], J[1, i, (k+1)%N, j])]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the next diagonally neighboring sites
        site_neighbors_diagonal_next = [(J[0, (i+2)%N if i < N-1 else 0, (j+1)%N, k], J[1, i, (k+1)%N, j])]
        interacting_spins_diagonal_next = sum(val for val in site_neighbors_diagonal_next[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal_next) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal_next) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4472318}
#standard deviation: 0.04483753861174808
#island_id: 1
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0, 1]]
        site_neighbors.extend([J[2, i, (j+1)%N if d==1 else j-1, k] for d in [0]])
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:30
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0]]
        site_neighbors.extend([J[1, i, (j+1)%N if d==1 else j-1, k] for d in [1]])
        site_neighbors.extend([J[2, i, j, (k+1)%N if d==2 else k-1] for d in [2]])
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3533626}
#standard deviation: 0.04194095374738157
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        # Add interactions with neighboring spins
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i + d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[3-d, i - d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.20885579999999995}
#standard deviation: 0.046417695401215264
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        neighbor_spin = J[2, i, j, k-1]
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.015845400000000003}
#standard deviation: 0.04656008826065518
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(3):
          if i + (d-1)%2 == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+d, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[1-d, i-d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[1-d, i-d, j, k]

        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i, j, k-1]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.1814622}
#standard deviation: 0.044730074124239946
#island_id: 0
#version_generated: 3
#generate time07:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[2, i, j, k], J[3, i, j, k], J[4, i, j, k], J[5, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.2197138}
#standard deviation: 0.05575785334425995
#island_id: 1
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = sum(J[d, (i+1)%N, j, k] + J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] for d in [0, 1, 2])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(J[d, i, j, k] for d in [3,4,5])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.36947180000000013}
#standard deviation: 0.046706731043394595
#island_id: 1
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = sum(val for val in site_neighbors)
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  for i in range(N):
    for j in range(N):
      for k in range(N):
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        interacting_spins = [J[d, i, j, k] for d in [3,4,5]]
        total_spin = sum(J[d, i, j, k] for d in [3,4,5])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.49319460000000004}
#standard deviation: 0.04309335645827556
#island_id: 1
#version_generated: 3
#generate time07:32
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+n)%N, (j+m)%N, (k+p)%N] for d, n, m, p in [(0,1,0,0), (1,0,1,0), (2,0,0,1)]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(sum(val for val in interacting_spins if val < 0)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(sum(val for val in interacting_spins if val > 0)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4311762000000001}
#standard deviation: 0.04747377416595399
#island_id: 1
#version_generated: 3
#generate time07:33
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the diagonally neighboring sites
        site_neighbors_diagonal = [J[0, (i+1)%N, (j+1)%N, k], J[1, i, (k+1)%N, j]]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3387282000000002}
#standard deviation: 0.04939048253216403
#island_id: 1
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the diagonally neighboring sites
        site_neighbors_diagonal = [J[0, (i+1)%N, (j+1)%N, k], J[1, i, (k+1)%N, j]]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the non-neighboring sites
        for d in range(3):
          interacting_spins_non_neighboring = J[d, i, j, k]
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_non_neighboring) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_non_neighboring) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.36911540000000015}
#standard deviation: 0.049687622632200876
#island_id: 1
#version_generated: 3
#generate time07:34
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_diagonal = [J[0, (i+1)%N, (j+1)%N, k], J[1, i, (k+1)%N, j]]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the sites at distance 3
        site_neighbors_distance_3 = [J[0, (i+2)%N, j, k], J[1, i, (j+2)%N, k], J[2, i, j, (k+2)%N]]
        interacting_spins_distance_3 = sum(val for val in site_neighbors_distance_3)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_distance_3) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_distance_3) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.38229380000000013}
#standard deviation: 0.049341698811046227
#island_id: 1
#version_generated: 3
#generate time07:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N])]
        interacting_spins = sum(val for val in site_neighbors[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_diagonal = [(J[0, (i+1)%N if i < N-1 else 0, (j+1)%N if j < N-1 else 0, k], J[1, i, (k+1)%N if k < N-1 else 0, j])]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors_diagonal_next = [(J[0, (i+2)%N if i < N-2 else 0, (j+1)%N if j < N-1 else 0, k], J[1, i, (k+1)%N if k < N-1 else 0, j])]
        interacting_spins_diagonal_next = sum(val for val in site_neighbors_diagonal_next[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal_next) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal_next) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [(J[0, (i+1)%N if i < N-1 else 0, j, k], J[1, i, (j+1)%N if j < N-1 else 0, k], J[2, i, j, (k+1)%N if k < N-1 else 0])]
        interacting_spins = sum(val for val in site_neighbors[0])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0]]
        site_neighbors.extend([J[1, i, (j+1)%N if d==1 else j-1, k] for d in [1]])
        site_neighbors.extend([J[2, i, j, (k+1)%N if d==2 else k-1] for d in [2]])
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0]]
        site_neighbors.extend([J[1, i, (j+1)%N if d==1 else j-1, k] for d in [1]])
        site_neighbors.extend([J[2, i, j, (k+1)%N if d==2 else k-1] for d in [2]])
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0]]
        site_neighbors.extend([J[1, i, (j+1)%N if d==1 else j-1, k] for d in [1]])
        site_neighbors.extend([J[2, i, j, (k+1)%N if d==2 else k-1] for d in [2]])
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0]]
        site_neighbors.extend([J[1, i, (j+1)%N if d==1 else j-1, k] for d in [1]])
        site_neighbors.extend([J[2, i, j, (k+1)%N if d==2 else k-1] for d in [2]])
        
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.035184599999999996}
#standard deviation: 0.042701213599147275
#island_id: 3
#version_generated: 3
#generate time07:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = [np.zeros(N) for _ in range(6)]

  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          interacting_spins[d][i] += J[d, i, j, k]

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i, j, k] if h[i][j][k] > 0 else -J[d, i, j, k] for d in [0, 1, 2]])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[d] if h[i][j][k] > 0 and val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.12429060000000001}
#standard deviation: 0.04495579508406008
#island_id: 3
#version_generated: 3
#generate time07:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0]
        site_neighbors = []

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, i, j, k])
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k] if h[i][j][k] > 0 else -J[d, (i + (d % 2)) % N, j, k])
          else:
            interacting_spins.append(J[d-3, i, (j + 1) % N, k])
            site_neighbors.append(J[d-3, (i + 1) % N, j, k] if h[i][j][k] > 0 else -J[d-3, (i + 1) % N, j, k])

        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if h[i][j][k] > 0 and val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': 0.004377400000000007}
#standard deviation: 0.34573644657345537
#island_id: 3
#version_generated: 3
#generate time07:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [np.zeros(N) for _ in range(6)]
  site_neighbors = [np.zeros(N) for _ in range(3)]
  
  for d in range(6):
    for i in range(N):
      for j in range(N):
        for k in range(N):
          interacting_spins[d][i] += J[d, i, j, k]
          
          if h[i][j][k] > 0:
            site_neighbors[0][i] += J[0, i, (j + 1) % N, k]
            site_neighbors[1][i] += J[1, (i + 1) % N, j, k]
            site_neighbors[2][i] += J[2, i, j, (k + 1) % N]
          elif h[i][j][k] < 0:
            site_neighbors[0][i] -= J[0, i, (j + 1) % N, k]
            site_neighbors[1][i] -= J[1, (i + 1) % N, j, k]
            site_neighbors[2][i] -= J[2, i, j, (k + 1) % N]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum([J[d, i, j, k] if h[i][j][k] > 0 else -J[d, i, j, k] for d in [0, 1, 2]])
        
        site_neighbors_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors[0]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins[d] if h[i][j][k] > 0 and val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        site_neighbors_spin += sum([val if h[i][j][k] > 0 else -val for val in site_neighbors[1]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbors_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbors_spin
        
  return(priorities)




#score: {'data3D.txt': 0.0283346}
#standard deviation: 0.0459462329559236
#island_id: 3
#version_generated: 3
#generate time07:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0]
        for d in [0, 1, 2]:
          if (i + d) % N == j:
            interacting_spins.append(J[d, i, j, k])
          elif (j + d) % N == i:
            interacting_spins.append(J[3 - d, i, j, k])
          elif (k + d) % N == i:
            interacting_spins.append(J[4 - d, i, j, k])
        total_spin = sum([J[d, i, j, k] if h[i][j][k] > 0 else -J[d, i, j, k] for d in [0, 1, 2]])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.189611}
#standard deviation: 0.04497254094444743
#island_id: 0
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in [2, 3]:
          neighbor_spin = J[d, i, j, k-1]
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
            
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
            priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.20633659999999998}
#standard deviation: 0.04633353451270474
#island_id: 0
#version_generated: 3
#generate time07:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]

          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (neighbor_spin < 0)
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          elif h[i][j][k] < 0:
            priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
            priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return [list(x) for x in priorities]




#score: {'data3D.txt': -0.140667}
#standard deviation: 0.0421628864168477
#island_id: 3
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        # Add a new term based on the number of nearest neighbors with spin opposite to that of the current site
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of next nearest neighbors with spin opposite to that of the current site
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.140667}
#standard deviation: 0.0421628864168477
#island_id: 3
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        # Add a new term based on the number of nearest neighbors with the opposite sign
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors with sign changed
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.140667}
#standard deviation: 0.0421628864168477
#island_id: 3
#version_generated: 3
#generate time07:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_neighbor_spin
          
        # Add a new term based on the number of nearest neighbors with sign changed
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors with sign changed
        for d in [0, 2]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.15903420000000024}
#standard deviation: 0.04778493141524848
#island_id: 3
#version_generated: 3
#generate time07:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.34339339999999957}
#standard deviation: 0.04479744988768891
#island_id: 3
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = [J[d, i, j, k] for d in range(6) for i in range(N) for j in range(N) for k in range(N)]
  site_neighbors = [[J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] 
           for i in range(N) for j in range(N) for k in range(N)]
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbor_spin = sum(val for val in site_neighbors[i * N * N + j * N + k])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors[i * N * N + j * N + k] if val < 0]) + site_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * site_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors[i * N * N + j * N + k] if val > 0]) + site_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * site_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.15903420000000024}
#standard deviation: 0.04778493141524848
#island_id: 3
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.19473179999999998}
#standard deviation: 0.04532443346319951
#island_id: 3
#version_generated: 3
#generate time07:43
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.499427}
#standard deviation: 0.04108827899778719
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum(1 for val in interacting_spins if val < 0) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.3716526}
#standard deviation: 0.04308302767030191
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in [0, 1, 2]]
        total_spin = sum(interacting_spins)

        site_neighbors = []
        if j < N - 1:
          site_neighbors.append(J[0][i][j + 1][k])
        if i < N - 1:
          site_neighbors.append(J[1][i + 1][j][k])
        if k < N - 1:
          site_neighbors.append(J[2][i][j][k + 1])

        neighbor_spin = sum([spin for spin in interacting_spins if spin > 0])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - sum(site_neighbors))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * sum(site_neighbors)

        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val > 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.31313979999999997}
#standard deviation: 0.045126871993968296
#island_id: 3
#version_generated: 3
#generate time07:46
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if J[2, i, j, k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.43632860000000007}
#standard deviation: 0.04552272379856022
#island_id: 1
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = [J[0, (i+1)%N if d==0 else i-1, j, k] for d in [0]]
        interacting_spins_y = [J[1, i, (j+1)%N if d==1 else j-1, k] for d in [0]]
        interacting_spins_z = [J[2, i, j, (k+1)%N if d==2 else k-1] for d in [0]]
        interacting_spins = sum(val for val in interacting_spins_x + interacting_spins_y + interacting_spins_z)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.4572206}
#standard deviation: 0.04537298596786418
#island_id: 1
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, (i+1)%N if d==0 else i-1, j, k] for d in [0, 1]]
        interacting_spins.extend([J[2, i, (j+1)%N if d==1 else j-1, k] for d in [0]])
        
        total_spin = sum(J[d, i, j, k] for d in range(3))

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(sum(val for val in interacting_spins)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(sum(val for val in interacting_spins)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.5039786}
#standard deviation: 0.043816754581324266
#island_id: 1
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(sum(J[2, i, (j+1)%N if d==1 else j-1, k] for d in [0])) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(sum(J[2, i, (j+1)%N if d==1 else j-1, k] for d in [0])) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.1436882000000002}
#standard deviation: 0.0481131052911782
#island_id: 1
#version_generated: 3
#generate time07:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = sum(J[d, (i+1)%N if d==0 else i-1, j, k] for d in [0])
        interacting_spins_y = sum(J[2, i, (j+1)%N if d==1 else j-1, k] for d in [0])
        interacting_spin_z = J[2, i, j, k]
        
        total_spin = interacting_spin_z + 2*interacting_spins_x*interacting_spin_z + 2*interacting_spins_y*interacting_spin_z
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (1 + interacting_spin_z) - np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2*total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 + interacting_spin_z) + np.exp(abs(total_spin))
          priorities[i * N * N + j * N + k][1] = -2 + 2*total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.0026022000000000007}
#standard deviation: 0.04700316622484064
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in J[range(3), i, j, k] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1, 2]:
            neighbor_spin = J[d, (i + (d - 1) % 2), j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
          
        return(priorities)




#score: {'data3D.txt': -0.002408200000000001}
#standard deviation: 0.04705028175005969
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
          
          neighbor_spin = J[2, i, j, k - 1]
          if neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] -= 1
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
              priorities[i * N * N + j * N + k][1] += 1
          
        return(priorities)




#score: {'data3D.txt': -0.4621242}
#standard deviation: 0.04183589719798059
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        # Add interactions with neighboring spins
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i + d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[3-d, i - d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4621242}
#standard deviation: 0.04183589719798059
#island_id: 0
#version_generated: 3
#generate time07:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
          
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i + d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[3-d, i - d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.2075686}
#standard deviation: 0.04594848522029862
#island_id: 2
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - same_spin_count
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - same_spin_count
          priorities[i * N * N + j * N + k][1] = -2
        
  return(priorities)




#score: {'data3D.txt': -0.47791300000000003}
#standard deviation: 0.042556983809945936
#island_id: 2
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = sum(1 for neighbor in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if neighbor > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
        priorities[i * N * N + j * N + k][1] += same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.47791300000000003}
#standard deviation: 0.042556983809945936
#island_id: 2
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= 2
        
        # Add a new term based on the number of nearest neighbors with the same spin
        same_spin_count = sum(1 for neighbor in [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]] if neighbor > 0)
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
        priorities[i * N * N + j * N + k][1] += same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.12635259999999998}
#standard deviation: 0.04554150758637664
#island_id: 2
#version_generated: 3
#generate time07:49
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3): 
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)  
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in range(6))
        
        priorities[i*N*N + j*N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, j, k], J[2, i, j, k]] if val < 0])
        priorities[i*N*N + j*N + k][1] -= total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3179994000000002}
#standard deviation: 0.05009200454803142
#island_id: 1
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the diagonally neighboring sites
        site_neighbors_diagonal = [J[0, (i+1)%N, (j+1)%N, k], J[1, i, (k+1)%N, j]]
        interacting_spins_diagonal = sum(val for val in site_neighbors_diagonal)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the non-neighboring sites
        for d in range(3):
          interacting_spins_non_neighboring = J[d, i, j, k]
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_non_neighboring) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_non_neighboring) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the diagonally non-neighboring sites
        site_neighbors_diagonal_non_neighboring = [J[0, (i+1)%N, (j-1)%N, k], J[1, i, (k-1)%N, j]]
        interacting_spins_diagonal_non_neighboring = sum(val for val in site_neighbors_diagonal_non_neighboring)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal_non_neighboring) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_diagonal_non_neighboring) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add the interaction with the non-neighboring sites and diagonally non-neighboring sites
        for d in range(3):
          interacting_spins_non_neighboring_diagonal = J[d, i, j, k]
          
          if h[i][j][k] > 0:
            priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins_non_neighboring_diagonal) + total_spin
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          else:
            priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins_non_neighboring_diagonal) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4547494}
#standard deviation: 0.045944576607473496
#island_id: 1
#version_generated: 3
#generate time07:50
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, (i+1)%N, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        interacting_spins = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0028081999999999994}
#standard deviation: 0.04695402232780489
#island_id: 2
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin + site_nbr
          priorities[i * N * N + j * N + k][1] += 2
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.0029402000000000005}
#standard deviation: 0.04693681523026461
#island_id: 2
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        return(priorities)




#score: {'data3D.txt': -0.45489260000000004}
#standard deviation: 0.0429618754855977
#island_id: 2
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = np.sum(site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= total_spin - site_nbr
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.2104794}
#standard deviation: 0.05518603351972308
#island_id: 1
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins_x = sum(J[d, (i+1)%N, j, k] for d in [0])
        interacting_spins_y = sum(J[d, i, (j+1)%N, k] for d in [1])
        interacting_spins_z = sum(J[d, i, j, (k+1)%N] for d in [2])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(J[d, i, j, k] for d in [3,4,5])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * (abs(interacting_spins_x) + abs(interacting_spins_y) + abs(interacting_spins_z)) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (abs(interacting_spins_x) + abs(interacting_spins_y) + abs(interacting_spins_z)) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.2197138}
#standard deviation: 0.05575785334425995
#island_id: 1
#version_generated: 3
#generate time07:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = sum(J[d, (i+1)%N, j, k] + J[d, i, (j+1)%N, k] + J[d, i, j, (k+1)%N] for d in [0, 1, 2])
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2]) + sum(J[d, i, j, k] for d in [3,4,5])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += -np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * abs(interacting_spins) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  return(priorities)




#score: {'data3D.txt': -0.40909660000000003}
#standard deviation: 0.04736980798398912
#island_id: 2
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] < 0]) - 1)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] > 0]) - 1)
          priorities[i * N * N + j * N + k][1] += 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0524758}
#standard deviation: 0.05385968561326737
#island_id: 2
#version_generated: 3
#generate time07:52
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.1089946}
#standard deviation: 0.05124639002739608
#island_id: 2
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] < 0]) - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] > 0]) - 1) - total_spin
          priorities[i * N * N + j * N + k][1] = -1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, :] < 0]) - 1) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, :] > 0]) - 1) * 2
            priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.20735539999999997}
#standard deviation: 0.043638116948832704
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

  return(priorities)




#score: {'data3D.txt': 0.1927246}
#standard deviation: 0.04518755442419959
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        for d in range(6):
          if J[d, i, j, k] > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[e, i, j, k] for e in range(3)] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          elif J[d, i, j, k] < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[e, i, j, k] for e in range(3)] if val > 0]) - total_spin
            priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.0025886000000000004}
#standard deviation: 0.04701342861396093
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        return(priorities)




#score: {'data3D.txt': -0.0025886000000000004}
#standard deviation: 0.04701342861396093
#island_id: 0
#version_generated: 3
#generate time07:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))

  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_neighbors = []
        for d in range(3):
          if (i + (d - 1) % 2 == 0):
            site_neighbors.append(interacting_spins[2, i + d, j, k])
          else:
            site_neighbors.append(interacting_spins[2-d, i - d, j, k])

        priorities[i * N * N + j * N + k][0] = np.exp(-abs(total_spin)) * (len([val for val in [J[d, i, j, k] for d in [0, 1, 2]] if val < 0]) + len([val for val in site_neighbors if val < 0])) + total_spin
        priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        return(priorities)




#score: {'data3D.txt': -0.0710186}
#standard deviation: 0.05670820058898008
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0524758}
#standard deviation: 0.05385968561326737
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        same_spin_count = sum(1 for neighbor in site_neighbors if neighbor > 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.12117460000000002}
#standard deviation: 0.05093762886943208
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = len(interacting_spins) - same_spin_count
        
        total_spin = sum(sum(J[d, i, :j, k]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N**2 + j * N + k][1] -= 1
        else:
          priorities[i * N**2 + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N**2 + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time07:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        
        total_spin = sum(J[d, i, j, :].sum() for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
          priorities[i * N * N + j * N + k][1] -= same_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
          priorities[i * N * N + j * N + k][1] = -same_spin_count
  
  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 0
#version_generated: 3
#generate time08:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return priorities




#score: {'data3D.txt': -0.49731140000000007}
#standard deviation: 0.039625450786584124
#island_id: 2
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time08:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * (1 if J[2, i, j, k - 1] < 0 else 1)
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * (1 if J[2, i, j, k - 1] > 0 else -1)
          priorities[i * N * N + j * N + k][1] += 1
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(J[0, i, j, k])) * (1 if neighbor_spin < 0 else 1)
          priorities[i * N * N + j * N + k][1] -= 1
        priorities[i * N * N + j * N + k][0] += h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
  return priorities




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        
        total_spin = sum(J[d, i, j, :].sum() for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
          priorities[i * N * N + j * N + k][1] -= same_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
          priorities[i * N * N + j * N + k][1] = -same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * same_spin_count
          priorities[i * N * N + j * N + k][1] -= opposite_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * opposite_spin_count
          priorities[i * N * N + j * N + k][1] = -same_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.042807000000000005}
#standard deviation: 0.047046253740335164
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(J[d, i, j, :].sum() for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
          priorities[i * N * N + j * N + k][1] -= same_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin_count - same_spin_count)
          priorities[i * N * N + j * N + k][1] = -opposite_spin_count
  
  return(priorities)




#score: {'data3D.txt': 0.3842842000000001}
#standard deviation: 0.04500063988833937
#island_id: 2
#version_generated: 3
#generate time08:07
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count)
          priorities[i * N * N + j * N + k][1] -= same_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (opposite_spin_count - same_spin_count)
          priorities[i * N * N + j * N + k][1] = -same_spin_count
  
  return priorities




#score: {'data3D.txt': -0.4634226}
#standard deviation: 0.04078876327176396
#island_id: 1
#version_generated: 2
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4531118}
#standard deviation: 0.04134124358023111
#island_id: 1
#version_generated: 2
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N], J[2, i, (i + 1) % N, k]]
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0025014000000000004}
#standard deviation: 0.04708857438954804
#island_id: 1
#version_generated: 2
#generate time08:08
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate the total interaction energy for each spin
        site_energy = sum(val * abs(val) for val in interacting_spins)
        
        # Calculate the total energy difference between spins
        delta_energy = sum(abs(val - h[i][j][k]) for val in interacting_spins)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (1 - 2*h[i][j][k]/delta_energy) * site_energy
        priorities[i * N * N + j * N + k][1] -= 2 - 2*h[i][j][k]
        
  return(priorities)




#score: {'data3D.txt': -0.06135379999999999}
#standard deviation: 0.15244542730288776
#island_id: 2
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d,i,j,:] for d in [0,1]))
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2,i,j,k-1]<0]) - 1) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2,i,j,k-1]>0]) - 1) - total_spin
          priorities[i*N*N+j*N+k][1] = -1
        
        for d in [0,1]:
          if i+(d-1)%2==0:
            neighbor_spin = J[d,i+d,j,k]
          else:
            neighbor_spin = J[1-d,i-d,j,k]
          if neighbor_spin<0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d,i,j,:] < 0]) - 1) * 2
            priorities[i*N*N+j*N+k][1] -= 2
          elif neighbor_spin>0:
            priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d,i,j,:] > 0]) - 1) * 2
            priorities[i*N*N+j*N+k][1] = 2
        
  for i in range(N):
    for j in range(N):
      for k in range(N):
        if h[i][j][k]>0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([J[3,i,j,k-1]<0]) - 1) + total_spin
          priorities[i*N*N+j*N+k][1] -= 1
        else:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * (np.sum([J[3,i,j,k-1]>0]) - 1) - total_spin
          priorities[i*N*N+j*N+k][1] = -1
        
  return(priorities)




#score: {'data3D.txt': -0.1089946}
#standard deviation: 0.05124639002739608
#island_id: 2
#version_generated: 3
#generate time08:09
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] < 0]) - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] > 0]) - 1) - total_spin
          priorities[i * N * N + j * N + k][1] = -1

        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, :] < 0]) - 1) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, :] > 0]) - 1) * 2
            priorities[i * N * N + j * N + k][1] = 2

  return(priorities)




#score: {'data3D.txt': -0.1089946}
#standard deviation: 0.05124639002739608
#island_id: 2
#version_generated: 3
#generate time08:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] < 0]) - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[2, i, j, k - 1] > 0]) - 1) - total_spin
          priorities[i * N * N + j * N + k][1] = -1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, :] < 0]) - 1) * 2
            priorities[i * N * N + j * N + k][1] -= 2
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (np.sum([J[d, i, j, :] > 0]) - 1) * 2
            priorities[i * N * N + j * N + k][1] = 2
        
  return(priorities)




#score: {'data3D.txt': -0.05936580000000001}
#standard deviation: 0.05430982517335146
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)

        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * same_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * same_spin_count

        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1

        for d in [0, 1]:
          if (i + (d-1) % 2 == 0):
            neighbor_spin = J[d, i+d, j, k]
          else:
            neighbor_spin = J[1-d, i-d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1

  return priorities




#score: {'data3D.txt': -0.10541379999999999}
#standard deviation: 0.04865036741443994
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [2]:
          neighbor_spin = J[d, i, j, k-1]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [4, 5]:
          neighbor_spin = J[d % 3, i-1 if i > 0 else N-2, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.017055}
#standard deviation: 0.04664409646461168
#island_id: 2
#version_generated: 3
#generate time08:11
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - 2) + total_spin
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - 2) + total_spin
          priorities[i * N * N + j * N + k][1] -= 4 - 2 * total_spin
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-same_spin_count) * (same_spin_count - 1)
        priorities[i * N * N + j * N + k][1] -= same_spin_count
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        neighbor_spin = J[2, i, j, k-1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * neighbor_spin
        elif neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(neighbor_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 2 - 2 * neighbor_spin
  
  return priorities




#score: {'data3D.txt': -0.005135400000000001}
#standard deviation: 0.04682577865706026
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(6):
          if i+int(d/2)%2 == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+(d%2), j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+(d%2), j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[5-d, i-(d%2), j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[5-d, i-(d%2), j, k]

  return(priorities)




#score: {'data3D.txt': -0.0023958000000000004}
#standard deviation: 0.0470765753040724
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1]]
        
        total_spin = sum(J[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(6):
          if i + (d-1)%2 == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+d, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[5-d, i-d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[5-d, i-d, j, k]

          if k > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[3, i, j, k-1]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[3, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.0031326}
#standard deviation: 0.047327102354147985
#island_id: 0
#version_generated: 3
#generate time08:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  interacting_spins = np.zeros((6, N, N, N))  
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
    interacting_spins[i+3] = np.roll(h, 1, axis=i)
    
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] * interacting_spins[d, i, j, k] for d in [0, 1])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins[0, i, j, k].flatten() if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]
        
  return(priorities)




#score: {'data3D.txt': -0.4634226}
#standard deviation: 0.04078876327176396
#island_id: 1
#version_generated: 3
#generate time08:13
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  
  return(priorities)




#score: {'data3D.txt': 0.10491979999999991}
#standard deviation: 0.05286261749062376
#island_id: 3
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] -= 4
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] += 4
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  return(priorities)




#score: {'data3D.txt': 0.046498599999999876}
#standard deviation: 0.05312801744880003
#island_id: 3
#version_generated: 3
#generate time08:14
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] -= 2
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 2
              priorities[i * N * N + j * N + k][1] += 2
          
          for d in [0, 1]:
            if (i + (d - 1) % 2 == 0):
              neighbor_spin = J[d, i + d, j, k]
            else:
              neighbor_spin = J[1 - d, i - d, j, k]
            if neighbor_spin < 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
              priorities[i * N * N + j * N + k][1] -= 4
            elif neighbor_spin > 0:
              priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 4
              priorities[i * N * N + j * N + k][1] += 4
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.0885026}
#standard deviation: 0.04751507038024883
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1, 2])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[0, i, j, k:] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': 0.0909878}
#standard deviation: 0.047889595228608896
#island_id: 2
#version_generated: 3
#generate time08:15
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_spin_count + 2*opposite_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_spin_count + 2*opposite_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.24415299999999998}
#standard deviation: 0.044192494283531905
#island_id: 1
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N], J[2, i, (i + 1) % N, k]]
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
            priorities[i * N * N + j * N + k][1] -= len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin
            priorities[i * N * N + j * N + k][1] += len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.43417259999999996}
#standard deviation: 0.044518042288941684
#island_id: 1
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin)
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N], J[2, i, (i + 1) % N, k]]
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4531118}
#standard deviation: 0.04134124358023111
#island_id: 1
#version_generated: 3
#generate time08:16
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in [J[0, i, j, k], J[1, i, (j + 1) % N, k], J[2, i, j, (k + 1) % N]] if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, i, j, (k + 1) % N], J[2, i, (i + 1) % N, k]]
        for d, neighbor in enumerate(site_neighbors):
          if neighbor < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 0
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  interacting_spins = np.zeros((6, N, N, N))
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis=i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis=i)

  for i in range(N):
    for j in range(N):
      for k in range(N):
        spin_energy = 0
        for d in [0, 1, 2]:
          if h[i][j][k] > 0:
            spin_energy += -J[d, i, j, k]*interacting_spins[d, i, j, k]
          elif h[i][j][k] < 0:
            spin_energy += J[d, i, j, k]*interacting_spins[d, i, j, k]

        priorities[i * N * N + j * N + k][0] = spin_energy
        priorities[i * N * N + j * N + k][1] = -2

  return(priorities)




#score: {'data3D.txt': -0.1995209999999999}
#standard deviation: 0.04593450423156868
#island_id: 0
#version_generated: 3
#generate time08:27
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in J[[0, 1, 2], i, j, k] if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

  return(priorities)




#score: {'data3D.txt': -0.34002740000000004}
#standard deviation: 0.045597410554109326
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4634226}
#standard deviation: 0.04078876327176396
#island_id: 1
#version_generated: 3
#generate time08:31
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.08926220000000001}
#standard deviation: 0.04669187778575628
#island_id: 3
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0]
        site_neighbors = []

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d][i][j][k])
            site_neighbors.append(J[d][(i + (d % 2)) % N][j][k] if h[i][j][k] > 0 else -J[d][(i + (d % 2)) % N][j][k])
          else:
            interacting_spins.append(J[d-3][i][min(j+1,N-1)][k])
            site_neighbors.append(J[d-3][min(i+1,N-1)][j][k] if h[i][j][k] > 0 else -J[d-3][min(i+1,N-1)][j][k])

        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if h[i][j][k] > 0 and val < 0]) - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if h[i][j][k] > 0 and val < 0]) - site_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.17169740000000003}
#standard deviation: 0.04408131478574567
#island_id: 3
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [0]
        site_neighbors = []

        for d in range(6):
          if d < 3:
            interacting_spins.append(J[d, (i + (d % 2)) % N, j, k])
            site_neighbors.append(J[d, i, (j + (d % 2)) % N, k] if h[i][j][k] > 0 else -J[d, i, (j + (d % 2)) % N, k])
          else:
            interacting_spins.append(J[d-3, i, j, (k + (d % 2)) % N])
            site_neighbors.append(J[d-3, i, j, (k + (d % 2)) % N] if h[i][j][k] > 0 else -J[d-3, i, j, (k + (d % 2)) % N])

        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if h[i][j][k] > 0 and val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * site_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin

  return(priorities)




#score: {'data3D.txt': -0.0708994}
#standard deviation: 0.04710252307085046
#island_id: 3
#version_generated: 3
#generate time08:35
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        site_neighbors = []
        
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k] if h[i][j][k] > 0 else -J[d, (i + (d % 2)) % N, j, k])
          else:
            site_neighbors.append(J[d-3, i, (j + 1) % N, k] if h[i][j][k] > 0 else -J[d-3, i, (j + 1) % N, k])
        
        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - site_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4634226}
#standard deviation: 0.04078876327176396
#island_id: 1
#version_generated: 3
#generate time08:36
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4784158}
#standard deviation: 0.04165759126929929
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        # Add a new term based on the magnitude of the spin
        if abs(h[i][j][k]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * abs(h[i][j][k])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

  return(priorities)




#score: {'data3D.txt': -0.4634226}
#standard deviation: 0.04078876327176396
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4634226}
#standard deviation: 0.04078876327176396
#island_id: 1
#version_generated: 3
#generate time08:37
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = sum([J[d, i, j, k] for d in [0, 1, 2]])
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0])
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0])
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0801002}
#standard deviation: 0.04755821359092455
#island_id: 3
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = []
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k])
          else:
            site_neighbors.append(J[3, i, (j + 1) % N, k])

        total_spin_site = sum([val for val in interacting_spins if h[i][j][k] > 0]) + sum([val for val in site_neighbors if h[i][j][k] > 0])
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin) + np.exp(-abs(total_spin_site)) * (len([val for val in site_neighbors if val < 0]) - total_spin_site)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 + 2 * total_spin_site

  return(priorities)




#score: {'data3D.txt': -0.1174542}
#standard deviation: 0.04981127404875326
#island_id: 3
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = []
        
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k] if h[i][j][k] > 0 else -J[d, (i + (d % 2)) % N, j, k])
          else:
            site_neighbors.append(J[d-3, i, (j + 1) % N, k] if h[i][j][k] > 0 else -J[d-3, i, (j + 1) % N, k])
        
        total_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin) + np.exp(-abs(total_neighbor_spin)) * (len([val for val in site_neighbors if val < 0]) - total_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin - 2 + 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1946242}
#standard deviation: 0.040662599208117524
#island_id: 3
#version_generated: 3
#generate time08:38
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        site_neighbors = []
        
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k] if h[i][j][k] > 0 else -J[d, (i + (d % 2)) % N, j, k])
          else:
            site_neighbors.append(J[d-3, i, (j + 1) % N, k] if h[i][j][k] > 0 else -J[d-3, i, (j + 1) % N, k])
        
        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - site_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin
        
        # Add a new term based on the total spin of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        
  return priorities




#score: {'data3D.txt': 0.2351466}
#standard deviation: 0.048755792973143204
#island_id: 3
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': 0.19183060000000002}
#standard deviation: 0.04727792279320233
#island_id: 3
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.2766906}
#standard deviation: 0.05365122171619207
#island_id: 3
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          # Add a new term based on the site's neighbors
          site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.2351466}
#standard deviation: 0.048755792973143204
#island_id: 3
#version_generated: 3
#generate time08:39
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.053531800000000004}
#standard deviation: 0.04619257374037519
#island_id: 0
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(3):
          if i + (d-1)%2 == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+d, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[1-d, i-d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[1-d, i-d, j, k]

        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i, j, k-1]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.053531800000000004}
#standard deviation: 0.04619257374037519
#island_id: 0
#version_generated: 3
#generate time08:40
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(3):
          if i + (d-1)%2 == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+d, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[1-d, i-d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[1-d, i-d, j, k]

        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i, j, k-1]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': -0.025352600000000003}
#standard deviation: 0.04650247513025516
#island_id: 0
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[0, i, j, k], J[1, i, (j+1)%N, k], J[2, i, j, (k+1)%N]]
        total_spin = sum(interacting_spins)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(3):
          if i+d < N and j+int(d/2)%N < N and k+int((d%2)*2) < N:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+d, j+int(d/2)%N, k+int((d%2)*2)]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+d, j+int(d/2)%N, k+int((d%2)*2)]

  return priorities




#score: {'data3D.txt': -0.053531800000000004}
#standard deviation: 0.04619257374037519
#island_id: 0
#version_generated: 3
#generate time08:41
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in [J[0, i, j, k], J[1, i, j, k]] if val < 0]) - total_spin)
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        elif h[i][j][k] < 0:
          priorities[i * N * N + j * N + k][0] = -priorities[i * N * N + j * N + k][0]
          priorities[i * N * N + j * N + k][1] = -priorities[i * N * N + j * N + k][1]

        for d in range(3):
          if i + (d-1)%2 == 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[d, i+d, j, k]
          else:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[1-d, i-d, j, k]
            priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[1-d, i-d, j, k]

        if k > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[2, i, j, k-1]
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * J[2, i, j, k-1]

  return(priorities)




#score: {'data3D.txt': 0.24741700000000036}
#standard deviation: 0.04520432801181763
#island_id: 3
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] = -np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] = np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.009110999999999994}
#standard deviation: 0.048718803341215186
#island_id: 3
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
        
        # Add a new term based on the magnetism of neighboring sites
        for d in [0, 1, 2]:
          if i > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i-1, j, k]
            priorities[i * N * N + j * N + k][1] -= J[d, i-1, j, k]
          if i < N - 1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i+1, j, k]
            priorities[i * N * N + j * N + k][1] -= J[d, i+1, j, k]
          if j > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, j-1, k]
            priorities[i * N * N + j * N + k][1] -= J[d, i, j-1, k]
          if j < N - 1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, j+1, k]
            priorities[i * N * N + j * N + k][1] -= J[d, i, j+1, k]
          if k > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, j, k-1]
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, k-1]
          if k < N - 1:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * J[d, i, j, k+1]
            priorities[i * N * N + j * N + k][1] -= J[d, i, j, k+1]
  
  return(priorities)




#score: {'data3D.txt': -0.47797900000000004}
#standard deviation: 0.04094119879778804
#island_id: 3
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the site's neighbors
        if sum([val for val in site_neighbors if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
        elif sum([val for val in site_neighbors if val > 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': 0.2351466}
#standard deviation: 0.048755792973143204
#island_id: 3
#version_generated: 3
#generate time08:44
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        
        # Calculate priority based on magnetism and neighboring spins
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
        priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
  
  return(priorities)




#score: {'data3D.txt': -0.15903420000000024}
#standard deviation: 0.04778493141524848
#island_id: 3
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.15903420000000024}
#standard deviation: 0.04778493141524848
#island_id: 3
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.15903420000000024}
#standard deviation: 0.04778493141524848
#island_id: 3
#version_generated: 3
#generate time08:45
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 3 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.34616379999999997}
#standard deviation: 0.04881559760527367
#island_id: 3
#version_generated: 3
#generate time08:47
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        neighbor_spin = J[0, i, j, k] if i == site_nbr else 0
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in interacting_spins if val < 0]) - len([val for val in interacting_spins if val > 0])) + 2 * neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.1946242}
#standard deviation: 0.040662599208117524
#island_id: 3
#version_generated: 3
#generate time08:48
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        site_neighbors = []
        
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k] if h[i][j][k] > 0 else -J[d, (i + (d % 2)) % N, j, k])
          else:
            site_neighbors.append(J[d-3, i, (j + 1) % N, k] if h[i][j][k] > 0 else -J[d-3, i, (j + 1) % N, k])
        
        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - site_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin
        
        # Add a new term based on the total spin of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        
  return priorities




#score: {'data3D.txt': -0.1946242}
#standard deviation: 0.040662599208117524
#island_id: 3
#version_generated: 3
#generate time08:51
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d][i][j][k] for d in range(6)]
        site_neighbors = []
        
        for d in range(6):
          if d < 3:
            site_neighbors.append(J[d, (i + (d % 2)) % N, j, k] if h[i][j][k] > 0 else -J[d, (i + (d % 2)) % N, j, k])
          else:
            site_neighbors.append(J[d-3, i, (j + 1) % N, k] if h[i][j][k] > 0 else -J[d-3, i, (j + 1) % N, k])
        
        total_spin = sum([val if h[i][j][k] > 0 else -val for val in interacting_spins])
        site_neighbor_spin = sum([val if h[i][j][k] > 0 else -val for val in site_neighbors])
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in interacting_spins if val < 0]) - total_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (len([val for val in site_neighbors if val < 0]) - site_neighbor_spin)
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * site_neighbor_spin
        
        # Add a new term based on the total spin of the site
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * total_spin
        priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.427989}
#standard deviation: 0.042042180711756624
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))

  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])

        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)

        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin

        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin

        # Add a new term based on the site's neighbors
        if sum([val for val in site_neighbors if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
        elif sum([val for val in site_neighbors if val > 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])

        # Add a new term based on the site's neighbors' neighbors
        site_neighbors_neighbors = [J[0, i, (j + 1) % N, (k + 1) % N], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 2) % N]]
        total_neighbor_neighbor_spin = sum(val for val in site_neighbors_neighbors)

        if sum([val for val in site_neighbors_neighbors if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors_neighbors if val < 0]) - sum([val for val in site_neighbors_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors_neighbors if val < 0])
        elif sum([val for val in site_neighbors_neighbors if val > 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors_neighbors if val > 0]) - sum([val for val in site_neighbors_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors_neighbors if val > 0])

  return(priorities)




#score: {'data3D.txt': -0.11476540000000017}
#standard deviation: 0.04703917051607098
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        if sum([val for val in site_neighbors if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
        elif sum([val for val in site_neighbors if val > 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the site's magnetism
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(h[i][j][k])) * (1 - sum([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * h[i][j][k]
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(h[i][j][k])) * (1 - sum([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * h[i][j][k]
  
  return(priorities)




#score: {'data3D.txt': -0.4088306}
#standard deviation: 0.04203701206841418
#island_id: 3
#version_generated: 3
#generate time08:53
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        # Add a new term based on the site's neighbors
        if sum([val for val in site_neighbors if val < 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val < 0]) - sum([val for val in site_neighbors if val > 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val < 0])
        elif sum([val for val in site_neighbors if val > 0]) > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (sum([val for val in site_neighbors if val > 0]) - sum([val for val in site_neighbors if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * sum([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (total_spin - len([val for val in interacting_spins if val < 0]))
          priorities[i * N * N + j * N + k][1] -= 2 * total_spin
        elif total_spin < 0:
          priorities[i * N * N + j * N + k][0] -= np.exp(abs(total_spin)) * (total_spin - len([val for val in interacting_spins if val > 0]))
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.3844914}
#standard deviation: 0.04938951716751238
#island_id: 0
#version_generated: 2
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.3404394}
#standard deviation: 0.040329227213523444
#island_id: 0
#version_generated: 2
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * len([val for val in site_neighbors if val < 0]) + 2 * len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.20233859999999998}
#standard deviation: 0.04843070627236402
#island_id: 0
#version_generated: 2
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0])
        priorities[i * N * N + j * N + k][1] -= 2 * (len([val for val in site_neighbors if val < 0]) - len([val for val in site_neighbors if val > 0]))
        
  return(priorities)




#score: {'data3D.txt': -0.2913758}
#standard deviation: 0.05251801304657289
#island_id: 0
#version_generated: 2
#generate time08:54
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -abs(total_spin) * np.exp(-abs(total_spin)) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.504559}
#standard deviation: 0.042060679488091966
#island_id: 0
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) - total_spin
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in interacting_spins if val > 0])
  
  return(priorities)




#score: {'data3D.txt': -0.464319}
#standard deviation: 0.046641260263847927
#island_id: 0
#version_generated: 3
#generate time08:55
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_spin
        priorities[i * N * N + j * N + k][1] -= sum([val for val in site_neighbors if val > 0]) - total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.10188939999999999}
#standard deviation: 0.04802828549552857
#island_id: 2
#version_generated: 3
#generate time08:56
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 4, 5]]
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1])
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - 1) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        for d in [2, 3]:
          neighbor_spin = J[d, i-1 if i > 0 else N-2, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
  
  return(priorities)




#score: {'data3D.txt': -0.2913758}
#standard deviation: 0.05251801304657289
#island_id: 0
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -abs(total_spin) * np.exp(-abs(total_spin)) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.0812554}
#standard deviation: 0.05416601970645434
#island_id: 0
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -abs(total_spin) * np.exp(-abs(total_spin)) + total_spin + h[i][j][k]
        if site_nbr > 0:
          priorities[i * N * N + j * N + k][1] -= abs(site_nbr)
        elif site_nbr < 0:
          priorities[i * N * N + j * N + k][1] += abs(site_nbr)
        
  return(priorities)




#score: {'data3D.txt': -0.2913758}
#standard deviation: 0.05251801304657289
#island_id: 0
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] = -abs(total_spin) * np.exp(-abs(total_spin)) + total_spin + h[i][j][k]
        priorities[i * N * N + j * N + k][1] = 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': 0.08748380000000003}
#standard deviation: 0.0472427676746399
#island_id: 0
#version_generated: 3
#generate time08:57
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        site_nbr = sum(val for val in site_neighbors)
        
        if total_spin > 0:
          priorities[i * N * N + j * N + k][0] = -abs(total_spin) * np.exp(-total_spin) + h[i][j][k]
          priorities[i * N * N + j * N + k][1] = -2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] = abs(total_spin) * np.exp(abs(total_spin)) - h[i][j][k]
          priorities[i * N * N + j * N + k][1] = 2 * total_spin
  
  return(priorities)




#score: {'data3D.txt': -0.29240340000000004}
#standard deviation: 0.04582824749474935
#island_id: 3
#version_generated: 3
#generate time08:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2822694}
#standard deviation: 0.04425806167965334
#island_id: 3
#version_generated: 3
#generate time08:58
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
        priorities[i * N * N + j * N + k][1] -= 3 - 2 * total_neighbor_spin
        
  return(priorities)




#score: {'data3D.txt': -0.29240340000000004}
#standard deviation: 0.04582824749474935
#island_id: 3
#version_generated: 3
#generate time08:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2817946}
#standard deviation: 0.04639411698523854
#island_id: 3
#version_generated: 3
#generate time08:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val < 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_neighbor_spin)) * len([val for val in site_neighbors if val > 0]) - total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time08:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
          
  return(priorities)




#score: {'data3D.txt': -0.2907322}
#standard deviation: 0.053258058574829785
#island_id: 3
#version_generated: 3
#generate time08:59
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) - total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) - total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.4759646}
#standard deviation: 0.04561189128768944
#island_id: 0
#version_generated: 3
#generate time09:02
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3,2))
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d,i,j,k] for d in [0,1,2]]
        total_spin = sum(J[d,i,j,k] for d in [0,1,2])
        
        site_neighbors = [J[0,i,(j+1)%N,k], J[1,(i+1)%N,j,k], J[2,i,j,(k+1)%N]]
        site_nbr = sum(val for val in site_neighbors)
        
        if h[i][j][k] > 0:
          priorities[i*N*N+j*N+k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        else:
          priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i*N*N+j*N+k][1] = -2 + 2 * total_spin
        
        site_nbr += sum(val for val in interacting_spins)
        
        priorities[i*N*N+j*N+k][0] -= np.exp(-abs(total_spin)) * len([val for val in [site_nbr]+interacting_spins if val < 0]) + total_spin
        priorities[i*N*N+j*N+k][1] -= 2 - 2 * total_spin
        
  return(priorities)




#score: {'data3D.txt': -0.555059}
#standard deviation: 0.04218580139098937
#island_id: 1
#version_generated: 2
#generate time09:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum([val for val in site_neighbors if val < 0])
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.0030534}
#standard deviation: 0.04700053349101476
#island_id: 1
#version_generated: 2
#generate time09:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        total_neighbor_spin = sum(val for val in site_neighbors)
        
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
        priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val < 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_neighbor_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in site_neighbors if val > 0]) + total_neighbor_spin
          priorities[i * N * N + j * N + k][1] += 2 - 2 * total_neighbor_spin
        
        return(priorities)




#score: {'data3D.txt': -0.5573542}
#standard deviation: 0.03899346640605321
#island_id: 1
#version_generated: 2
#generate time09:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.43673500000000004}
#standard deviation: 0.04196872424794445
#island_id: 1
#version_generated: 2
#generate time09:03
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': 0.09617219999999999}
#standard deviation: 0.046588586447326344
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2, 3, 4, 5]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1, 2, 3, 4, 5])
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_spin_count + 2*opposite_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_spin_count + 2*opposite_spin_count
        
  return(priorities)




#score: {'data3D.txt': -0.0022994000000000005}
#standard deviation: 0.04707471932619461
#island_id: 2
#version_generated: 3
#generate time09:04
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in range(6)]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(J[d, i, j, k] for d in range(6))
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_spin_count + 2*opposite_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_spin_count + 2*opposite_spin_count
        
  return(priorities)




#score: {'data3D.txt': 0.04077699999999993}
#standard deviation: 0.059148164392481384
#island_id: 2
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        
        same_spin_count = sum(1 for neighbor in interacting_spins if neighbor > 0)
        opposite_spin_count = sum(1 for neighbor in interacting_spins if neighbor < 0)
        
        total_spin = sum(sum(J[d, i, j, :]) for d in [0, 1, 2])
        
        same_neighbor_spin_count = sum(1 for neighbor in interacting_spins if abs(neighbor) == 1)
        opposite_neighbor_spin_count = sum(1 for neighbor in interacting_spins if abs(neighbor) == -1)
        
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_neighbor_spin_count - opposite_neighbor_spin_count + 2*opposite_spin_count
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * (same_spin_count - opposite_spin_count) + total_spin
          priorities[i * N * N + j * N + k][1] -= same_neighbor_spin_count - opposite_neighbor_spin_count - 2*opposite_spin_count
  
  return(priorities)




#score: {'data3D.txt': -0.5019262000000001}
#standard deviation: 0.04230677621327345
#island_id: 1
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4641438}
#standard deviation: 0.041369626558140464
#island_id: 1
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.5019262000000001}
#standard deviation: 0.04230677621327345
#island_id: 1
#version_generated: 3
#generate time09:05
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.47555820000000004}
#standard deviation: 0.04179905038107924
#island_id: 1
#version_generated: 3
#generate time09:06
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k], J[2, i, j, (k + 1) % N]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4883234000000001}
#standard deviation: 0.03922015416134924
#island_id: 2
#version_generated: 3
#generate time09:10
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        
        # Add a new term based on the local energy
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * h[i][j][k]
        priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the number of nearest neighbors with the same spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin < 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the number of nearest neighbors with the opposite spin
        neighbor_spin = J[2, i, j, k - 1]
        if neighbor_spin > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] += 1
        else:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
          priorities[i * N * N + j * N + k][1] -= 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
        # Add a new term based on the total spin of the site's neighbors
        for d in [0, 1]:
          if (i + (d - 1) % 2 == 0):
            neighbor_spin = J[d, i + d, j, k]
          else:
            neighbor_spin = J[1 - d, i - d, j, k]
          if neighbor_spin < 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] -= 1
          elif neighbor_spin > 0:
            priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * 1
            priorities[i * N * N + j * N + k][1] += 1
        
  return(priorities)




#score: {'data3D.txt': -0.4641438}
#standard deviation: 0.041369626558140464
#island_id: 1
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4641438}
#standard deviation: 0.041369626558140464
#island_id: 1
#version_generated: 3
#generate time09:12
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = np.zeros((N**3, 2))
  
  for i in range(N):
    for j in range(N):
      for k in range(N):
        interacting_spins = [J[d, i, j, k] for d in [0, 1, 2]]
        total_spin = sum(J[d, i, j, k] for d in [0, 1, 2])
        
        site_nbr = (i + ((k - 1) % 2 - 1)) % N
        if h[i][j][k] > 0:
          priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val < 0]) + total_spin
          priorities[i * N * N + j * N + k][1] -= 2 - 2 * total_spin
        else:
          priorities[i * N * N + j * N + k][0] -= np.exp(-abs(total_spin)) * len([val for val in interacting_spins if val > 0]) + total_spin
          priorities[i * N * N + j * N + k][1] = -2 + 2 * total_spin
        
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
        # Add a new term based on the total spin of the site's neighbors
        site_neighbors = [J[0, i, (j + 1) % N, k], J[1, (i + 1) % N, j, k]]
        priorities[i * N * N + j * N + k][0] += np.exp(-abs(total_spin)) * sum(1 for val in site_neighbors if val < 0)
        priorities[i * N * N + j * N + k][1] -= len([val for val in site_neighbors if val > 0])
        
  return(priorities)




#score: {'data3D.txt': -0.4916790000000001}
#standard deviation: 0.05384134729926433
#island_id: None
#version_generated: None
#generate time09:17
program:
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.optimize import minimize
import itertools
from evaluate import evaluate
import funsearch

def priority(N, h, J):
  priorities = h
  interacting_spins = np.zeros((6,N,N,N))  # D X N^D matrix of neighboring spins along each axis
  for i in range(3):
    interacting_spins[i] = np.roll(h, -1, axis = i)
  for i in range(3):
    interacting_spins[i+3] = np.roll(h, 1, axis = i)
  for i in range(N):
    for j in range(N):
      for k in range(N):
        for l in range(6):
            priorities[i,j,k] += -J[l,i,j,k]*interacting_spins[l,i,j,k]
  priorities = np.array([priorities.flatten(), np.zeros(N**3)]).T
  return(priorities)




